import 'core-js/proposals/json-parse-with-source.js';
import { ViewKey, ComputeKey, Address, PrivateKeyCiphertext, PrivateKey, RecordCiphertext, EncryptionToolkit, Group, Metadata, VerifyingKey, Program, Plaintext, Transaction, ProvingRequest, ProvingKey, RecordPlaintext, Field, Poseidon4, ProgramManager as ProgramManager$1, verifyFunctionExecution } from '@provablehq/wasm/testnet.js';
export { Address, Authorization, BHP1024, BHP256, BHP512, BHP768, Boolean, Ciphertext, ComputeKey, EncryptionToolkit, ExecutionRequest, ExecutionResponse, Field, Execution as FunctionExecution, GraphKey, Group, I128, I16, I32, I64, I8, OfflineQuery, Pedersen128, Pedersen64, Plaintext, Poseidon2, Poseidon4, Poseidon8, PrivateKey, PrivateKeyCiphertext, Program, ProgramManager as ProgramManagerBase, ProvingKey, ProvingRequest, RecordCiphertext, RecordPlaintext, Scalar, Signature, Transaction, Transition, U128, U16, U32, U64, U8, VerifyingKey, ViewKey, getOrInitConsensusVersionTestHeights, initThreadPool, verifyFunctionExecution } from '@provablehq/wasm/testnet.js';
import { bech32m } from '@scure/base';

/**
 * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from
 * an existing private key or seed, and message signing and verification functionality. An Aleo Account is generated
 * from a randomly generated seed (number) from which an account private key, view key, and a public account address are
 * derived. The private key lies at the root of an Aleo account. It is a highly sensitive secret and should be protected
 * as it allows for creation of Aleo Program executions and arbitrary value transfers. The View Key allows for decryption
 * of a user's activity on the blockchain. The Address is the public address to which other users of Aleo can send Aleo
 * credits and other records to. This class should only be used in environments where the safety of the underlying key
 * material can be assured.
 *
 * @example
 * import { Account } from "@provablehq/sdk/testnet.js";
 *
 * // Create a new account
 * const myRandomAccount = new Account();
 *
 * // Create an account from a randomly generated seed
 * const seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);
 * const mySeededAccount = new Account({seed: seed});
 *
 * // Create an account from an existing private key
 * const myExistingAccount = new Account({privateKey: process.env.privateKey});
 *
 * // Sign a message
 * const hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100]);
 * const signature = myRandomAccount.sign(hello_world);
 *
 * // Verify a signature
 * assert(myRandomAccount.verify(hello_world, signature));
 */
class Account {
    _privateKey;
    _viewKey;
    _computeKey;
    _address;
    constructor(params = {}) {
        try {
            this._privateKey = this.privateKeyFromParams(params);
        }
        catch (e) {
            console.error("Wrong parameter", e);
            throw new Error("Wrong Parameter");
        }
        this._viewKey = ViewKey.from_private_key(this._privateKey);
        this._computeKey = ComputeKey.from_private_key(this._privateKey);
        this._address = Address.from_private_key(this._privateKey);
    }
    /**
     * Attempts to create an account from a private key ciphertext
     * @param {PrivateKeyCiphertext | string} ciphertext The encrypted private key ciphertext or its string representation
     * @param {string} password The password used to decrypt the private key ciphertext
     * @returns {Account} A new Account instance created from the decrypted private key
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create an account object from a previously encrypted ciphertext and password.
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     */
    static fromCiphertext(ciphertext, password) {
        try {
            ciphertext = (typeof ciphertext === "string") ? PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;
            const _privateKey = PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);
            return new Account({ privateKey: _privateKey.to_string() });
        }
        catch (e) {
            throw new Error("Wrong password or invalid ciphertext");
        }
    }
    /**
     * Creates a PrivateKey from the provided parameters.
     * @param {AccountParam} params The parameters containing either a private key string or a seed
     * @returns {PrivateKey} A PrivateKey instance derived from the provided parameters
     */
    privateKeyFromParams(params) {
        if (params.seed) {
            return PrivateKey.from_seed_unchecked(params.seed);
        }
        if (params.privateKey) {
            return PrivateKey.from_string(params.privateKey);
        }
        return new PrivateKey();
    }
    /**
     * Returns the PrivateKey associated with the account.
     * @returns {PrivateKey} The private key of the account
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const privateKey = account.privateKey();
     */
    privateKey() {
        return this._privateKey;
    }
    /**
     * Returns the ViewKey associated with the account.
     * @returns {ViewKey} The view key of the account
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const viewKey = account.viewKey();
     */
    viewKey() {
        return this._viewKey;
    }
    /**
     * Returns the ComputeKey associated with the account.
     * @returns {ComputeKey} The compute key of the account
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const computeKey = account.computeKey();
     */
    computeKey() {
        return this._computeKey;
    }
    /**
     * Returns the Aleo address associated with the account.
     * @returns {Address} The public address of the account
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const address = account.address();
     */
    address() {
        return this._address;
    }
    /**
     * Deep clones the Account.
     * @returns {Account} A new Account instance with the same private key
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const clonedAccount = account.clone();
     */
    clone() {
        return new Account({ privateKey: this._privateKey.to_string() });
    }
    /**
     * Returns the address of the account in a string representation.
     *
     * @returns {string} The string representation of the account address
     */
    toString() {
        return this.address().to_string();
    }
    /**
     * Encrypts the account's private key with a password.
     *
     * @param {string} password Password to encrypt the private key.
     * @returns {PrivateKeyCiphertext} The encrypted private key ciphertext
     *
     * @example
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * const account = new Account();
     * const ciphertext = account.encryptAccount("password");
     * process.env.ciphertext = ciphertext.toString();
     */
    encryptAccount(password) {
        return this._privateKey.toCiphertext(password);
    }
    /**
     * Decrypts an encrypted record string into a plaintext record object.
     *
     * @param {string} ciphertext A string representing the ciphertext of a record.
     * @returns {RecordPlaintext} The decrypted record plaintext
     *
     * @example
     * // Import the AleoNetworkClient and Account classes
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create a connection to the Aleo network and an account
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
     *
     * // Get the record ciphertexts from a transaction.
     * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
     * const records = transaction.records();
     *
     * // Decrypt any records the account owns.
     * const decryptedRecords = [];
     * for (const record of records) {
     *    if (account.decryptRecord(record)) {
     *      decryptedRecords.push(record);
     *    }
     * }
     */
    decryptRecord(ciphertext) {
        return this._viewKey.decrypt(ciphertext);
    }
    /**
     * Decrypts an array of Record ciphertext strings into an array of record plaintext objects.
     *
     * @param {string[]} ciphertexts An array of strings representing the ciphertexts of records.
     * @returns {RecordPlaintext[]} An array of decrypted record plaintexts
     *
     * @example
     * // Import the AleoNetworkClient and Account classes
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create a connection to the Aleo network and an account
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
     *
     * // Get the record ciphertexts from a transaction.
     * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
     * const records = transaction.records();
     *
     * // Decrypt any records the account owns. If the account owns no records, the array will be empty.
     * const decryptedRecords = account.decryptRecords(records);
     */
    decryptRecords(ciphertexts) {
        return ciphertexts.map((ciphertext) => this._viewKey.decrypt(ciphertext));
    }
    /**
     * Generates a record view key from the account owner's view key and the record ciphertext.
     * This key can be used to decrypt the record without revealing the account's view key.
     * @param {RecordCiphertext | string} recordCiphertext The record ciphertext to generate the view key for
     * @returns {Field} The record view key
     *
     * @example
     * // Import the Account class
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create an account object from a previously encrypted ciphertext and password.
     * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
     *
     * // Generate a record view key from the account's view key and a record ciphertext
     * const recordCiphertext = RecordCiphertext.fromString("your_record_ciphertext_here");
     * const recordViewKey = account.generateRecordViewKey(recordCiphertext);
     */
    generateRecordViewKey(recordCiphertext) {
        if (typeof recordCiphertext === 'string') {
            recordCiphertext = RecordCiphertext.fromString(recordCiphertext);
        }
        if (!(recordCiphertext.isOwner(this._viewKey))) {
            throw new Error("The record ciphertext does not belong to this account");
        }
        return EncryptionToolkit.generateRecordViewKey(this._viewKey, recordCiphertext);
    }
    /**
     * Generates a transition view key from the account owner's view key and the transition public key.
     * This key can be used to decrypt the private inputs and outputs of a the transition without
     * revealing the account's view key.
     * @param {string | Group} tpk The transition public key
     * @returns {Field} The transition view key
     *
     * @example
     * // Import the Account class
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * // Generate a transition view key from the account's view key and a transition public key
     * const tpk = Group.fromString("your_transition_public_key_here");
     *
     * const transitionViewKey = account.generateTransitionViewKey(tpk);
     */
    generateTransitionViewKey(tpk) {
        if (typeof tpk === 'string') {
            tpk = Group.fromString(tpk);
        }
        return EncryptionToolkit.generateTvk(this._viewKey, tpk);
    }
    /**
     * Determines whether the account owns a ciphertext record.
     * @param {RecordCiphertext | string} ciphertext The record ciphertext to check ownership of
     * @returns {boolean} True if the account owns the record, false otherwise
     *
     * @example
     * // Import the AleoNetworkClient and Account classes
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create a connection to the Aleo network and an account
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const account = Account.fromCiphertext(process.env.ciphertext!, process.env.password!);
     *
     * // Get the record ciphertexts from a transaction and check ownership of them.
     * const transaction = await networkClient.getTransactionObject("at1fjy6s9md2v4rgcn3j3q4qndtfaa2zvg58a4uha0rujvrn4cumu9qfazxdd");
     * const records = transaction.records();
     *
     * // Check if the account owns any of the record ciphertexts present in the transaction.
     * const ownedRecords = [];
     * for (const record of records) {
     *    if (account.ownsRecordCiphertext(record)) {
     *      ownedRecords.push(record);
     *    }
     * }
     */
    ownsRecordCiphertext(ciphertext) {
        if (typeof ciphertext === 'string') {
            try {
                const ciphertextObject = RecordCiphertext.fromString(ciphertext);
                return ciphertextObject.isOwner(this._viewKey);
            }
            catch (e) {
                return false;
            }
        }
        else {
            return ciphertext.isOwner(this._viewKey);
        }
    }
    /**
     * Signs a message with the account's private key.
     * Returns a Signature.
     *
     * @param {Uint8Array} message Message to be signed.
     * @returns {Signature} Signature over the message in bytes.
     *
     * @example
     * // Import the Account class
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create a connection to the Aleo network and an account
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     *
     * // Create an account and a message to sign.
     * const account = new Account();
     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
     * const signature = account.sign(message);
     *
     * // Verify the signature.
     * assert(account.verify(message, signature));
     */
    sign(message) {
        return this._privateKey.sign(message);
    }
    /**
     * Verifies the Signature on a message.
     *
     * @param {Uint8Array} message Message in bytes to be signed.
     * @param {Signature} signature Signature to be verified.
     * @returns {boolean} True if the signature is valid, false otherwise.
     *
     * @example
     * // Import the Account class
     * import { Account } from "@provablehq/sdk/testnet.js";
     *
     * // Create a connection to the Aleo network and an account
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     *
     * // Sign a message.
     * const message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])
     * const signature = account.sign(message);
     *
     * // Verify the signature.
     * assert(account.verify(message, signature));
     */
    verify(message, signature) {
        return this._address.verify(message, signature);
    }
}

function detectBrowser() {
    const userAgent = navigator.userAgent;
    if (/chrome|crios|crmo/i.test(userAgent) && !/edge|edg|opr/i.test(userAgent)) {
        return "chrome";
    }
    else if (/firefox|fxios/i.test(userAgent)) {
        return "firefox";
    }
    else if (/safari/i.test(userAgent) && !/chrome|crios|crmo|android/i.test(userAgent)) {
        return "safari";
    }
    else if (/edg/i.test(userAgent)) {
        return "edge";
    }
    else if (/opr\//i.test(userAgent)) {
        return "opera";
    }
    else {
        return "browser";
    }
}
function environment() {
    if ((typeof process !== 'undefined') &&
        (process.release?.name === 'node')) {
        return 'node';
    }
    else if (typeof window !== 'undefined') {
        return detectBrowser();
    }
    else {
        return 'unknown';
    }
}
function logAndThrow(message) {
    console.error(message);
    throw new Error(message);
}
function parseJSON(json) {
    function revive(key, value, context) {
        if (Number.isInteger(value)) {
            return BigInt(context.source);
        }
        else {
            return value;
        }
    }
    return JSON.parse(json, revive);
}
async function get(url, options) {
    const response = await fetch(url, options);
    if (!response.ok) {
        throw new Error(response.status + " could not get URL " + url);
    }
    return response;
}
async function post(url, options) {
    options.method = "POST";
    const response = await fetch(url, options);
    if (!response.ok) {
        const error = await response.text();
        let message = `${response.status} error received from ${url}`;
        if (error) {
            message = `${error}`;
        }
        throw new Error(message);
    }
    return response;
}
async function retryWithBackoff(fn, { maxAttempts = 5, baseDelay = 100, jitter, retryOnStatus = [], shouldRetry, } = {}) {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            return await fn();
        }
        catch (err) {
            const isLast = attempt === maxAttempts;
            const error = err;
            let retryable = false;
            if (typeof error.status === "number") {
                if (error.status >= 500) {
                    retryable = true;
                }
                else if (error.status >= 400 && shouldRetry) {
                    retryable = shouldRetry(error);
                }
            }
            else if (shouldRetry) {
                retryable = shouldRetry(error);
            }
            if (!retryable || isLast)
                throw error;
            const jitterAmount = jitter ?? baseDelay;
            const actualJitter = Math.floor(Math.random() * jitterAmount);
            const delay = baseDelay * 2 ** (attempt - 1) + actualJitter;
            console.warn(`Retry ${attempt}/${maxAttempts} failed. Retrying in ${delay}ms...`);
            await new Promise((res) => setTimeout(res, delay));
        }
    }
    throw new Error("retryWithBackoff: unreachable");
}

const KEY_STORE = Metadata.baseUrl();
function convert(metadata) {
    // This looks up the method name in VerifyingKey
    const verifyingKey = VerifyingKey[metadata.verifyingKey];
    if (!verifyingKey) {
        throw new Error("Invalid method name: " + metadata.verifyingKey);
    }
    return {
        name: metadata.name,
        locator: metadata.locator,
        prover: metadata.prover,
        verifier: metadata.verifier,
        verifyingKey,
    };
}
const CREDITS_PROGRAM_KEYS = {
    bond_public: convert(Metadata.bond_public()),
    bond_validator: convert(Metadata.bond_validator()),
    claim_unbond_public: convert(Metadata.claim_unbond_public()),
    fee_private: convert(Metadata.fee_private()),
    fee_public: convert(Metadata.fee_public()),
    inclusion: convert(Metadata.inclusion()),
    join: convert(Metadata.join()),
    set_validator_state: convert(Metadata.set_validator_state()),
    split: convert(Metadata.split()),
    transfer_private: convert(Metadata.transfer_private()),
    transfer_private_to_public: convert(Metadata.transfer_private_to_public()),
    transfer_public: convert(Metadata.transfer_public()),
    transfer_public_as_signer: convert(Metadata.transfer_public_as_signer()),
    transfer_public_to_private: convert(Metadata.transfer_public_to_private()),
    unbond_public: convert(Metadata.unbond_public()),
    getKey: function (key) {
        if (this.hasOwnProperty(key)) {
            return this[key];
        }
        else {
            throw new Error(`Key "${key}" not found.`);
        }
    }
};
const PRIVATE_TRANSFER_TYPES = new Set([
    "transfer_private",
    "private",
    "transferPrivate",
    "transfer_private_to_public",
    "privateToPublic",
    "transferPrivateToPublic",
]);
const VALID_TRANSFER_TYPES = new Set([
    "transfer_private",
    "private",
    "transferPrivate",
    "transfer_private_to_public",
    "privateToPublic",
    "transferPrivateToPublic",
    "transfer_public",
    "transfer_public_as_signer",
    "public",
    "public_as_signer",
    "transferPublic",
    "transferPublicAsSigner",
    "transfer_public_to_private",
    "publicToPrivate",
    "publicAsSigner",
    "transferPublicToPrivate",
]);
const PRIVATE_TRANSFER = new Set([
    "private",
    "transfer_private",
    "transferPrivate",
]);
const PRIVATE_TO_PUBLIC_TRANSFER = new Set([
    "private_to_public",
    "privateToPublic",
    "transfer_private_to_public",
    "transferPrivateToPublic",
]);
const PUBLIC_TRANSFER = new Set([
    "public",
    "transfer_public",
    "transferPublic",
]);
const PUBLIC_TRANSFER_AS_SIGNER = new Set([
    "public_as_signer",
    "transfer_public_as_signer",
    "transferPublicAsSigner",
]);
const PUBLIC_TO_PRIVATE_TRANSFER = new Set([
    "public_to_private",
    "publicToPrivate",
    "transfer_public_to_private",
    "transferPublicToPrivate",
]);
const RECORD_DOMAIN = "RecordScannerV0";
/**
 * Zero address on Aleo blockchain that corresponds to field element 0. Used as padding in Merkle trees and as a sentinel value.
 */
const ZERO_ADDRESS = "aleo1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3ljyzc";
const FIVE_MINUTES = 5 * 60 * 1000; // 5 minutes in milliseconds

/**
 * Client library that encapsulates REST calls to publicly exposed endpoints of Aleo nodes. The methods provided in this
 * allow users to query public information from the Aleo blockchain and submit transactions to the network.
 *
 * @param {string} host
 * @example
 * // Connection to a local node.
 * const localNetworkClient = new AleoNetworkClient("http://0.0.0.0:3030", undefined, account);
 *
 * // Connection to a public beacon node
 * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
 * const apiKey = process.env.apiKey;
 * const consumerId = process.env.consumerId;
 * const publicNetworkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined, account);
 */
class AleoNetworkClient {
    host;
    headers;
    account;
    ctx;
    verboseErrors;
    network;
    apiKey;
    consumerId;
    jwtData;
    constructor(host, options) {
        this.host = host + "/testnet";
        this.network = "testnet";
        this.ctx = {};
        this.verboseErrors = true;
        if (options && options.headers) {
            this.headers = options.headers;
        }
        else {
            this.headers = {
                // This is replaced by the actual version by a Rollup plugin
                "X-Aleo-SDK-Version": "0.9.14",
                "X-Aleo-environment": environment(),
            };
        }
    }
    /**
     * Set an account to use in networkClient calls
     *
     * @param {Account} account Set an account to use for record scanning functions.
     * @example
     * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1");
     * const account = new Account();
     * networkClient.setAccount(account);
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Return the Aleo account used in the networkClient
     *
     * @example
     * const account = networkClient.getAccount();
     */
    getAccount() {
        return this.account;
    }
    /**
     * Set a new host for the networkClient
     *
     * @param {string} host The address of a node hosting the Aleo API
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a networkClient that connects to a local node.
     * const networkClient = new AleoNetworkClient("http://0.0.0.0:3030", undefined);
     *
     * // Set the host to a public node.
     * networkClient.setHost("http://api.explorer.provable.com/v1");
     */
    setHost(host) {
        this.host = host + "/testnet";
    }
    /**
     * Set verbose errors to true or false for the `AleoNetworkClient`. When set to true, if `submitTransaction` fails, the failure responses will report descriptive information as to why the transaction failed.
     *
     * @param {boolean} verboseErrors Set verbose error mode to true or false for the AleoNetworkClient.
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a networkClient
     * const networkClient = new AleoNetworkClient();
     *
     * // Set debug mode to true
     * networkClient.setVerboseTransactionErrors(true);
     **/
    setVerboseErrors(verboseErrors) {
        this.verboseErrors = verboseErrors;
    }
    /**
     * Set a header in the `AleoNetworkClient`s header map
     *
     * @param {string} headerName The name of the header to set
     * @param {string} value The header value
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a networkClient
     * const networkClient = new AleoNetworkClient();
     *
     * // Set the value of the `Accept-Language` header to `en-US`
     * networkClient.setHeader('Accept-Language', 'en-US');
     */
    setHeader(headerName, value) {
        this.headers[headerName] = value;
    }
    removeHeader(headerName) {
        delete this.headers[headerName];
    }
    /**
     * Fetches data from the Aleo network and returns it as a JSON object.
     *
     * @param url The URL to fetch data from.
     */
    async fetchData(url = "/") {
        try {
            const raw = await this.fetchRaw(url);
            return parseJSON(raw);
        }
        catch (error) {
            throw new Error(`Error fetching data: ${error}`);
        }
    }
    /**
     * Fetches data from the Aleo network and returns it as an unparsed string.
     *
     * This method should be used when it is desired to reconstitute data returned
     * from the network into a WASM object.
     *
     * @param url
     */
    async fetchRaw(url = "/") {
        try {
            const ctx = { ...this.ctx };
            return await retryWithBackoff(async () => {
                const response = await get(this.host + url, {
                    headers: {
                        ...this.headers,
                        ...ctx,
                    },
                });
                return await response.text();
            });
        }
        catch (error) {
            throw new Error(`Error fetching data: ${error}`);
        }
    }
    /**
     * Wrapper around the POST helper to allow mocking in tests. Not meant for use in production.
     *
     * @param url The URL to POST to.
     * @param options The RequestInit options for the POST request.
     * @returns The Response object from the POST request.
     */
    async _sendPost(url, options) {
        return post(url, options);
    }
    /**
     * Attempt to find records in the Aleo blockchain.
     *
     * @param {number} startHeight - The height at which to start searching for unspent records
     * @param {number} endHeight - The height at which to stop searching for unspent records
     * @param {boolean} unspent - Whether to search for unspent records only
     * @param {string[]} programs - The program(s) to search for unspent records in
     * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])
     * @param {number} maxMicrocredits - The maximum number of microcredits to search for
     * @param {string[]} nonces - The nonces of already found records to exclude from the search
     * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.
     * @returns {Promise<Array<RecordPlaintext>>} An array of records belonging to the account configured in the network client.
     *
     * @example
     * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Import an account from a ciphertext and password.
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * networkClient.setAccount(account);
     *
     * // Find specific amounts
     * const startHeight = 500000;
     * const amounts = [600000, 1000000];
     * const records = networkClient.findRecords(startHeight, undefined, true, ["credits.aleo"] amounts);
     *
     * // Find specific amounts with a maximum number of cumulative microcredits
     * const maxMicrocredits = 100000;
     * const records = networkClient.findRecords(startHeight, undefined, true, ["credits.aleo"] undefined, maxMicrocredits);
     */
    async findRecords(startHeight, endHeight, unspent = false, programs, amounts, maxMicrocredits, nonces, privateKey) {
        nonces = nonces || [];
        // Ensure start height is not negative
        if (startHeight < 0) {
            throw new Error("Start height must be greater than or equal to 0");
        }
        // Initialize search parameters
        const records = new Array();
        let start;
        let end;
        let resolvedPrivateKey;
        let failures = 0;
        let totalRecordValue = BigInt(0);
        let latestHeight;
        // Ensure a private key is present to find owned records
        if (typeof privateKey === "undefined") {
            if (typeof this.account === "undefined") {
                throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");
            }
            else {
                resolvedPrivateKey = this.account._privateKey;
            }
        }
        else {
            try {
                resolvedPrivateKey =
                    privateKey instanceof PrivateKey
                        ? privateKey
                        : PrivateKey.from_string(privateKey);
            }
            catch (error) {
                throw new Error("Error parsing private key provided.");
            }
        }
        const viewKey = resolvedPrivateKey.to_view_key();
        // Get the latest height to ensure the range being searched is valid
        try {
            const blockHeight = await this.getLatestHeight();
            if (typeof blockHeight === "number") {
                latestHeight = blockHeight;
            }
            else {
                throw new Error(`Error fetching latest block height: Expected type 'number' got '${typeof blockHeight}'`);
            }
        }
        catch (error) {
            throw new Error(`Error fetching latest block height: ${error}`);
        }
        // If no end height is specified or is greater than the latest height, set the end height to the latest height
        if (typeof endHeight === "number" && endHeight <= latestHeight) {
            end = endHeight;
        }
        else {
            end = latestHeight;
        }
        // If the starting is greater than the ending height, return an error
        if (startHeight > end) {
            throw new Error("Start height must be less than or equal to end height.");
        }
        // Iterate through blocks in reverse order in chunks of 50
        while (end > startHeight) {
            start = end - 50;
            if (start < startHeight) {
                start = startHeight;
            }
            try {
                // Get 50 blocks (or the difference between the start and end if less than 50)
                const blocks = await this.getBlockRange(start, end);
                end = start;
                // Iterate through blocks to find unspent records
                for (let i = 0; i < blocks.length; i++) {
                    const block = blocks[i];
                    const transactions = block.transactions;
                    if (!(typeof transactions === "undefined")) {
                        for (let j = 0; j < transactions.length; j++) {
                            const confirmedTransaction = transactions[j];
                            // Search for unspent records in execute transactions of credits.aleo
                            if (confirmedTransaction.type == "execute") {
                                const transaction = confirmedTransaction.transaction;
                                if (transaction.execution &&
                                    !(typeof transaction.execution
                                        .transitions == "undefined")) {
                                    for (let k = 0; k <
                                        transaction.execution.transitions
                                            .length; k++) {
                                        const transition = transaction.execution.transitions[k];
                                        // Only search for unspent records in the specified programs.
                                        if (!(typeof programs === "undefined")) {
                                            if (!programs.includes(transition.program)) {
                                                continue;
                                            }
                                        }
                                        if (!(typeof transition.outputs ==
                                            "undefined")) {
                                            for (let l = 0; l < transition.outputs.length; l++) {
                                                const output = transition.outputs[l];
                                                if (output.type === "record") {
                                                    try {
                                                        // Create a wasm record ciphertext object from the found output
                                                        const record = RecordCiphertext.fromString(output.value);
                                                        // Determine if the record is owned by the specified view key
                                                        if (record.isOwner(viewKey)) {
                                                            // Decrypt the record and get the serial number
                                                            const recordPlaintext = record.decrypt(viewKey);
                                                            // If the record has already been found, skip it
                                                            const nonce = recordPlaintext.nonce();
                                                            if (nonces.includes(nonce)) {
                                                                continue;
                                                            }
                                                            if (unspent) {
                                                                const recordViewKey = recordPlaintext.recordViewKey(viewKey).toString();
                                                                // Otherwise record the nonce that has been found
                                                                const serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, "credits.aleo", "credits", recordViewKey);
                                                                // Attempt to see if the serial number is spent
                                                                try {
                                                                    await retryWithBackoff(() => this.getTransitionId(serialNumber));
                                                                    continue;
                                                                }
                                                                catch (error) {
                                                                    console.log("Found unspent record!");
                                                                }
                                                            }
                                                            // Add the record to the list of records if the user did not specify amounts.
                                                            if (!amounts) {
                                                                records.push(recordPlaintext);
                                                                // If the user specified a maximum number of microcredits, check if the search has found enough
                                                                if (typeof maxMicrocredits ===
                                                                    "number") {
                                                                    totalRecordValue +=
                                                                        recordPlaintext.microcredits();
                                                                    // Exit if the search has found the amount specified
                                                                    if (totalRecordValue >=
                                                                        BigInt(maxMicrocredits)) {
                                                                        return records;
                                                                    }
                                                                }
                                                            }
                                                            // If the user specified a list of amounts, check if the search has found them
                                                            if (!(typeof amounts ===
                                                                "undefined") &&
                                                                amounts.length >
                                                                    0) {
                                                                let amounts_found = 0;
                                                                if (recordPlaintext.microcredits() >
                                                                    amounts[amounts_found]) {
                                                                    amounts_found += 1;
                                                                    records.push(recordPlaintext);
                                                                    // If the user specified a maximum number of microcredits, check if the search has found enough
                                                                    if (typeof maxMicrocredits ===
                                                                        "number") {
                                                                        totalRecordValue +=
                                                                            recordPlaintext.microcredits();
                                                                        // Exit if the search has found the amount specified
                                                                        if (totalRecordValue >=
                                                                            BigInt(maxMicrocredits)) {
                                                                            return records;
                                                                        }
                                                                    }
                                                                    if (records.length >=
                                                                        amounts.length) {
                                                                        return records;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    catch (error) { }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (error) {
                // If there is an error fetching blocks, log it and keep searching
                console.warn("Error fetching blocks in range: " +
                    start.toString() +
                    "-" +
                    end.toString());
                console.warn("Error: ", error);
                failures += 1;
                if (failures > 10) {
                    console.warn("10 failures fetching records reached. Returning records fetched so far");
                    return records;
                }
            }
        }
        return records;
    }
    /**
     * Attempts to find unspent records in the Aleo blockchain.
     *
     * @param {number} startHeight - The height at which to start searching for unspent records
     * @param {number} endHeight - The height at which to stop searching for unspent records
     * @param {string[]} programs - The program(s) to search for unspent records in
     * @param {number[]} amounts - The amounts (in microcredits) to search for (eg. [100, 200, 3000])
     * @param {number} maxMicrocredits - The maximum number of microcredits to search for
     * @param {string[]} nonces - The nonces of already found records to exclude from the search
     * @param {string | PrivateKey} privateKey - An optional private key to use to find unspent records.
     * @returns {Promise<Array<RecordPlaintext>>} An array of unspent records belonging to the account configured in the network client.
     *
     * @example
     * import { Account, AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     *
     * // Create a network client and set an account to search for records with.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * networkClient.setAccount(account);
     *
     * // Find specific amounts
     * const startHeight = 500000;
     * const endHeight = 550000;
     * const amounts = [600000, 1000000];
     * const records = networkClient.findUnspentRecords(startHeight, endHeight, ["credits.aleo"], amounts);
     *
     * // Find specific amounts with a maximum number of cumulative microcredits
     * const maxMicrocredits = 100000;
     * const records = networkClient.findUnspentRecords(startHeight, undefined, ["credits.aleo"], undefined, maxMicrocredits);
     */
    async findUnspentRecords(startHeight, endHeight, programs, amounts, maxMicrocredits, nonces, privateKey) {
        try {
            this.ctx = { "X-ALEO-METHOD": "findUnspentRecords" };
            return await this.findRecords(startHeight, endHeight, true, programs, amounts, maxMicrocredits, nonces, privateKey);
        }
        catch (error) {
            throw new Error("Error finding unspent records: " + error);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the contents of the block at the specified block height.
     *
     * @param {number} blockHeight - The height of the block to fetch
     * @returns {Promise<BlockJSON>} A javascript object containing the block at the specified height
     *
     * @example
     * const block = networkClient.getBlock(1234);
     */
    async getBlock(blockHeight) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getBlock" };
            const block = await this.fetchData("/block/" + blockHeight);
            return block;
        }
        catch (error) {
            throw new Error(`Error fetching block ${blockHeight}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the contents of the block with the specified hash.
     *
     * @param {string} blockHash The hash of the block to fetch.
     * @returns {Promise<BlockJSON>} A javascript object representation of the block matching the hash.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const block = networkClient.getBlockByHash("ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9");
     */
    async getBlockByHash(blockHash) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getBlockByHash" };
            const block = await this.fetchData(`/block/${blockHash}`);
            return block;
        }
        catch (error) {
            throw new Error(`Error fetching block ${blockHash}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns a range of blocks between the specified block heights. A maximum of 50 blocks can be fetched at a time.
     *
     * @param {number} start Starting block to fetch.
     * @param {number} end Ending block to fetch. This cannot be more than 50 blocks ahead of the start block.
     * @returns {Promise<Array<BlockJSON>>} An array of block objects
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Fetch 50 blocks.
     * const (start, end) = (2050, 2100);
     * const blockRange = networkClient.getBlockRange(start, end);
     *
     * let cursor = start;
     * blockRange.forEach((block) => {
     *   assert(block.height == cursor);
     *   cursor += 1;
     *  }
     */
    async getBlockRange(start, end) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getBlockRange" };
            return await this.fetchData("/blocks?start=" + start + "&end=" + end);
        }
        catch (error) {
            throw new Error(`Error fetching blocks between ${start} and ${end}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the deployment transaction id associated with the specified program.
     *
     * @param {Program | string} program The name of the deployed program OR a wasm Program object.
     * @returns {Promise<string>} The transaction ID of the deployment transaction.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
     *
     * // Get the transaction ID of the deployment transaction for a program.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const transactionId = networkClient.getDeploymentTransactionIDForProgram("hello_hello.aleo");
     *
     * // Get the transaction data for the deployment transaction.
     * const transaction = networkClient.getTransactionObject(transactionId);
     *
     * // Get the verifying keys for the functions in the deployed program.
     * const verifyingKeys = transaction.verifyingKeys();
     */
    async getDeploymentTransactionIDForProgram(program) {
        this.ctx = { "X-ALEO-METHOD": "getDeploymentTransactionIDForProgram" };
        if (program instanceof Program) {
            program = program.id();
        }
        try {
            const id = await this.fetchData("/find/transactionID/deployment/" + program);
            return id.replace('"', "");
        }
        catch (error) {
            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the deployment transaction associated with a specified program as a JSON object.
     *
     * @param {Program | string} program The name of the deployed program OR a wasm Program object.
     * @returns {Promise<Transaction>} JSON representation of the deployment transaction.
     *
     * @example
     * import { AleoNetworkClient, DeploymentJSON } from "@provablehq/sdk/testnet.js";
     *
     * // Get the transaction ID of the deployment transaction for a program.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const transaction = networkClient.getDeploymentTransactionForProgram("hello_hello.aleo");
     *
     * // Get the verifying keys for each function in the deployment.
     * const deployment = <DeploymentJSON>transaction.deployment;
     * const verifyingKeys = deployment.verifying_keys;
     */
    async getDeploymentTransactionForProgram(program) {
        if (program instanceof Program) {
            program = program.id();
        }
        try {
            this.ctx = { "X-ALEO-METHOD": "getDeploymentTransactionForProgram" };
            const transaction_id = (await this.getDeploymentTransactionIDForProgram(program));
            return await this.getTransaction(transaction_id);
        }
        catch (error) {
            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the deployment transaction associated with a specified program as a wasm object.
     *
     * @param {Program | string} program The name of the deployed program OR a wasm Program object.
     * @returns {Promise<Transaction>} Wasm object representation of the deployment transaction.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
     *
     * // Get the transaction ID of the deployment transaction for a program.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const transactionId = networkClient.getDeploymentTransactionIDForProgram("hello_hello.aleo");
     *
     * // Get the transaction data for the deployment transaction.
     * const transaction = networkClient.getDeploymentTransactionObjectForProgram(transactionId);
     *
     * // Get the verifying keys for the functions in the deployed program.
     * const verifyingKeys = transaction.verifyingKeys();
     */
    async getDeploymentTransactionObjectForProgram(program) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getDeploymentTransactionObjectForProgram" };
            const transaction_id = (await this.getDeploymentTransactionIDForProgram(program));
            return await this.getTransactionObject(transaction_id);
        }
        catch (error) {
            throw new Error(`Error fetching deployment transaction for program ${program}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the contents of the latest block as JSON.
     *
     * @returns {Promise<BlockJSON>} A javascript object containing the latest block
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/testnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const latestHeight = networkClient.getLatestBlock();
     */
    async getLatestBlock() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getLatestBlock" };
            return (await this.fetchData("/block/latest"));
        }
        catch (error) {
            throw new Error(`Error fetching latest block: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the latest committee.
     *
     * @returns {Promise<object>} A javascript object containing the latest committee
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Create a network client and get the latest committee.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const latestCommittee = await networkClient.getLatestCommittee();
     */
    async getLatestCommittee() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getLatestCommittee" };
            return await this.fetchData("/committee/latest");
        }
        catch (error) {
            throw new Error(`Error fetching latest committee: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the committee at the specified block height.
     *
     * @param {number} blockHeight - The height of the block to fetch the committee for
     * @returns {Promise<object>} A javascript object containing the committee
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Create a network client and get the committee for a specific block.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const committee = await networkClient.getCommitteeByBlockHeight(1234);
     */
    async getCommitteeByBlockHeight(blockHeight) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getCommitteeByBlockHeight" };
            return await this.fetchData(`/committee/${blockHeight}`);
        }
        catch (error) {
            throw new Error(`Error fetching committee at height ${blockHeight}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the latest block height.
     *
     * @returns {Promise<number>} The latest block height.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const latestHeight = networkClient.getLatestHeight();
     */
    async getLatestHeight() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getLatestHeight" };
            return Number(await this.fetchData("/block/height/latest"));
        }
        catch (error) {
            throw new Error(`Error fetching latest height: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the latest block hash.
     *
     * @returns {Promise<string>} The latest block hash.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the latest block hash.
     * const latestHash = networkClient.getLatestBlockHash();
     */
    async getLatestBlockHash() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getLatestBlockHash" };
            return String(await this.fetchData("/block/hash/latest"));
        }
        catch (error) {
            throw new Error(`Error fetching latest hash: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the source code of a program given a program ID.
     *
     * @param {string} programId The program ID of a program deployed to the Aleo Network.
     * @param {number | undefined} edition The edition of the program to fetch. When this is undefined it will fetch the latest version.
     * @returns {Promise<string>} The source code of the program.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the source code of a program.)
     * @returns {Promise<string>} Source code of the program
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const program = networkClient.getProgram("hello_hello.aleo");
     * const expectedSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
     * assert.equal(program, expectedSource);
     */
    async getProgram(programId, edition) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramVersion" };
            if (typeof edition === "number") {
                return await this.fetchData(`/program/${programId}/${edition}`);
            }
            else {
                return await this.fetchData("/program/" + programId);
            }
        }
        catch (error) {
            throw new Error(`Error fetching program ${programId}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the current program edition deployed on the Aleo network.
     *
     * @param {string} programId The program ID of a program deployed to the Aleo Network.
     * @returns {Promise<number>} The edition of the program.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const programVersion = networkClient.getLatestProgramEdition("hello_hello.aleo");
     * assert.equal(programVersion, 1);
     */
    async getLatestProgramEdition(programId) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getLatestProgramEdition" };
            const raw = await this.fetchRaw("/program/" + programId + "/latest_edition");
            return JSON.parse(raw);
        }
        catch (error) {
            throw new Error(`Error fetching program ${programId}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns a program object from a program ID or program source code.
     *
     * @param {string} inputProgram The program ID or program source code of a program deployed to the Aleo Network.
     * @param {number | undefined} edition The edition of the program to fetch. When this is undefined it will fetch the latest version.
     * @returns {Promise<Program>} Source code of the program.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const programID = "hello_hello.aleo";
     * const programSource = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n"
     *
     * // Get program object from program ID or program source code
     * const programObjectFromID = await networkClient.getProgramObject(programID);
     * const programObjectFromSource = await networkClient.getProgramObject(programSource);
     *
     * // Both program objects should be equal
     * assert(programObjectFromID.to_string() === programObjectFromSource.to_string());
     */
    async getProgramObject(inputProgram, edition) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramObject" };
            return Program.fromString(await this.getProgram(inputProgram, edition));
        }
        catch (error) {
            throw new Error(`${inputProgram} is neither a program name or a valid program: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     *  Returns an object containing the source code of a program and the source code of all programs it imports
     *
     * @param {Program | string} inputProgram The program ID or program source code of a program deployed to the Aleo Network
     * @returns {Promise<ProgramImports>} Object of the form { "program_id": "program_source", .. } containing program id & source code for all program imports
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * const double_test_source = "import multiply_test.aleo;\n\nprogram double_test.aleo;\n\nfunction double_it:\n    input r0 as u32.private;\n    call multiply_test.aleo/multiply 2u32 r0 into r1;\n    output r1 as u32.private;\n"
     * const double_test = Program.fromString(double_test_source);
     * const expectedImports = {
     *     "multiply_test.aleo": "program multiply_test.aleo;\n\nfunction multiply:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    mul r0 r1 into r2;\n    output r2 as u32.private;\n"
     * }
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Imports can be fetched using the program ID, source code, or program object
     * let programImports = await networkClient.getProgramImports("double_test.aleo");
     * assert.deepStrictEqual(programImports, expectedImports);
     *
     * // Using the program source code
     * programImports = await networkClient.getProgramImports(double_test_source);
     * assert.deepStrictEqual(programImports, expectedImports);
     *
     * // Using the program object
     * programImports = await networkClient.getProgramImports(double_test);
     * assert.deepStrictEqual(programImports, expectedImports);
     */
    async getProgramImports(inputProgram, imports = {}) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramImports" };
            // Normalize input to a Program object
            let program;
            if (inputProgram instanceof Program) {
                program = inputProgram;
            }
            else {
                try {
                    program = Program.fromString(inputProgram);
                }
                catch {
                    try {
                        program = await this.getProgramObject(inputProgram);
                    }
                    catch (error2) {
                        throw new Error(`${inputProgram} is neither a program name nor a valid program: ${error2}`);
                    }
                }
            }
            // Get the list of programs that the program imports
            const importList = program.getImports();
            // Recursively get any imports that the imported programs have in a depth-first search
            for (let i = 0; i < importList.length; i++) {
                const import_id = importList[i];
                if (!imports.hasOwnProperty(import_id)) {
                    const programSource = await this.getProgram(import_id);
                    const nestedImports = await this.getProgramImports(programSource, imports);
                    for (const key in nestedImports) {
                        if (!imports.hasOwnProperty(key)) {
                            imports[key] = nestedImports[key];
                        }
                    }
                    imports[import_id] = programSource;
                }
            }
            return imports;
        }
        catch (error) {
            logAndThrow("Error fetching program imports: " + error.message);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Get a list of the program names that a program imports.
     *
     * @param {Program | string} inputProgram - The program id or program source code to get the imports of
     * @returns {string[]} - The list of program names that the program imports
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const programImportsNames = networkClient.getProgramImports("wrapped_credits.aleo");
     * const expectedImportsNames = ["credits.aleo"];
     * assert.deepStrictEqual(programImportsNames, expectedImportsNames);
     */
    async getProgramImportNames(inputProgram) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramImportNames" };
            const program = inputProgram instanceof Program
                ? inputProgram
                : await this.getProgramObject(inputProgram);
            return program.getImports();
        }
        catch (error) {
            throw new Error(`Error fetching imports for program ${inputProgram instanceof Program ? inputProgram.id() : inputProgram}: ${error.message}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the names of the mappings of a program.
     *
     * @param {string} programId - The program ID to get the mappings of (e.g. "credits.aleo")
     * @returns {Promise<Array<string>>} - The names of the mappings of the program.
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const mappings = networkClient.getProgramMappingNames("credits.aleo");
     * const expectedMappings = [
     *   "committee",
     *   "delegated",
     *   "metadata",
     *   "bonded",
     *   "unbonding",
     *   "account",
     *   "withdraw"
     * ];
     * assert.deepStrictEqual(mappings, expectedMappings);
     */
    async getProgramMappingNames(programId) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramMappingNames" };
            return await this.fetchData(`/program/${programId}/mappings`);
        }
        catch (error) {
            throw new Error(`Error fetching mappings for program ${programId} - ensure the program exists on chain before trying again: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the value of a program's mapping for a specific key.
     *
     * @param {string} programId - The program ID to get the mapping value of (e.g. "credits.aleo")
     * @param {string} mappingName - The name of the mapping to get the value of (e.g. "account")
     * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the "account" mapping)
     * @returns {Promise<string>} String representation of the value of the mapping
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get public balance of an account
     * const mappingValue = networkClient.getMappingValue("credits.aleo", "account", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px");
     * const expectedValue = "0u64";
     * assert(mappingValue === expectedValue);
     */
    async getProgramMappingValue(programId, mappingName, key) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramMappingValue" };
            const keyString = key instanceof Plaintext ? key.toString() : key;
            return await this.fetchData(`/program/${programId}/mapping/${mappingName}/${keyString}`);
        }
        catch (error) {
            throw new Error(`Error fetching value for key '${key}' in mapping '${mappingName}' in program '${programId}' - ensure the mapping exists and the key is correct: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the value of a mapping as a wasm Plaintext object. Returning an object in this format allows it to be converted to a Js type and for its internal members to be inspected if it's a struct or array.
     *
     * @param {string} programId - The program ID to get the mapping value of (e.g. "credits.aleo")
     * @param {string} mappingName - The name of the mapping to get the value of (e.g. "bonded")
     * @param {string | Plaintext} key - The key to look up in the mapping (e.g. an address for the "bonded" mapping)
     * @returns {Promise<Plaintext>} String representation of the value of the mapping
     *
     * @example
     * import { AleoNetworkClient } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the bond state as an account.
     * const unbondedState = networkClient.getMappingPlaintext("credits.aleo", "bonded", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px");
     *
     * // Get the two members of the object individually.
     * const validator = unbondedState.getMember("validator");
     * const microcredits = unbondedState.getMember("microcredits");
     *
     * // Ensure the expected values are correct.
     * assert.equal(validator, "aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd");
     * assert.equal(microcredits, BigInt("9007199254740991"));
     *
     * // Get a JS object representation of the unbonded state.
     * const unbondedStateObject = unbondedState.toObject();
     *
     * const expectedState = {
     *     validator: "aleo1u6940v5m0fzud859xx2c9tj2gjg6m5qrd28n636e6fdd2akvfcgqs34mfd",
     *     microcredits: BigInt(9007199254740991)
     * };
     * assert.equal(unbondedState, expectedState);
     */
    async getProgramMappingPlaintext(programId, mappingName, key) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getProgramMappingPlaintext" };
            const keyString = key instanceof Plaintext ? key.toString() : key;
            const value = await this.fetchRaw(`/program/${programId}/mapping/${mappingName}/${keyString}`);
            return Plaintext.fromString(JSON.parse(value));
        }
        catch (error) {
            throw new Error("Failed to fetch mapping value." + error);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the public balance of an address from the account mapping in credits.aleo
     *
     * @param {Address | string} address A string or wasm object representing an address.
     * @returns {Promise<number>} The public balance of the address in microcredits.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the balance of an account from either an address object or address string.
     * const account = Account.fromCiphertext(process.env.ciphertext, process.env.password);
     * const publicBalance = await networkClient.getPublicBalance(account.address());
     * const publicBalanceFromString = await networkClient.getPublicBalance(account.address().to_string());
     * assert(publicBalance === publicBalanceFromString);
     */
    async getPublicBalance(address) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getPublicBalance" };
            const addressString = address instanceof Address ? address.to_string() : address;
            const balanceStr = await this.getProgramMappingValue("credits.aleo", "account", addressString);
            return balanceStr ? parseInt(balanceStr) : 0;
        }
        catch (error) {
            throw new Error(`Error fetching public balance for ${address}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the latest state/merkle root of the Aleo blockchain.
     *
     * @returns {Promise<string>} A string representing the latest state root of the Aleo blockchain.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the latest state root.
     * const stateRoot = networkClient.getStateRoot();
     */
    async getStateRoot() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getStateRoot" };
            return await this.fetchData("/stateRoot/latest");
        }
        catch (error) {
            throw new Error(`Error fetching latest state root: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns a transaction by its unique identifier.
     *
     * @param {string} transactionId The transaction ID to fetch.
     * @returns {Promise<TransactionJSON>} A json representation of the transaction.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const transaction = networkClient.getTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
     */
    async getTransaction(transactionId) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransaction" };
            return await this.fetchData("/transaction/" + transactionId);
        }
        catch (error) {
            throw new Error(`Error fetching transaction ${transactionId}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns a confirmed transaction by its unique identifier.
     *
     * @param {string} transactionId The transaction ID to fetch.
     * @returns {Promise<ConfirmedTransactionJSON>} A json object containing the confirmed transaction.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const transaction = networkClient.getConfirmedTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
     * assert.equal(transaction.status, "confirmed");
     */
    async getConfirmedTransaction(transactionId) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getConfirmedTransaction" };
            return await this.fetchData(`/transaction/confirmed/${transactionId}`);
        }
        catch (error) {
            throw new Error(`Error fetching confirmed transaction ${transactionId}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns a transaction as a wasm object. Getting a transaction of this type will allow the ability for the inputs,
     * outputs, and records to be searched for and displayed.
     *
     * @param {string} transactionId - The unique identifier of the transaction to fetch
     * @returns {Promise<Transaction>} A wasm object representation of the transaction.
     *
     * @example
     * const transactionObject = networkClient.getTransaction("at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj");
     * // Get the transaction inputs as a JS array.
     * const transactionInputs = transactionObject.inputs(true);
     *
     * // Get the transaction outputs as a JS object.
     * const transactionOutputs = transactionObject.outputs(true);
     *
     * // Get any records generated in transitions in the transaction as a JS object.
     * const records = transactionObject.records();
     *
     * // Get the transaction type.
     * const transactionType = transactionObject.transactionType();
     * assert.equal(transactionType, "Execute");
     *
     * // Get a JS representation of all inputs, outputs, and transaction metadata.
     * const transactionSummary = transactionObject.summary();
     */
    async getTransactionObject(transactionId) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransactionObject" };
            const transaction = await this.fetchRaw("/transaction/" + transactionId);
            return Transaction.fromString(transaction);
        }
        catch (error) {
            throw new Error(`Error fetching transaction object ${transactionId}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the transactions present at the specified block height.
     *
     * @param {number} blockHeight The block height to fetch the confirmed transactions at.
     * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block height.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const transactions = networkClient.getTransactions(654);
     */
    async getTransactions(blockHeight) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransactions" };
            return await this.fetchData("/block/" + blockHeight.toString() + "/transactions");
        }
        catch (error) {
            throw new Error(`Error fetching transactions: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the confirmed transactions present in the block with the specified block hash.
     *
     * @param {string} blockHash The block hash to fetch the confirmed transactions at.
     * @returns {Promise<Array<ConfirmedTransactionJSON>>} An array of confirmed transactions (in JSON format) for the block hash.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * const transactions = networkClient.getTransactionsByBlockHash("ab19dklwl9vp63zu3hwg57wyhvmqf92fx5g8x0t6dr72py8r87pxupqfne5t9");
     */
    async getTransactionsByBlockHash(blockHash) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransactionsByBlockHash" };
            const block = await this.fetchData(`/block/${blockHash}`);
            const height = block.header.metadata.height;
            return await this.getTransactions(Number(height));
        }
        catch (error) {
            throw new Error(`Error fetching transactions for block ${blockHash}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the transactions in the memory pool. This method requires access to a validator's REST API.
     *
     * @returns {Promise<Array<TransactionJSON>>} An array of transactions (in JSON format) currently in the mempool.
     *
     * @example
     * import { AleoNetworkClient, Account } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     *
     * // Get the current transactions in the mempool.
     * const transactions = networkClient.getTransactionsInMempool();
     */
    async getTransactionsInMempool() {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransactionsInMempool" };
            return await this.fetchData("/memoryPool/transactions");
        }
        catch (error) {
            throw new Error(`Error fetching transactions from mempool: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Returns the transition ID of the transition corresponding to the ID of the input or output.
     * @param {string} inputOrOutputID - The unique identifier of the input or output to find the transition ID for
     * @returns {Promise<string>} - The transition ID of the input or output ID.
     *
     * @example
     * const transitionId = networkClient.getTransitionId("2429232855236830926144356377868449890830704336664550203176918782554219952323field");
     */
    async getTransitionId(inputOrOutputID) {
        try {
            this.ctx = { "X-ALEO-METHOD": "getTransitionId" };
            return await this.fetchData("/find/transitionID/" + inputOrOutputID);
        }
        catch (error) {
            throw new Error(`Error fetching transition ID for input/output ${inputOrOutputID}: ${error}`);
        }
        finally {
            this.ctx = {};
        }
    }
    /**
     * Submit an execute or deployment transaction to the Aleo network.
     *
     * @param {Transaction | string} transaction - The transaction to submit, either as a Transaction object or string representation
     * @returns {Promise<string>} - The transaction id of the submitted transaction or the resulting error
     */
    async submitTransaction(transaction) {
        const transactionString = transaction instanceof Transaction
            ? transaction.toString()
            : transaction;
        try {
            const endpoint = this.verboseErrors ? "transaction/broadcast?check_transaction=true" : "transaction/broadcast";
            const response = await retryWithBackoff(() => this._sendPost(`${this.host}/${endpoint}`, {
                body: transactionString,
                headers: Object.assign({}, { ...this.headers, "X-ALEO-METHOD": "submitTransaction" }, {
                    "Content-Type": "application/json",
                }),
            }));
            try {
                const text = await response.text();
                return parseJSON(text);
            }
            catch (error) {
                throw new Error(`Error posting transaction. Aleo network response: ${error.message}`);
            }
        }
        catch (error) {
            throw new Error(`Error posting transaction: ${error}`);
        }
    }
    /**
     * Submit a solution to the Aleo network.
     *
     * @param {string} solution - The string representation of the solution to submit
     * @returns {Promise<string>} The solution id of the submitted solution or the resulting error.
     */
    async submitSolution(solution) {
        try {
            const response = await retryWithBackoff(() => post(this.host + "/solution/broadcast", {
                body: solution,
                headers: Object.assign({}, { ...this.headers, "X-ALEO-METHOD": "submitSolution" }, {
                    "Content-Type": "application/json",
                }),
            }));
            try {
                const text = await response.text();
                return parseJSON(text);
            }
            catch (error) {
                throw new Error(`Error posting solution. Aleo network response: ${error.message}`);
            }
        }
        catch (error) {
            throw new Error(`Error posting solution: No response received: ${error.message}`);
        }
    }
    /**
     * Refreshes the JWT by making a POST request to /jwts/{consumer_id}
     *
     * @param {string} apiKey - The API key for authentication.
     * @param {string} consumerId - The consumer ID associated with the API key.
     * @returns {Promise<JwtData>} The JWT token and expiration time
     */
    async refreshJwt(apiKey, consumerId) {
        if (!apiKey || !consumerId) {
            throw new Error('API key and consumer ID are required to refresh JWT');
        }
        const response = await post(`https://api.provable.com/jwts/${consumerId}`, {
            headers: {
                'X-Provable-API-Key': apiKey
            }
        });
        const authHeader = response.headers.get('authorization');
        if (!authHeader) {
            throw new Error('No authorization header in JWT refresh response');
        }
        const body = await response.json();
        return {
            jwt: authHeader,
            expiration: body.exp * 1000 // Convert to milliseconds
        };
    }
    /**
     * Submit a `ProvingRequest` to a remote proving service for delegated proving. If the broadcast flag of the `ProvingRequest` is set to `true` the remote service will attempt to broadcast the result `Transaction` on behalf of the requestor.
     *
     * @param {DelegatedProvingParams} options - The optional parameters required to submit a proving request.
     * @returns {Promise<ProvingResponse>} The ProvingResponse containing the transaction result and the result of the broadcast if the `broadcast` flag was set to `true`.
     */
    async submitProvingRequest(options) {
        const proverUri = options.url ?? this.host;
        const provingRequestString = options.provingRequest instanceof ProvingRequest
            ? options.provingRequest.toString()
            : options.provingRequest;
        const apiKey = options.apiKey ?? this.apiKey;
        const consumerId = options.consumerId ?? this.consumerId;
        let jwtData = options.jwtData ?? this.jwtData;
        // Check if JWT is expired or missing
        const bufferTime = FIVE_MINUTES; // 5 minutes buffer
        const isExpired = jwtData && Date.now() >= jwtData.expiration - bufferTime;
        if (!jwtData || isExpired) {
            if (options.apiKey && options.consumerId) {
                jwtData = await this.refreshJwt(apiKey, consumerId);
                // Update both the class and the options with the new JWT
                this.jwtData = jwtData;
                options.jwtData = jwtData;
            }
            else {
                throw new Error('JWT or both apiKey and consumerId are required');
            }
        }
        const headers = {
            ...this.headers,
            "X-ALEO-METHOD": "submitProvingRequest",
            "Content-Type": "application/json",
        };
        if (jwtData?.jwt) {
            headers["Authorization"] = jwtData.jwt;
        }
        try {
            const response = await retryWithBackoff(() => post(`${proverUri}`, {
                body: provingRequestString,
                headers
            }));
            const responseText = await response.text();
            return parseJSON(responseText);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            throw new Error(`Failed to submit proving request: ${errorMessage}`);
        }
    }
    /**
     * Await a submitted transaction to be confirmed or rejected on the Aleo network.
     *
     * @param {string} transactionId - The transaction ID to wait for confirmation
     * @param {number} checkInterval - The interval in milliseconds to check for confirmation (default: 2000)
     * @param {number} timeout - The maximum time in milliseconds to wait for confirmation (default: 45000)
     * @returns {Promise<Transaction>} The confirmed transaction object that returns if the transaction is confirmed.
     *
     * @example
     * import { AleoNetworkClient, Account, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a network client and program manager.
     * const networkClient = new AleoNetworkClient("http://api.explorer.provable.com/v1", undefined);
     * const programManager = new ProgramManager(networkClient);
     *
     * // Set the account for the program manager.
     * programManager.setAccount(Account.fromCiphertext(process.env.ciphertext, process.env.password));
     *
     * // Build a transfer transaction.
     * const tx = await programManager.buildTransferPublicTransaction(100, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0);
     *
     * // Submit the transaction to the network.
     * const transactionId = await networkClient.submitTransaction(tx);
     *
     * // Wait for the transaction to be confirmed.
     * const transaction = await networkClient.waitForTransactionConfirmation(transactionId);
     */
    async waitForTransactionConfirmation(transactionId, checkInterval = 2000, timeout = 45000) {
        const startTime = Date.now();
        return new Promise((resolve, reject) => {
            const interval = setInterval(async () => {
                const elapsed = Date.now() - startTime;
                if (elapsed > timeout) {
                    clearInterval(interval);
                    return reject(new Error(`Transaction ${transactionId} did not appear after the timeout period of ${interval}ms - consider resubmitting the transaction`));
                }
                try {
                    const res = await fetch(`${this.host}/transaction/confirmed/${transactionId}`, {
                        headers: {
                            ...this.headers,
                            "X-ALEO-METHOD": "waitForTransactionConfirmation",
                        },
                    });
                    if (!res.ok) {
                        let text = "";
                        try {
                            text = await res.text();
                            console.warn("Response text from server:", text);
                        }
                        catch (err) {
                            console.warn("Failed to read response text:", err);
                        }
                        // If the transaction ID is malformed (e.g. invalid checksum, wrong length),
                        // the API returns a 4XX with "Invalid URL"  we treat this as a fatal error and stop polling.
                        if (res.status >= 400 &&
                            res.status < 500 &&
                            text.includes("Invalid URL")) {
                            clearInterval(interval);
                            return reject(new Error(`Malformed transaction ID: ${text}`));
                        }
                        // Log and continue polling for 404s or 5XX errors in case a tx doesn't exist yet
                        console.warn("Non-OK response (retrying):", res.status, text);
                        return;
                    }
                    const data = parseJSON(await res.text());
                    if (data?.status === "accepted") {
                        clearInterval(interval);
                        return resolve(data);
                    }
                    if (data?.status === "rejected") {
                        clearInterval(interval);
                        return reject(new Error(`Transaction ${transactionId} was rejected by the network. Ensure that the account paying the fee has enough credits and that the inputs to the on-chain function are valid.`));
                    }
                }
                catch (err) {
                    console.error("Polling error:", err);
                }
            }, checkInterval);
        });
    }
}

/**
 * AleoKeyProviderParams search parameter for the AleoKeyProvider. It allows for the specification of a proverUri and
 * verifierUri to fetch keys via HTTP from a remote resource as well as a unique cacheKey to store the keys in memory.
 */
class AleoKeyProviderParams {
    name;
    proverUri;
    verifierUri;
    cacheKey;
    /**
     * Create a new AleoKeyProviderParams object which implements the KeySearchParams interface. Users can optionally
     * specify a url for the proverUri & verifierUri to fetch keys via HTTP from a remote resource as well as a unique
     * cacheKey to store the keys in memory for future use. If no proverUri or verifierUri is specified, a cachekey must
     * be provided.
     *
     * @param { AleoKeyProviderInitParams } params - Optional search parameters
     */
    constructor(params) {
        this.proverUri = params.proverUri;
        this.verifierUri = params.verifierUri;
        this.cacheKey = params.cacheKey;
        this.name = params.name;
    }
}
/**
 * AleoKeyProvider class. Implements the KeyProvider interface. Enables the retrieval of Aleo program proving and
 * verifying keys for the credits.aleo program over http from official Aleo sources and storing and retrieving function
 * keys from a local memory cache.
 */
class AleoKeyProvider {
    cache;
    cacheOption;
    keyUris;
    async fetchBytes(url = "/") {
        try {
            const response = await get(url);
            const data = await response.arrayBuffer();
            return new Uint8Array(data);
        }
        catch (error) {
            throw new Error("Error fetching data." + error.message);
        }
    }
    constructor() {
        this.keyUris = KEY_STORE;
        this.cache = new Map();
        this.cacheOption = false;
    }
    /**
     * Use local memory to store keys
     *
     * @param {boolean} useCache whether to store keys in local memory
     */
    useCache(useCache) {
        this.cacheOption = useCache;
    }
    /**
     * Clear the key cache
     */
    clearCache() {
        this.cache.clear();
    }
    /**
     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId
     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.
     *
     * @param {string} keyId access key for the cache
     * @param {FunctionKeyPair} keys keys to cache
     */
    cacheKeys(keyId, keys) {
        const [provingKey, verifyingKey] = keys;
        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);
    }
    /**
     * Determine if a keyId exists in the cache
     *
     * @param {string} keyId keyId of a proving and verifying key pair
     * @returns {boolean} true if the keyId exists in the cache, false otherwise
     */
    containsKeys(keyId) {
        return this.cache.has(keyId);
    }
    /**
     * Delete a set of keys from the cache
     *
     * @param {string} keyId keyId of a proving and verifying key pair to delete from memory
     * @returns {boolean} true if the keyId exists in the cache and was deleted, false if the key did not exist
     */
    deleteKeys(keyId) {
        return this.cache.delete(keyId);
    }
    /**
     * Get a set of keys from the cache
     * @param keyId keyId of a proving and verifying key pair
     *
     * @returns {FunctionKeyPair} Proving and verifying keys for the specified program
     */
    getKeys(keyId) {
        console.debug(`Checking if key exists in cache. KeyId: ${keyId}`);
        if (this.cache.has(keyId)) {
            const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);
            return [ProvingKey.fromBytes(provingKeyBytes), VerifyingKey.fromBytes(verifyingKeyBytes)];
        }
        else {
            throw new Error("Key not found in cache.");
        }
    }
    /**
     * Get arbitrary function keys from a provider
     *
     * @param {KeySearchParams} params parameters for the key search in form of: {proverUri: string, verifierUri: string, cacheKey: string}
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
     *
     * @example
     * // Create a new object which implements the KeyProvider interface
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually using the key provider
     * const keySearchParams = { "cacheKey": "myProgram:myFunction" };
     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.functionKeys(keySearchParams);
     */
    async functionKeys(params) {
        if (params) {
            let proverUrl;
            let verifierUrl;
            let cacheKey;
            if ("name" in params && typeof params["name"] == "string") {
                let key = CREDITS_PROGRAM_KEYS.getKey(params["name"]);
                return this.fetchCreditsKeys(key);
            }
            if ("proverUri" in params && typeof params["proverUri"] == "string") {
                proverUrl = params["proverUri"];
            }
            if ("verifierUri" in params && typeof params["verifierUri"] == "string") {
                verifierUrl = params["verifierUri"];
            }
            if ("cacheKey" in params && typeof params["cacheKey"] == "string") {
                cacheKey = params["cacheKey"];
            }
            if (proverUrl && verifierUrl) {
                return await this.fetchRemoteKeys(proverUrl, verifierUrl, cacheKey);
            }
            if (cacheKey) {
                return this.getKeys(cacheKey);
            }
        }
        throw new Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl");
    }
    /**
     * Returns the proving and verifying keys for a specified program from a specified url.
     *
     * @param {string} verifierUrl Url of the proving key
     * @param {string} proverUrl Url the verifying key
     * @param {string} cacheKey Key to store the keys in the cache
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
     *
     * @example
     * // Create a new AleoKeyProvider object
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually
     * const [transferPrivateProvingKey, transferPrivateVerifyingKey] = await keyProvider.fetchKeys(
     *     CREDITS_PROGRAM_KEYS.transfer_private.prover,
     *     CREDITS_PROGRAM_KEYS.transfer_private.verifier,
     * );
     */
    async fetchRemoteKeys(proverUrl, verifierUrl, cacheKey) {
        try {
            // If cache is enabled, check if the keys have already been fetched and return them if they have
            if (this.cacheOption) {
                if (!cacheKey) {
                    cacheKey = proverUrl;
                }
                const value = this.cache.get(cacheKey);
                if (typeof value !== "undefined") {
                    return [ProvingKey.fromBytes(value[0]), VerifyingKey.fromBytes(value[1])];
                }
                else {
                    console.debug("Fetching proving keys from url " + proverUrl);
                    const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                    console.debug("Fetching verifying keys " + verifierUrl);
                    const verifyingKey = (await this.getVerifyingKey(verifierUrl));
                    this.cache.set(cacheKey, [provingKey.toBytes(), verifyingKey.toBytes()]);
                    return [provingKey, verifyingKey];
                }
            }
            else {
                // If cache is disabled, fetch the keys and return them
                const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                const verifyingKey = (await this.getVerifyingKey(verifierUrl));
                return [provingKey, verifyingKey];
            }
        }
        catch (error) {
            throw new Error(`Error: ${error.message} fetching fee proving and verifying keys from ${proverUrl} and ${verifierUrl}.`);
        }
    }
    /***
     * Fetches the proving key from a remote source.
     *
     * @param proverUrl
     * @param cacheKey
     *
     * @returns {Promise<ProvingKey>} Proving key for the specified program
     */
    async fetchProvingKey(proverUrl, cacheKey) {
        try {
            // If cache is enabled, check if the keys have already been fetched and return them if they have
            if (this.cacheOption) {
                if (!cacheKey) {
                    cacheKey = proverUrl;
                }
                const value = this.cache.get(cacheKey);
                if (typeof value !== "undefined") {
                    return ProvingKey.fromBytes(value[0]);
                }
                else {
                    console.debug("Fetching proving keys from url " + proverUrl);
                    const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                    return provingKey;
                }
            }
            else {
                const provingKey = ProvingKey.fromBytes(await this.fetchBytes(proverUrl));
                return provingKey;
            }
        }
        catch (error) {
            throw new Error(`Error: ${error.message} fetching fee proving keys from ${proverUrl}`);
        }
    }
    async fetchCreditsKeys(key) {
        try {
            if (!this.cache.has(key.locator) || !this.cacheOption) {
                const verifying_key = key.verifyingKey();
                const proving_key = await this.fetchProvingKey(key.prover, key.locator);
                if (this.cacheOption) {
                    this.cache.set(CREDITS_PROGRAM_KEYS.getKey(key.name).locator, [proving_key.toBytes(), verifying_key.toBytes()]);
                }
                return [proving_key, verifying_key];
            }
            else {
                const keyPair = this.cache.get(key.locator);
                return [ProvingKey.fromBytes(keyPair[0]), VerifyingKey.fromBytes(keyPair[1])];
            }
        }
        catch (error) {
            throw new Error(`Error: fetching credits.aleo keys: ${error.message}`);
        }
    }
    async bondPublicKeys() {
        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_public);
    }
    bondValidatorKeys() {
        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.bond_validator);
    }
    claimUnbondPublicKeys() {
        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.claim_unbond_public);
    }
    /**
     * Returns the proving and verifying keys for the transfer functions in the credits.aleo program
     * @param {string} visibility Visibility of the transfer function
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer functions
     *
     * @example
     * // Create a new AleoKeyProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for value transfers
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * // Keys can also be fetched manually
     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys("public");
     */
    async transferKeys(visibility) {
        if (PRIVATE_TRANSFER.has(visibility)) {
            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private);
        }
        else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {
            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_private_to_public);
        }
        else if (PUBLIC_TRANSFER.has(visibility)) {
            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);
        }
        else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {
            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_as_signer);
        }
        else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {
            return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public_to_private);
        }
        else {
            throw new Error("Invalid visibility type");
        }
    }
    /**
     * Returns the proving and verifying keys for the transfer_public function.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the transfer_public function
     */
    async transferPublicKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.transfer_public);
    }
    /**
     * Returns the proving and verifying keys for the inclusion proof.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the inclusion proof.
     */
    async inclusionKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.inclusion);
    }
    /**
     * Returns the proving and verifying keys for the join function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    async joinKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.join);
    }
    /**
     * Returns the proving and verifying keys for the split function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the split function
     * */
    async splitKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.split);
    }
    /**
     * Returns the proving and verifying keys for the fee_private function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function
     */
    async feePrivateKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_private);
    }
    /**
     * Returns the proving and verifying keys for the fee_public function in the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the fee function
     */
    async feePublicKeys() {
        return await this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.fee_public);
    }
    /**
     * Gets a verifying key. If the verifying key is for a credits.aleo function, get it from the wasm cache otherwise
     *
     * @returns {Promise<VerifyingKey>} Verifying key for the function
     */
    // attempt to fetch it from the network
    async getVerifyingKey(verifierUri) {
        switch (verifierUri) {
            case CREDITS_PROGRAM_KEYS.bond_public.verifier:
                return CREDITS_PROGRAM_KEYS.bond_public.verifyingKey();
            case CREDITS_PROGRAM_KEYS.bond_validator.verifier:
                return CREDITS_PROGRAM_KEYS.bond_validator.verifyingKey();
            case CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier:
                return CREDITS_PROGRAM_KEYS.claim_unbond_public.verifyingKey();
            case CREDITS_PROGRAM_KEYS.fee_private.verifier:
                return CREDITS_PROGRAM_KEYS.fee_private.verifyingKey();
            case CREDITS_PROGRAM_KEYS.fee_public.verifier:
                return CREDITS_PROGRAM_KEYS.fee_public.verifyingKey();
            case CREDITS_PROGRAM_KEYS.inclusion.verifier:
                return CREDITS_PROGRAM_KEYS.inclusion.verifyingKey();
            case CREDITS_PROGRAM_KEYS.join.verifier:
                return CREDITS_PROGRAM_KEYS.join.verifyingKey();
            case CREDITS_PROGRAM_KEYS.set_validator_state.verifier:
                return CREDITS_PROGRAM_KEYS.set_validator_state.verifyingKey();
            case CREDITS_PROGRAM_KEYS.split.verifier:
                return CREDITS_PROGRAM_KEYS.split.verifyingKey();
            case CREDITS_PROGRAM_KEYS.transfer_private.verifier:
                return CREDITS_PROGRAM_KEYS.transfer_private.verifyingKey();
            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifier:
                return CREDITS_PROGRAM_KEYS.transfer_private_to_public.verifyingKey();
            case CREDITS_PROGRAM_KEYS.transfer_public.verifier:
                return CREDITS_PROGRAM_KEYS.transfer_public.verifyingKey();
            case CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifier:
                return CREDITS_PROGRAM_KEYS.transfer_public_as_signer.verifyingKey();
            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifier:
                return CREDITS_PROGRAM_KEYS.transfer_public_to_private.verifyingKey();
            case CREDITS_PROGRAM_KEYS.unbond_public.verifier:
                return CREDITS_PROGRAM_KEYS.unbond_public.verifyingKey();
            default:
                try {
                    /// Try to fetch the verifying key from the network as a string
                    const response = await get(verifierUri);
                    const text = await response.text();
                    return VerifyingKey.fromString(text);
                }
                catch (e) {
                    /// If that fails, try to fetch the verifying key from the network as bytes
                    try {
                        return VerifyingKey.fromBytes(await this.fetchBytes(verifierUri));
                    }
                    catch (inner) {
                        throw new Error("Invalid verifying key. Error: " + inner.message);
                    }
                }
        }
    }
    unBondPublicKeys() {
        return this.fetchCreditsKeys(CREDITS_PROGRAM_KEYS.unbond_public);
    }
}

/**
 * Search parameters for the offline key provider. This class implements the KeySearchParams interface and includes
 * a convenience method for creating a new instance of this class for each function of the credits.aleo program.
 *
 * @example
 * // If storing a key for a custom program function
 * offlineSearchParams = new OfflineSearchParams("myprogram.aleo/myfunction");
 *
 * // If storing a key for a credits.aleo program function
 * bondPublicKeyParams = OfflineSearchParams.bondPublicKeyParams();
 */
class OfflineSearchParams {
    cacheKey;
    verifyCreditsKeys;
    /**
     * Create a new OfflineSearchParams instance.
     *
     * @param {string} cacheKey - Key used to store the local function proving & verifying keys. This should be stored
     * under the naming convention "programName/functionName" (i.e. "myprogram.aleo/myfunction")
     * @param {boolean} verifyCreditsKeys - Whether to verify the keys against the credits.aleo program,
     * defaults to false, but should be set to true if using keys from the credits.aleo program
     */
    constructor(cacheKey, verifyCreditsKeys = false) {
        this.cacheKey = cacheKey;
        this.verifyCreditsKeys = verifyCreditsKeys;
    }
    /**
     * Create a new OfflineSearchParams instance for the bond_public function of the credits.aleo program.
     */
    static bondPublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_public.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the bond_validator function of the credits.aleo program.
     */
    static bondValidatorKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.bond_validator.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the claim_unbond_public function of the
     */
    static claimUnbondPublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the fee_private function of the credits.aleo program.
     */
    static feePrivateKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_private.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the fee_public function of the credits.aleo program.
     */
    static feePublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.fee_public.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the inclusion prover function.
     */
    static inclusionKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.inclusion.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the join function of the credits.aleo program.
     */
    static joinKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.join.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the set_validator_state function of the credits.aleo program.
     */
    static setValidatorStateKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.set_validator_state.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the split function of the credits.aleo program.
     */
    static splitKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.split.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the transfer_private function of the credits.aleo program.
     */
    static transferPrivateKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the transfer_private_to_public function of the credits.aleo program.
     */
    static transferPrivateToPublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the transfer_public function of the credits.aleo program.
     */
    static transferPublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the transfer_public_as_signer function of the credits.aleo program.
     */
    static transferPublicAsSignerKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_as_signer.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the transfer_public_to_private function of the credits.aleo program.
     */
    static transferPublicToPrivateKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, true);
    }
    /**
     * Create a new OfflineSearchParams instance for the unbond_public function of the credits.aleo program.
     */
    static unbondPublicKeyParams() {
        return new OfflineSearchParams(CREDITS_PROGRAM_KEYS.unbond_public.locator, true);
    }
}
/**
 * A key provider meant for building transactions offline on devices such as hardware wallets. This key provider is not
 * able to contact the internet for key material and instead relies on the user to insert Aleo function proving &
 * verifying keys from local storage prior to usage.
 *
 * @example
 * // Create an offline program manager
 * const programManager = new ProgramManager();
 *
 * // Create a temporary account for the execution of the program
 * const account = new Account();
 * programManager.setAccount(account);
 *
 * // Create the proving keys from the key bytes on the offline machine
 * console.log("Creating proving keys from local key files");
 * const program = "program hello_hello.aleo; function hello: input r0 as u32.public; input r1 as u32.private; add r0 r1 into r2; output r2 as u32.private;";
 * const myFunctionProver = await getLocalKey("/path/to/my/function/hello_hello.prover");
 * const myFunctionVerifier = await getLocalKey("/path/to/my/function/hello_hello.verifier");
 * const feePublicProvingKeyBytes = await getLocalKey("/path/to/credits.aleo/feePublic.prover");
 *
 * myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProver);
 * myFunctionVerifyingKey = VerifyingKey.fromBytes(myFunctionVerifier);
 * const feePublicProvingKey = ProvingKey.fromBytes(feePublicKeyBytes);
 *
 * // Create an offline key provider
 * console.log("Creating offline key provider");
 * const offlineKeyProvider = new OfflineKeyProvider();
 *
 * // Cache the keys
 * // Cache the proving and verifying keys for the custom hello function
 * OfflineKeyProvider.cacheKeys("hello_hello.aleo/hello", myFunctionProvingKey, myFunctionVerifyingKey);
 *
 * // Cache the proving key for the fee_public function (the verifying key is automatically cached)
 * OfflineKeyProvider.insertFeePublicKey(feePublicProvingKey);
 *
 * // Create an offline query using the latest state root in order to create the inclusion proof
 * const offlineQuery = new OfflineQuery("latestStateRoot");
 *
 * // Insert the key provider into the program manager
 * programManager.setKeyProvider(offlineKeyProvider);
 *
 * // Create the offline search params
 * const offlineSearchParams = new OfflineSearchParams("hello_hello.aleo/hello");
 *
 * // Create the offline transaction
 * const offlineExecuteTx = <Transaction>await this.buildExecutionTransaction("hello_hello.aleo", "hello", 1, false, ["5u32", "5u32"], undefined, offlineSearchParams, undefined, undefined, undefined, undefined, offlineQuery, program);
 *
 * // Broadcast the transaction later on a machine with internet access
 * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
 * const txId = await networkClient.broadcastTransaction(offlineExecuteTx);
 */
class OfflineKeyProvider {
    cache;
    constructor() {
        this.cache = new Map();
    }
    /**
     * Get bond_public function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function
     */
    bondPublicKeys() {
        return this.functionKeys(OfflineSearchParams.bondPublicKeyParams());
    }
    ;
    /**
     * Get bond_validator function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the bond_public function
     */
    bondValidatorKeys() {
        return this.functionKeys(OfflineSearchParams.bondValidatorKeyParams());
    }
    ;
    /**
     * Cache a set of keys. This will overwrite any existing keys with the same keyId. The user can check if a keyId
     * exists in the cache using the containsKeys method prior to calling this method if overwriting is not desired.
     *
     * @param {string} keyId access key for the cache
     * @param {FunctionKeyPair} keys keys to cache
     */
    cacheKeys(keyId, keys) {
        const [provingKey, verifyingKey] = keys;
        this.cache.set(keyId, [provingKey.toBytes(), verifyingKey.toBytes()]);
    }
    ;
    /**
     * Get unbond_public function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the unbond_public function
     */
    claimUnbondPublicKeys() {
        return this.functionKeys(OfflineSearchParams.claimUnbondPublicKeyParams());
    }
    ;
    /**
     * Get arbitrary function key from the offline key provider cache.
     *
     * @param {KeySearchParams | undefined} params - Optional search parameters for the key provider
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified program
     *
     * @example
     * /// First cache the keys from local offline resources
     * const offlineKeyProvider = new OfflineKeyProvider();
     * const myFunctionVerifyingKey = VerifyingKey.fromString("verifier...");
     * const myFunctionProvingKeyBytes = await readBinaryFile('./resources/myfunction.prover');
     * const myFunctionProvingKey = ProvingKey.fromBytes(myFunctionProvingKeyBytes);
     *
     * /// Cache the keys for future use with a memorable locator
     * offlineKeyProvider.cacheKeys("myprogram.aleo/myfunction", [myFunctionProvingKey, myFunctionVerifyingKey]);
     *
     * /// When they're needed, retrieve the keys from the cache
     *
     * /// First create a search parameter object with the same locator used to cache the keys
     * const keyParams = new OfflineSearchParams("myprogram.aleo/myfunction");
     *
     * /// Then retrieve the keys
     * const [myFunctionProver, myFunctionVerifier] = await offlineKeyProvider.functionKeys(keyParams);
     */
    functionKeys(params) {
        return new Promise((resolve, reject) => {
            if (params === undefined) {
                reject(new Error("No search parameters provided, cannot retrieve keys"));
            }
            else {
                const keyId = params.cacheKey;
                const verifyCreditsKeys = params.verifyCreditsKeys;
                if (this.cache.has(keyId)) {
                    const [provingKeyBytes, verifyingKeyBytes] = this.cache.get(keyId);
                    const provingKey = ProvingKey.fromBytes(provingKeyBytes);
                    const verifyingKey = VerifyingKey.fromBytes(verifyingKeyBytes);
                    if (verifyCreditsKeys) {
                        const keysMatchExpected = this.verifyCreditsKeys(keyId, provingKey, verifyingKey);
                        if (!keysMatchExpected) {
                            reject(new Error(`Cached keys do not match expected keys for ${keyId}`));
                        }
                    }
                    resolve([provingKey, verifyingKey]);
                }
                else {
                    reject(new Error("Keys not found in cache for " + keyId));
                }
            }
        });
    }
    ;
    /**
     * Determines if the keys for a given credits function match the expected keys.
     *
     * @returns {boolean} Whether the keys match the expected keys
     */
    verifyCreditsKeys(locator, provingKey, verifyingKey) {
        switch (locator) {
            case CREDITS_PROGRAM_KEYS.bond_public.locator:
                return provingKey.isBondPublicProver() && verifyingKey.isBondPublicVerifier();
            case CREDITS_PROGRAM_KEYS.claim_unbond_public.locator:
                return provingKey.isClaimUnbondPublicProver() && verifyingKey.isClaimUnbondPublicVerifier();
            case CREDITS_PROGRAM_KEYS.fee_private.locator:
                return provingKey.isFeePrivateProver() && verifyingKey.isFeePrivateVerifier();
            case CREDITS_PROGRAM_KEYS.fee_public.locator:
                return provingKey.isFeePublicProver() && verifyingKey.isFeePublicVerifier();
            case CREDITS_PROGRAM_KEYS.inclusion.locator:
                return provingKey.isInclusionProver() && verifyingKey.isInclusionVerifier();
            case CREDITS_PROGRAM_KEYS.join.locator:
                return provingKey.isJoinProver() && verifyingKey.isJoinVerifier();
            case CREDITS_PROGRAM_KEYS.set_validator_state.locator:
                return provingKey.isSetValidatorStateProver() && verifyingKey.isSetValidatorStateVerifier();
            case CREDITS_PROGRAM_KEYS.split.locator:
                return provingKey.isSplitProver() && verifyingKey.isSplitVerifier();
            case CREDITS_PROGRAM_KEYS.transfer_private.locator:
                return provingKey.isTransferPrivateProver() && verifyingKey.isTransferPrivateVerifier();
            case CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator:
                return provingKey.isTransferPrivateToPublicProver() && verifyingKey.isTransferPrivateToPublicVerifier();
            case CREDITS_PROGRAM_KEYS.transfer_public.locator:
                return provingKey.isTransferPublicProver() && verifyingKey.isTransferPublicVerifier();
            case CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator:
                return provingKey.isTransferPublicToPrivateProver() && verifyingKey.isTransferPublicToPrivateVerifier();
            case CREDITS_PROGRAM_KEYS.unbond_public.locator:
                return provingKey.isUnbondPublicProver() && verifyingKey.isUnbondPublicVerifier();
            default:
                return false;
        }
    }
    /**
     * Get fee_private function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    feePrivateKeys() {
        return this.functionKeys(OfflineSearchParams.feePrivateKeyParams());
    }
    ;
    /**
     * Get fee_public function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    feePublicKeys() {
        return this.functionKeys(OfflineSearchParams.feePublicKeyParams());
    }
    ;
    /**
     * Get the inclusion prover keys from. The keys must be cached prior to calling this method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the inclusion prover
     */
    inclusionKeys() {
        return this.functionKeys(OfflineSearchParams.inclusionKeyParams());
    }
    ;
    /**
     * Get join function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    joinKeys() {
        return this.functionKeys(OfflineSearchParams.joinKeyParams());
    }
    ;
    /**
     * Get split function keys from the credits.aleo program. The keys must be cached prior to calling this
     * method for it to work.
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    splitKeys() {
        return this.functionKeys(OfflineSearchParams.splitKeyParams());
    }
    ;
    /**
     * Get keys for a variant of the transfer function from the credits.aleo program.
     *
     *
     * @param {string} visibility Visibility of the transfer function (private, public, privateToPublic, publicToPrivate)
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the specified transfer function
     *
     * @example
     * // Create a new OfflineKeyProvider
     * const offlineKeyProvider = new OfflineKeyProvider();
     *
     * // Cache the keys for future use with the official locator
     * const transferPublicProvingKeyBytes = await readBinaryFile('./resources/transfer_public.prover.a74565e');
     * const transferPublicProvingKey = ProvingKey.fromBytes(transferPublicProvingKeyBytes);
     *
     * // Cache the transfer_public keys for future use with the OfflinKeyProvider's convenience method for
     * // transfer_public (the verifying key will be cached automatically)
     * offlineKeyProvider.insertTransferPublicKeys(transferPublicProvingKey);
     *
     * /// When they're needed, retrieve the keys from the cache
     * const [transferPublicProvingKey, transferPublicVerifyingKey] = await keyProvider.transferKeys("public");
     */
    transferKeys(visibility) {
        if (PRIVATE_TRANSFER.has(visibility)) {
            return this.functionKeys(OfflineSearchParams.transferPrivateKeyParams());
        }
        else if (PRIVATE_TO_PUBLIC_TRANSFER.has(visibility)) {
            return this.functionKeys(OfflineSearchParams.transferPrivateToPublicKeyParams());
        }
        else if (PUBLIC_TRANSFER.has(visibility)) {
            return this.functionKeys(OfflineSearchParams.transferPublicKeyParams());
        }
        else if (PUBLIC_TRANSFER_AS_SIGNER.has(visibility)) {
            return this.functionKeys(OfflineSearchParams.transferPublicAsSignerKeyParams());
        }
        else if (PUBLIC_TO_PRIVATE_TRANSFER.has(visibility)) {
            return this.functionKeys(OfflineSearchParams.transferPublicToPrivateKeyParams());
        }
        else {
            throw new Error("Invalid visibility type");
        }
    }
    ;
    /**
     * Get unbond_public function keys from the credits.aleo program
     *
     * @returns {Promise<FunctionKeyPair>} Proving and verifying keys for the join function
     */
    async unBondPublicKeys() {
        return this.functionKeys(OfflineSearchParams.unbondPublicKeyParams());
    }
    ;
    /**
     * Insert the proving and verifying keys for the bond_public function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for bond_public before inserting them into the cache.
     *
     * @param provingKey
     */
    insertBondPublicKeys(provingKey) {
        if (provingKey.isBondPublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.bond_public.locator, [provingKey.toBytes(), VerifyingKey.bondPublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for bond_public");
        }
    }
    /**
     * Insert the proving and verifying keys for the claim_unbond_public function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for claim_unbond_public before inserting them into the cache.
     *
     * @param provingKey
     */
    insertClaimUnbondPublicKeys(provingKey) {
        if (provingKey.isClaimUnbondPublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.claim_unbond_public.locator, [provingKey.toBytes(), VerifyingKey.claimUnbondPublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for claim_unbond_public");
        }
    }
    /**
     * Insert the proving and verifying keys for the fee_private function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for fee_private before inserting them into the cache.
     *
     * @param provingKey
     */
    insertFeePrivateKeys(provingKey) {
        if (provingKey.isFeePrivateProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.fee_private.locator, [provingKey.toBytes(), VerifyingKey.feePrivateVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for fee_private");
        }
    }
    /**
     * Insert the proving and verifying keys for the fee_public function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for fee_public before inserting them into the cache.
     *
     * @param provingKey
     */
    insertFeePublicKeys(provingKey) {
        if (provingKey.isFeePublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.fee_public.locator, [provingKey.toBytes(), VerifyingKey.feePublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for fee_public");
        }
    }
    /**
     * Insert the proving and verifying keys for the inclusion prover into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for the inclusion prover.
     *
     * @param provingKey
     */
    insertInclusionKeys(provingKey) {
        if (provingKey.isInclusionProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.inclusion.locator, [provingKey.toBytes(), VerifyingKey.inclusionVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for the inclusion prover");
        }
    }
    /**
     * Insert the proving and verifying keys for the join function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for join before inserting them into the cache.
     *
     * @param provingKey
     */
    insertJoinKeys(provingKey) {
        if (provingKey.isJoinProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.join.locator, [provingKey.toBytes(), VerifyingKey.joinVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for join");
        }
    }
    /**
     * Insert the proving and verifying keys for the set_validator_state function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for set_validator_state before inserting them into the cache.
     *
     * @param provingKey
     */
    insertSetValidatorStateKeys(provingKey) {
        if (provingKey.isSetValidatorStateProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.set_validator_state.locator, [provingKey.toBytes(), VerifyingKey.setValidatorStateVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for set_validator_state");
        }
    }
    /**
     * Insert the proving and verifying keys for the split function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for split before inserting them into the cache.
     *
     * @param provingKey
     */
    insertSplitKeys(provingKey) {
        if (provingKey.isSplitProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.split.locator, [provingKey.toBytes(), VerifyingKey.splitVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for split");
        }
    }
    /**
     * Insert the proving and verifying keys for the transfer_private function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for transfer_private before inserting them into the cache.
     *
     * @param provingKey
     */
    insertTransferPrivateKeys(provingKey) {
        if (provingKey.isTransferPrivateProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private.locator, [provingKey.toBytes(), VerifyingKey.transferPrivateVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for transfer_private");
        }
    }
    /**
     * Insert the proving and verifying keys for the transfer_private_to_public function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for transfer_private_to_public before inserting them into the cache.
     *
     * @param provingKey
     */
    insertTransferPrivateToPublicKeys(provingKey) {
        if (provingKey.isTransferPrivateToPublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_private_to_public.locator, [provingKey.toBytes(), VerifyingKey.transferPrivateToPublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for transfer_private_to_public");
        }
    }
    /**
     * Insert the proving and verifying keys for the transfer_public function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for transfer_public before inserting them into the cache.
     *
     * @param provingKey
     */
    insertTransferPublicKeys(provingKey) {
        if (provingKey.isTransferPublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public.locator, [provingKey.toBytes(), VerifyingKey.transferPublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for transfer_public");
        }
    }
    /**
     * Insert the proving and verifying keys for the transfer_public_to_private function into the cache. Only the proving key needs
     * to be inserted, the verifying key is automatically inserted by the SDK. This function will automatically check
     * that the keys match the expected checksum for transfer_public_to_private before inserting them into the cache.
     *
     * @param provingKey
     */
    insertTransferPublicToPrivateKeys(provingKey) {
        if (provingKey.isTransferPublicToPrivateProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.transfer_public_to_private.locator, [provingKey.toBytes(), VerifyingKey.transferPublicToPrivateVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for transfer_public_to_private");
        }
    }
    insertUnbondPublicKeys(provingKey) {
        if (provingKey.isUnbondPublicProver()) {
            this.cache.set(CREDITS_PROGRAM_KEYS.unbond_public.locator, [provingKey.toBytes(), VerifyingKey.unbondPublicVerifier().toBytes()]);
        }
        else {
            throw new Error("Attempted to insert invalid proving keys for unbond_public");
        }
    }
}

/**
 * A record provider implementation that uses the official Aleo API to find records for usage in program execution and
 * deployment, wallet functionality, and other use cases.
 */
class NetworkRecordProvider {
    account;
    networkClient;
    constructor(account, networkClient) {
        this.account = account;
        this.networkClient = networkClient;
    }
    /**
     * Set the account used to search for records
     *
     * @param {Account} account The account used to use for searching for records.
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Find a list of credit records with a given number of microcredits by via the official Aleo API
     *
     * @param {number[]} microcredits The number of microcredits to search for.
     * @param {RecordSearchParams} searchParameters Additional parameters to search for.
     * @returns {Promise<OwnedRecord[]>} The records if found, otherwise an error.
     *
     * @example
     * // Create a new NetworkRecordProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // The record provider can be used to find records with a given number of microcredits
     * const record = await recordProvider.findCreditsRecord(5000, { unspent: true, nonces: [] });
     *
     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
     * // found again if a subsequent search is performed
     * const records = await recordProvider.findCreditsRecords(5000, { unspent: true, nonces: [record.nonce()] });
     *
     * // When the program manager is initialized with the record provider it will be used to find automatically find
     * // fee records and amount records for value transfers so that they do not need to be specified manually
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     *
     * */
    async findCreditsRecords(microcredits, searchParameters) {
        let startHeight = 0;
        let endHeight = 0;
        let maxAmount = undefined;
        if (searchParameters) {
            if ("startHeight" in searchParameters && typeof searchParameters["startHeight"] == "number") {
                startHeight = searchParameters["startHeight"];
            }
            if ("endHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
                endHeight = searchParameters["endHeight"];
            }
            if ("amounts" in searchParameters && Array.isArray(searchParameters["amounts"]) && searchParameters["amount"].every((item) => typeof item === 'number')) {
                microcredits = searchParameters["amounts"];
            }
            if ("maxAmount" in searchParameters && typeof searchParameters["maxAmount"] == "number") {
                maxAmount = searchParameters["maxAmount"];
            }
        }
        // If the end height is not specified, use the current block height
        if (endHeight == 0) {
            const end = await this.networkClient.getLatestHeight();
            endHeight = end;
        }
        // If the start height is greater than the end height, throw an error
        if (startHeight >= endHeight) {
            logAndThrow("Start height must be less than end height");
        }
        const recordsPts = await this.networkClient.findRecords(startHeight, endHeight, searchParameters.unspent, ["credits.aleo"], microcredits, maxAmount, searchParameters.nonces, this.account.privateKey());
        return recordsPts.map((record) => ({
            owner: record.owner().toString(),
            programName: 'credits.aleo',
            recordName: 'credits',
            recordPlaintext: record.toString(),
        }));
    }
    /**
     * Find a credit record with a given number of microcredits by via the official Aleo API
     *
     * @param {number} microcredits The number of microcredits to search for.
     * @param {RecordSearchParams} searchParameters Additional parameters to search for.
     * @returns {Promise<OwnedRecord>} The record if found, otherwise an error.
     *
     * @example
     * // Create a new NetworkRecordProvider
     * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     *
     * // The record provider can be used to find records with a given number of microcredits
     * const record = await recordProvider.findCreditsRecord(5000, { unspent: true, nonces: [] });
     *
     * // When a record is found but not yet used, it's nonce should be added to the nonces parameter so that it is not
     * // found again if a subsequent search is performed
     * const records = await recordProvider.findCreditsRecords(5000, { unspent: true, nonces: [record.nonce()] });
     *
     * // When the program manager is initialized with the record provider it will be used to find automatically find
     * // fee records and amount records for value transfers so that they do not need to be specified manually
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.transfer(1, "aleo166q6ww6688cug7qxwe7nhctjpymydwzy2h7rscfmatqmfwnjvggqcad0at", "public", 0.5);
     */
    async findCreditsRecord(microcredits, searchParameters) {
        let records = null;
        try {
            records = await this.findCreditsRecords([microcredits], searchParameters);
        }
        catch (e) {
            console.log("No records found with error:", e);
        }
        if (records && records.length > 0) {
            return records[0];
        }
        console.error("Record not found with error:", records);
        throw new Error("Record not found");
    }
    /**
     * Find an arbitrary record. WARNING: This function is not implemented yet and will throw an error.
     */
    async findRecord(searchParameters) {
        let records;
        try {
            records = await this.findRecords(searchParameters);
        }
        catch (e) {
            console.log("No records found with error:", e);
        }
        if (records && records.length > 0) {
            return records[0];
        }
        console.error("Record not found with error:", records);
        throw new Error("Record not found");
    }
    /**
     * Find multiple records from a specified program.
     */
    async findRecords(searchParameters) {
        let startHeight = 0;
        let endHeight = 0;
        let amounts = undefined;
        let maxAmount = undefined;
        let programs = undefined;
        if (searchParameters) {
            if ("startHeight" in searchParameters && typeof searchParameters["startHeight"] == "number") {
                startHeight = searchParameters["startHeight"];
            }
            if ("endHeight" in searchParameters && typeof searchParameters["endHeight"] == "number") {
                endHeight = searchParameters["endHeight"];
            }
            if ("amounts" in searchParameters && Array.isArray(searchParameters["amounts"]) && searchParameters["amounts"].every((item) => typeof item === 'number')) {
                amounts = searchParameters["amounts"];
            }
            if ("maxAmount" in searchParameters && typeof searchParameters["maxAmount"] == "number") {
                maxAmount = searchParameters["maxAmount"];
            }
            if ("program" in searchParameters && typeof searchParameters["program"] == "string") {
                programs = [searchParameters["program"]];
            }
            if ("programs" in searchParameters && Array.isArray(searchParameters["programs"]) && searchParameters["programs"].every((item) => typeof item === "string")) {
                programs = searchParameters["programs"];
            }
        }
        // If the end height is not specified, use the current block height.
        if (endHeight == 0) {
            const end = await this.networkClient.getLatestHeight();
            endHeight = end;
        }
        // If the start height is greater than the end height, throw an error.
        if (startHeight >= endHeight) {
            logAndThrow("Start height must be less than end height");
        }
        const recordPts = await this.networkClient.findRecords(startHeight, endHeight, searchParameters.unspent, programs, amounts, maxAmount, searchParameters.nonces, this.account.privateKey());
        return recordPts.map((record) => ({
            record_plaintext: record.toString(),
        }));
    }
    async encryptedRecords(recordsFilter, responseFilter) {
        throw new Error("Not implemented");
    }
    async checkSerialNumbers(serialNumbers) {
        throw new Error("Not implemented");
    }
    async checkTags(tags) {
        throw new Error("Not implemented");
    }
}
/**
 * BlockHeightSearch is a RecordSearchParams implementation that allows for searching for records within a given
 * block height range.
 *
 * @example
 * // Create a new BlockHeightSearch
 * const params = new BlockHeightSearch(89995, 99995);
 *
 * // Create a new NetworkRecordProvider
 * const networkClient = new AleoNetworkClient("https://api.explorer.provable.com/v1");
 * const keyProvider = new AleoKeyProvider();
 * const recordProvider = new NetworkRecordProvider(account, networkClient);
 *
 * // The record provider can be used to find records with a given number of microcredits and the block height search
 * // can be used to find records within a given block height range
 * const record = await recordProvider.findCreditsRecord(5000, { unspent: true, nonces: [], ...params });
 *
 */
class BlockHeightSearch {
    startHeight;
    endHeight;
    unspent;
    constructor(startHeight, endHeight, unspent) {
        this.startHeight = startHeight;
        this.endHeight = endHeight;
        this.unspent = !!unspent;
    }
}

/**
 * RecordScanner is a RecordProvider implementation that uses the record scanner service to find records.
 *
 * @example
 * const account = new Account({ privateKey: 'APrivateKey1...' });
 *
 * const recordScanner = new RecordScanner({ url: "https://record-scanner.aleo.org" });
 * recordScanner.setAccount(account);
 * recordScanner.setApiKey("your-api-key");
 * const uuid = await recordScanner.register(0);
 *
 * const filter = {
 *     uuid,
 *     filter: {
 *         program: "credits.aleo",
 *         records: ["credits"],
 *     },
 *     responseFilter: {
 *         commitment: true,
 *         owner: true,
 *         tag: true,
 *         tag?: boolean;
 *         sender: true,
 *         spent: true,
 *         record_ciphertext: true,
 *         block_height: true;
 *         block_timestamp: true;
 *         output_index: true;
 *         record_name: true;
 *         function_name: true;
 *         program_name: true;
 *         transition_id: true;
 *         transaction_id: true;
 *         transaction_index: true;
 *         transition_index: true;
 *     },
 *     unspent: true,
 * };
 *
 * const records = await recordScanner.findRecords(filter);
 */
class RecordScanner {
    url;
    apiKey;
    uuid;
    constructor(options) {
        this.url = options.url;
        this.apiKey = typeof options.apiKey === "string" ? { header: "X-Provable-API-Key", value: options.apiKey } : options.apiKey;
    }
    /**
     * Set the API key to use for the record scanner.
     *
     * @param {string} apiKey The API key to use for the record scanner.
     */
    async setApiKey(apiKey) {
        this.apiKey = typeof apiKey === "string" ? { header: "X-Provable-API-Key", value: apiKey } : apiKey;
    }
    /**
     * Set the UUID to use for the record scanner.
     *
     * @param {Field} uuid The UUID to use for the record scanner.
     */
    async setUuid(uuidOrViewKey) {
        this.uuid = uuidOrViewKey instanceof ViewKey ? this.computeUUID(uuidOrViewKey) : uuidOrViewKey;
    }
    /**
     * Register the account with the record scanner service.
     *
     * @param {number} startBlock The block height to start scanning from.
     * @returns {Promise<RegistrationResponse>} The response from the record scanner service.
     */
    async register(viewKey, startBlock) {
        try {
            let request = {
                view_key: viewKey.to_string(),
                start: startBlock,
            };
            const response = await this.request(new Request(`${this.url}/register`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(request),
            }));
            const data = await response.json();
            this.uuid = data.uuid;
            return data;
        }
        catch (error) {
            console.error(`Failed to register view key: ${error}`);
            throw error;
        }
    }
    /**
     * Get encrypted records from the record scanner service.
     *
     * @param {RecordsFilter} recordsFilter The filter to use to find the records and filter the response.
     * @returns {Promise<EncryptedRecord[]>} The encrypted records.
     */
    async encryptedRecords(recordsFilter) {
        try {
            const response = await this.request(new Request(`${this.url}/records/encrypted`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(recordsFilter),
            }));
            return await response.json();
        }
        catch (error) {
            console.error(`Failed to get encrypted records: ${error}`);
            throw error;
        }
    }
    /**
     * Check if a list of serial numbers exist in the record scanner service.
     *
     * @param {string[]} serialNumbers The serial numbers to check.
     * @returns {Promise<Record<string, boolean>>} Map of Aleo Record serial numbers and whether they appeared in any inputs on chain. If boolean corresponding to the Serial Number has a true value, that Record is considered spent by the Aleo Network.
     */
    async checkSerialNumbers(serialNumbers) {
        try {
            const response = await this.request(new Request(`${this.url}/records/sns`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(serialNumbers),
            }));
            return await response.json();
        }
        catch (error) {
            console.error(`Failed to check if serial numbers exist: ${error}`);
            throw error;
        }
    }
    /**
     * Check if a list of tags exist in the record scanner service.
     *
     * @param {string[]} tags The tags to check.
     * @returns {Promise<Record<string, boolean>>} Map of Aleo Record tags and whether they appeared in any inputs on chain. If boolean corresponding to the tag has a true value, that Record is considered spent by the Aleo Network.
     */
    async checkTags(tags) {
        try {
            const response = await this.request(new Request(`${this.url}/records/tags`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(tags),
            }));
            return await response.json();
        }
        catch (error) {
            console.error(`Failed to check if tags exist: ${error}`);
            throw error;
        }
    }
    /**
     * Check the status of a record scanner indexing job.
     *
     * @param {string} jobId The job id to check.
     * @returns {Promise<StatusResponse>} The status of the job.
     */
    async checkStatus() {
        try {
            const response = await this.request(new Request(`${this.url}/status`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(this.uuid?.toString()),
            }));
            return await response.json();
        }
        catch (error) {
            console.error(`Failed to check status of job: ${error}`);
            throw error;
        }
    }
    /**
     * Find a record in the record scanner service.
     *
     * @param {OwnedFilter} searchParameters The filter to use to find the record.
     * @returns {Promise<OwnedRecord>} The record.
     */
    async findRecord(searchParameters) {
        try {
            const records = await this.findRecords(searchParameters);
            if (records.length > 0) {
                return records[0];
            }
            throw new Error("Record not found");
        }
        catch (error) {
            console.error(`Failed to find record: ${error}`);
            throw error;
        }
    }
    /**
     * Find records in the record scanner service.
     *
     * @param {OwnedFilter} filter The filter to use to find the records.
     * @returns {Promise<OwnedRecord[]>} The records.
     */
    async findRecords(filter) {
        if (!this.uuid) {
            throw new Error("You are using the RecordScanner implementation of the RecordProvider. No account has been registered with the RecordScanner which is required to use the findRecords method. Please set an with the setAccount method before calling the findRecords method again.");
        }
        filter.uuid = this.uuid?.toString();
        try {
            const response = await this.request(new Request(`${this.url}/records/owned`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(filter),
            }));
            return await response.json();
        }
        catch (error) {
            console.error(`Failed to get owned records: ${error}`);
            throw error;
        }
    }
    /**
     * Find a credits record in the record scanner service.
     *
     * @param {number} microcredits The amount of microcredits to find.
     * @param {OwnedFilter} searchParameters The filter to use to find the record.
     * @returns {Promise<OwnedRecord>} The record.
     */
    async findCreditsRecord(microcredits, searchParameters) {
        try {
            const records = await this.findRecords({
                decrypt: true,
                unspent: searchParameters.unspent,
                filter: {
                    start: searchParameters.filter?.start ?? 0,
                    program: "credits.aleo",
                    record: "credits",
                },
                uuid: this.uuid?.toString(),
            });
            const record = records.find(record => {
                const plaintext = RecordPlaintext.fromString(record.record_plaintext ?? '');
                const amountStr = plaintext.getMember("microcredits").toString();
                const amount = parseInt(amountStr.replace("u64", ""));
                return amount >= microcredits;
            });
            if (!record) {
                throw new Error(`No records found matching the supplied search filter:\n${JSON.stringify(searchParameters, null, 2)}`);
            }
            return record;
        }
        catch (error) {
            console.error(`Failed to find credits record: ${error}`);
            throw error;
        }
    }
    /**
     * Find credits records using a record scanning service.
     *
     * @param {number[]} microcreditAmounts The amounts of microcredits to find.
     * @param {OwnedFilter} searchParameters The filter to use to find the records.
     * @returns {Promise<OwnedRecord[]>} The records
     */
    async findCreditsRecords(microcreditAmounts, searchParameters) {
        try {
            const records = await this.findRecords({
                decrypt: true,
                unspent: searchParameters.unspent,
                filter: {
                    start: searchParameters.filter?.start ?? 0,
                    program: "credits.aleo",
                    record: "credits",
                },
                uuid: this.uuid?.toString(),
            });
            return records.filter(record => {
                const plaintext = RecordPlaintext.fromString(record.record_plaintext ?? '');
                const amount = plaintext.getMember("microcredits").toString();
                return microcreditAmounts.includes(parseInt(amount.replace("u64", "")));
            });
        }
        catch (error) {
            console.error(`Failed to find credits records: ${error}`);
            throw error;
        }
    }
    /**
     * Wrapper function to make a request to the record scanner service and handle any errors.
     *
     * @param {Request} req The request to make.
     * @returns {Promise<Response>} The response.
     */
    async request(req) {
        try {
            if (this.apiKey) {
                req.headers.set(this.apiKey.header, this.apiKey.value);
            }
            const response = await fetch(req);
            if (!response.ok) {
                throw new Error(await response.text() ?? `Request to ${req.url} failed with status ${response.status}`);
            }
            return response;
        }
        catch (error) {
            console.error(`Failed to make request to ${req.url}: ${error}`);
            throw error;
        }
    }
    computeUUID(vk) {
        // Construct the material needed for the Poseidon oracle.
        const inputs = [Field.newDomainSeparator(RECORD_DOMAIN), vk.toField(), Field.one()];
        // Calculate the uuid.
        const hasher = new Poseidon4();
        return hasher.hash(inputs);
    }
}

/**
 * Client library that encapsulates methods for constructing Merkle exclusion proofs for compliant stablecoin programs following the Sealance architecture.
 *

 * @example
 * Construct a Merkle exclusion proof.
 *  ```typescript
 * const sealance = new SealanceMerkleTree();
 * const leaves = [
 *      "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *    ];
 * const result = sealance.generateLeaves(leaves);
 * const tree = sealance.buildTree(result);
 * const [leftIdx, rightIdx] = sealance.getLeafIndices(tree, "aleo1kypwp5m7qtk9mwazgcpg0tq8aal23mnrvwfvug65qgcg9xvsrqgspyjm6n");
 * const proof_left = sealance.getSiblingPath(tree, leftIdx, 15);
 * const proof_right = sealance.getSiblingPath(tree, rightIdx, 15);
 * const exclusion_proof = [proof_left, proof_right];
 * const formatted_proof = sealance.formatMerkleProof(exclusion_proof);
 * ```
 */
class SealanceMerkleTree {
    static hasher = new Poseidon4();
    /**
    * Converts an Aleo blockchain address to a field element.
    *
    * This function decodes a bech32m-encoded Aleo address and converts it to a field element
    * represented as a BigInt. The address format follows the Aleo protocol specification,
    * starting with the prefix "aleo1" followed by encoded data.
    *
    * @param address - The Aleo blockchain address (e.g., "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px")
    * @returns A BigInt representing the field element.
    * @throws Error if the address is invalid or cannot be decoded.
    *
    * @example
    * ```typescript
    * const sealance = new SealanceMerkleTree();
    * const address = "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px";
    * const fieldValue = sealance.convertAddressToField(address);
    * console.log(fieldValue); // 123456789...n
    * ```
    */
    convertAddressToField(address) {
        const { words } = bech32m.decode(address);
        const bytes = bech32m.fromWords(words);
        // Convert bytes to BigInt (little-endian)
        let fieldValue = BigInt(0);
        for (let i = 0; i < bytes.length; i++) {
            fieldValue |= BigInt(bytes[i]) << BigInt(i * 8);
        }
        return fieldValue;
    }
    /**
    * Hashes two elements using Poseidon4 hash function
    * @param prefix - Prefix for the hash (e.g., "0field" for nodes, "1field" for leaves)
    * @param el1 - First element to hash
    * @param el2 - Second element to hash
    * @returns The hash result as a Field
    * @throws {Error} If inputs are empty or invalid
    */
    hashTwoElements(prefix, el1, el2) {
        if (!el1 || !el2) {
            throw new Error("Invalid inputs: elements cannot be empty");
        }
        const fields = [Field.fromString(prefix), Field.fromString(el1), Field.fromString(el2)];
        const arrayPlaintext = Plaintext.fromString(`[${fields.map(f => f.toString()).join(",")}]`);
        return SealanceMerkleTree.hasher.hash(arrayPlaintext.toFields());
    }
    /**
    * Builds a Merkle tree from given leaves. The tree is built bottom-up, hashing pairs of elements at each level.
    *
    * @param leaves - Array of leaf elements (must have even number of elements).
    * @returns Array representing the complete Merkle tree as BigInts.
    * @throws {Error} If leaves array is empty or has odd number of elements.
    *
    * @example
    * ```typescript
    * const sealance = new SealanceMerkleTree();
    * const leaves = ["0field", "1field", "2field", "3field"];
    * const tree = sealance.buildTree(leaves);
    * const root = tree[tree.length - 1]; // Get the Merkle root
    * ```
    */
    buildTree(leaves) {
        if (leaves.length === 0) {
            throw new Error("Leaves array cannot be empty");
        }
        if (leaves.length % 2 !== 0) {
            throw new Error("Leaves array must have even number of elements");
        }
        let currentLevel = leaves;
        let tree = [...currentLevel];
        let levelSize = currentLevel.length;
        while (levelSize > 1) {
            const nextLevel = [];
            for (let i = 0; i < levelSize; i += 2) {
                const left = currentLevel[i];
                const right = currentLevel[i + 1];
                const prefix = leaves.length === levelSize ? "1field" : "0field";
                const hash = this.hashTwoElements(prefix, left, right);
                nextLevel.push(hash.toString());
            }
            tree = [...tree, ...nextLevel];
            currentLevel = nextLevel;
            levelSize = currentLevel.length;
        }
        return tree.map(element => BigInt(element.slice(0, element.length - "field".length)));
    }
    /**
    * Converts an array of decimal string representations of U256 numbers to an array of BigInts.
    *
    * @param tree - Array of decimal string representations of U256 numbers.
    * @returns Array of BigInts.
    *
    * @example
    * ```typescript
    * const treeStrings = ["0","4328470178059738374782465505490977516512210899136548187530607227309847251692","1741259420362056497457198439964202806733137875365061915996980524089960046336"];
    * const sealance = new SealanceMerkleTree();
    * const treeBigInts = sealance.convertTreeToBigInt(treeStrings);
    * console.log(treeBigInts); // [
    *   0,
    *   4328470178059738374782465505490977516512210899136548187530607227309847251692,
    *   1741259420362056497457198439964202806733137875365061915996980524089960046336
    *  ]
    * ```
    */
    convertTreeToBigInt(tree) {
        return tree.map((element) => {
            try {
                // decimal string  native bigint
                return BigInt(element);
            }
            catch {
                throw new Error(`Invalid decimal U256 string: ${element}`);
            }
        });
    }
    /**
    * Converts Aleo addresses to field elements, sorts them, pads with zero fields, and returns an array. This prepares addresses for Merkle tree construction.
    *
    * @param addresses - Array of Aleo addresses.
    * @param maxTreeDepth - Maximum depth of the Merkle tree (default: 15).
    * @returns Array of field elements ready for Merkle tree construction.
    * @throws {Error} If the number of addresses exceeds the maximum capacity.
    *
    * @example
    * ```typescript
    * const addresses = [
 *      "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *    ];
    * const sealance = new SealanceMerkleTree();
    * const leaves = sealance.generateLeaves(addresses, 15);
    * console.log(leaves); // [
    *   "0field",
    *   "1295133970529764960316948294624974168921228814652993007266766481909235735940field",
    *   "1295133970529764960316948294624974168921228814652993007266766481909235735940field",
    *   "3501665755452795161867664882580888971213780722176652848275908626939553697821field"
    *  ]
    * ```
    */
    generateLeaves(addresses, maxTreeDepth = 15) {
        const maxNumLeaves = Math.floor(2 ** (maxTreeDepth - 1));
        // Filter out zero addresses
        addresses = addresses.filter(addr => addr !== ZERO_ADDRESS);
        let numLeaves = 0;
        if (addresses.length === 0 || addresses.length === 1) {
            numLeaves = 2;
        }
        else {
            numLeaves = Math.pow(2, Math.ceil(Math.log2(addresses.length)));
        }
        if (addresses.length > maxNumLeaves) {
            throw new Error(`Leaves limit exceeded. Max: ${maxNumLeaves}, provided: ${addresses.length}`);
        }
        // Convert addresses to fields
        const addressFields = addresses.map(addr => ({
            address: addr,
            field: this.convertAddressToField(addr),
        }));
        // Sort by field value
        const sortedFields = addressFields.sort((a, b) => (a.field < b.field ? -1 : 1)).map(item => item.field);
        // Convert to field strings
        const sortedFieldElements = sortedFields.map(field => field.toString() + "field");
        // Pad with zeros to reach power of 2
        const fullTree = Array(Math.max(numLeaves - sortedFieldElements.length, 0)).fill("0field");
        return fullTree.concat(sortedFieldElements);
    }
    /**
    * Finds the leaf indices for non-inclusion proof of an address and returns the indices of the two adjacent leaves that surround the target address.
    *
    * @param merkleTree - The complete Merkle tree as array of BigInts.
    * @param address - The Aleo address for which to find indices.
    * @returns Tuple of [leftLeafIndex, rightLeafIndex].
    *
    * @example
    * ```typescript
    * const addresses = [
 *      "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *      "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
 *    ];
    * const sealance = new SealanceMerkleTree();
    * const leaves = sealance.generateLeaves(addresses);
    * const tree = sealance.buildTree(leaves);
    * const [leftIdx, rightIdx] = sealance.getLeafIndices(tree, "aleo1...");
    * ```
    */
    getLeafIndices(merkleTree, address) {
        const num_leaves = Math.floor((merkleTree.length + 1) / 2);
        const addressBigInt = this.convertAddressToField(address);
        const leaves = merkleTree.slice(0, num_leaves);
        let rightLeafIndex = leaves.findIndex((leaf) => addressBigInt <= leaf);
        let leftLeafIndex = rightLeafIndex - 1;
        if (rightLeafIndex === -1) {
            rightLeafIndex = leaves.length - 1;
            leftLeafIndex = leaves.length - 1;
        }
        if (rightLeafIndex === 0) {
            leftLeafIndex = 0;
        }
        return [leftLeafIndex, rightLeafIndex];
    }
    /**
    * Generates the sibling path (Merkle proof) for a given leaf index
    *
    * @param tree - The complete Merkle tree.
    * @param leafIndex - Index of the leaf for which to generate the proof.
    * @param depth - Maximum depth of the tree.
    * @returns Object containing siblings array and leaf_index.
    *
    * @example
    * ```typescript
    * const addresses = [
    *    "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px",
    *    "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
    *    "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
    *  ];
    * const sealance = new SealanceMerkleTree();
    * const leaves = sealance.generateLeaves(addresses);
    * const tree = sealance.buildTree(leaves);
    * const [leftIdx, rightIdx] = sealance.getLeafIndices(tree, "aleo1...");
    * const proof = sealance.getSiblingPath(tree, leftIdx, 15);
    * // proof = { siblings: [0n, 1n, ...], leaf_index: leftIdx }
    * ```
    */
    getSiblingPath(tree, leafIndex, depth) {
        let num_leaves = Math.floor((tree.length + 1) / 2);
        const siblingPath = [];
        let index = leafIndex;
        let parentIndex = num_leaves;
        siblingPath.push(tree[index]);
        let level = 1;
        while (parentIndex < tree.length) {
            let siblingIndex = index % 2 === 0 ? index + 1 : index - 1; // Get the sibling index
            siblingPath.push(tree[siblingIndex]);
            index = parentIndex + Math.floor(leafIndex / 2 ** level); // Move up to the parent node
            parentIndex += Math.floor(num_leaves / 2 ** level); // Halve the number of nodes for the next level
            level++;
        }
        while (level < depth) {
            siblingPath.push(0n);
            level++;
        }
        return { siblings: siblingPath, leaf_index: leafIndex };
    }
    /**
    * Generates a formatted exclusion proof suitable for Aleo transactions.
    *
    * @param proof - An array of two {sibling path, leafindex} objects.
    * @returns String representation of the exclusion proof.
    *
    * @example
    * ```typescript
    * const addresses = [
    *    "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px",
    *    "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
    *    "aleo1s3ws5tra87fjycnjrwsjcrnw2qxr8jfqqdugnf0xzqqw29q9m5pqem2u4t",
    *  ];
    * const sealance = new SealanceMerkleTree();
    * const leaves = sealance.generateLeaves(addresses);
    * const tree = sealance.buildTree(leaves);
    * const [leftIdx, rightIdx] = sealance.getLeafIndices(tree, "aleo1...");
    * const proof1 = getSiblingPath(tree, leftIdx, 15);
    * const proof2 = getSiblingPath(tree, rightIdx, 15);
    * const formattedProof = formatMerkleProof([proof1, proof2]);
    * // formattedProof = "[{ siblings: [0field, 1field, ...], leaf_index: 0u32 }, { siblings: [0field, 2field, ...], leaf_index: 1u32 }]"
    * ```
    */
    formatMerkleProof(proof) {
        const formatted = proof.map(item => {
            const siblings = item.siblings.map(s => `${s}field`).join(", ");
            return `{siblings: [${siblings}], leaf_index: ${item.leaf_index}u32}`;
        }).join(", ");
        return `[${formatted}]`;
    }
}

/**
 * The ProgramManager class is used to execute and deploy programs on the Aleo network and create value transfers.
 */
class ProgramManager {
    account;
    keyProvider;
    host;
    networkClient;
    recordProvider;
    inclusionKeysLoaded = false;
    /** Create a new instance of the ProgramManager
     *
     * @param { string | undefined } host A host uri running the official Aleo API
     * @param { FunctionKeyProvider | undefined } keyProvider A key provider that implements {@link FunctionKeyProvider} interface
     * @param { RecordProvider | undefined } recordProvider A record provider that implements {@link RecordProvider} interface
     */
    constructor(host, keyProvider, recordProvider, networkClientOptions) {
        this.host = host ? host : "https://api.explorer.provable.com/v1";
        this.networkClient = new AleoNetworkClient(this.host, networkClientOptions);
        this.keyProvider = keyProvider ? keyProvider : new AleoKeyProvider();
        this.recordProvider = recordProvider;
    }
    /**
     * Check if the fee is sufficient to pay for the transaction
     */
    async checkFee(address, feeAmount) {
        const balance = BigInt(await this.networkClient.getPublicBalance(address));
        if (feeAmount > balance) {
            throw Error(`The desired execution requires a fee of ${feeAmount} microcredits, but the account paying the fee has ${balance} microcredits available.`);
        }
    }
    /**
     * Set the account to use for transaction submission to the Aleo network
     *
     * @param {Account} account Account to use for transaction submission
     */
    setAccount(account) {
        this.account = account;
    }
    /**
     * Set the key provider that provides the proving and verifying keys for programs
     *
     * @param {FunctionKeyProvider} keyProvider
     */
    setKeyProvider(keyProvider) {
        this.keyProvider = keyProvider;
    }
    /**
     * Set the host peer to use for transaction submission to the Aleo network
     *
     * @param host {string} Peer url to use for transaction submission
     */
    setHost(host) {
        this.host = host;
        this.networkClient.setHost(host);
    }
    /**
     * Set the record provider that provides records for transactions
     *
     * @param {RecordProvider} recordProvider
     */
    setRecordProvider(recordProvider) {
        this.recordProvider = recordProvider;
    }
    /**
     * Set a header in the `AleoNetworkClient`s header map
     *
     * @param {string} headerName The name of the header to set
     * @param {string} value The header value
     *
     * @example
     * import { ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a ProgramManager
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1");
     *
     * // Set the value of the `Accept-Language` header to `en-US`
     * programManager.setHeader('Accept-Language', 'en-US');
     */
    setHeader(headerName, value) {
        this.networkClient.headers[headerName] = value;
    }
    /**
     * Set the inclusion prover into the wasm memory. This should be done prior to any execution of a function with a
     * private record.
     *
     * @param {ProvingKey} [provingKey]
     *
     * @example
     * import { ProgramManager, AleoKeyProvider } from "@provablehq/sdk/mainnet.js";
     *
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a ProgramManager
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider);
     *
     * // Set the inclusion keys.
     * programManager.setInclusionProver();
     */
    async setInclusionProver(provingKey) {
        if (this.inclusionKeysLoaded) {
            return;
        }
        try {
            if (provingKey) {
                ProgramManager$1.loadInclusionProver(provingKey);
                this.inclusionKeysLoaded = true;
            }
            else {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
            }
            return;
        }
        catch {
            console.log("Setting the inclusion prover requires either a key provider to be configured for the ProgramManager OR to pass the inclusion prover directly");
        }
    }
    /**
     * Remove a header from the `AleoNetworkClient`s header map
     *
     * @param {string} headerName The name of the header to be removed
     *
     * @example
     * import { ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a ProgramManager
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1");
     *
     * // Remove the default `X-Aleo-SDK-Version` header
     * programManager.removeHeader('X-Aleo-SDK-Version');
     */
    removeHeader(headerName) {
        delete this.networkClient.headers[headerName];
    }
    /**
     * Builds a deployment transaction for submission to the Aleo network.
     *
     * @param {string} program Program source code
     * @param {number} priorityFee The optional priority fee to be paid for that transaction.
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to use pay the deployment fee
     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @returns {string} The transaction id of the deployed program or a failure message from the network
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.setAccount(Account);
     *
     * // Define a fee in credits
     * const priorityFee = 0.0;
     *
     * // Create the deployment transaction.
     * const tx = await programManager.buildDeploymentTransaction(program, fee, false);
     * await programManager.networkClient.submitTransaction(tx);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 20000);
     */
    async buildDeploymentTransaction(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey) {
        // Ensure the program is valid.
        let programObject;
        try {
            programObject = Program.fromString(program);
        }
        catch (e) {
            logAndThrow(`Error parsing program: '${e.message}'. Please ensure the program is valid.`);
        }
        // Ensure the program is valid and does not exist on the network
        try {
            let programSource;
            try {
                programSource = await this.networkClient.getProgram(programObject.id());
            }
            catch (e) {
                // Program does not exist on the network, deployment can proceed
                console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);
            }
            if (typeof programSource === "string") {
                throw Error(`Program ${programObject.id()} already exists on the network, please rename your program`);
            }
        }
        catch (e) {
            logAndThrow(`Error validating program: ${e.message}`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let deploymentPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            deploymentPrivateKey = this.account.privateKey();
        }
        if (typeof deploymentPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a private fee is specified, but no fee record is provided, estimate the fee and find a matching record.
                if (!feeRecord) {
                    console.log("Private fee specified, but no private fee record provided, estimating fee and finding a matching fee record.");
                    const programString = programObject.toString();
                    const imports = await this.networkClient.getProgramImports(programString);
                    const baseFee = Number(ProgramManager$1.estimateDeploymentFee(programString, imports));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(program);
        }
        catch (e) {
            logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        // Build a deployment transaction
        return await ProgramManager$1.buildDeploymentTransaction(deploymentPrivateKey, program, priorityFee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);
    }
    /**
     * Builds a deployment transaction for submission to the Aleo network that upgrades an existing program.
     *
     * @param {DeployOptions} options The deployment options.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * programManager.setAccount(Account);
     *
     * // Define a fee in credits
     * const priorityFee = 0.0;
     *
     * // Create the deployment transaction.
     * const tx = await programManager.buildUpgradeTransaction({program: program, priorityFee: fee, privateFee: false});
     * await programManager.networkClient.submitTransaction(tx);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 20000);
     */
    async buildUpgradeTransaction(options) {
        const { program, priorityFee, privateFee, recordSearchParams } = options;
        let feeRecord = options.feeRecord;
        let privateKey = options.privateKey;
        // Ensure the program is valid.
        let programObject;
        try {
            programObject = Program.fromString(program);
        }
        catch (e) {
            logAndThrow(`Error parsing program: '${e.message}'. Please ensure the program is valid.`);
        }
        // Ensure the program is valid and does not exist on the network
        try {
            let programSource;
            try {
                programSource = await this.networkClient.getProgram(programObject.id());
            }
            catch (e) {
                // Program does not exist on the network, deployment can proceed
                console.log(`Program ${programObject.id()} does not exist on the network...`);
            }
        }
        catch (e) {
            logAndThrow(`Error validating program: ${e.message}`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let deploymentPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            deploymentPrivateKey = this.account.privateKey();
        }
        if (typeof deploymentPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a private fee is specified, but no fee record is provided, estimate the fee and find a matching record.
                if (!feeRecord) {
                    console.log("Private fee specified, but no private fee record provided, estimating fee and finding a matching fee record.");
                    const programString = programObject.toString();
                    const imports = await this.networkClient.getProgramImports(programString);
                    const baseFee = Number(ProgramManager$1.estimateDeploymentFee(programString, imports));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(program);
        }
        catch (e) {
            logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        // Build a deployment transaction
        return await ProgramManager$1.buildUpgradeTransaction(deploymentPrivateKey, program, priorityFee, feeRecord, this.host, imports, feeProvingKey, feeVerifyingKey);
    }
    /**
     * Deploy an Aleo program to the Aleo network
     *
     * @param {string} program Program source code
     * @param {number} priorityFee The optional fee to be paid for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for searching for a record to used pay the deployment fee
     * @param {string | RecordPlaintext | undefined} feeRecord Optional Fee record to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @returns {string} The transaction id of the deployed program or a failure message from the network
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Define a fee in credits
     * const priorityFee = 0.0;
     *
     * // Deploy the program
     * const tx_id = await programManager.deploy(program, fee, false);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 20000);
     */
    async deploy(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey) {
        const tx = (await this.buildDeploymentTransaction(program, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey));
        let feeAddress;
        if (typeof privateKey !== "undefined") {
            feeAddress = Address.from_private_key(privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Builds an execution transaction for submission to the Aleo network.
     *
     * @param {ExecuteOptions} options - The options for the execution transaction.
     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build and execute the transaction
     * const tx = await programManager.buildExecutionTransaction({
     *   programName: "hello_hello.aleo",
     *   functionName: "hello_hello",
     *   priorityFee: 0.0,
     *   privateFee: false,
     *   inputs: ["5u32", "5u32"],
     *   keySearchParams: { "cacheKey": "hello_hello:hello" }
     * });
     *
     * // Submit the transaction to the network
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildExecutionTransaction(options) {
        // Destructure the options object to access the parameters
        const { functionName, priorityFee, privateFee, inputs, recordSearchParams, keySearchParams, privateKey, offlineQuery, } = options;
        let feeRecord = options.feeRecord;
        let provingKey = options.provingKey;
        let verifyingKey = options.verifyingKey;
        let program = options.program;
        let programName = options.programName;
        let imports = options.imports;
        let edition = options.edition;
        let programObject;
        // Ensure the function exists on the network
        if (program === undefined) {
            try {
                programObject = await this.networkClient.getProgramObject(programName);
                program = programObject.toString();
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (typeof program == "string") {
            try {
                programObject = Program.fromString(program);
            }
            catch (e) {
                logAndThrow(`Program sources passed for ${programName} were invalid: ${e}`);
            }
        }
        else if (program instanceof Program) {
            programObject = program;
            program = program.toString();
        }
        if (!(programObject instanceof Program)) {
            logAndThrow(`Failed to validate program ${programName}`);
        }
        // Get the program name if it is not provided in the parameters.
        if (programName === undefined) {
            programName = programObject.id();
        }
        if (edition == undefined) {
            try {
                edition = await this.networkClient.getLatestProgramEdition(programName);
            }
            catch (e) {
                console.warn(`Error finding edition for ${programName}. Network response: '${e.message}'. Assuming edition 1.`);
                edition = 1;
            }
        }
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee proving and verifying keys from the key provider
        let feeKeys;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // If the function proving and verifying keys are not provided, attempt to find them using the key provider
        if (!provingKey || !verifyingKey) {
            try {
                [provingKey, verifyingKey] = (await this.keyProvider.functionKeys(keySearchParams));
            }
            catch (e) {
                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
            }
        }
        // Resolve the program imports if they exist
        const numberOfImports = programObject.getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a fee record wasn't provided, estimate the fee that needs to be paid.
                if (!feeRecord) {
                    const baseFee = Number(await this.estimateExecutionFee({ programName, functionName, program, imports }));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        if (offlineQuery && !this.inclusionKeysLoaded) {
            try {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
                console.log("Successfully loaded inclusion key");
            }
            catch {
                logAndThrow(`Inclusion key bytes not loaded, please ensure the program manager is initialized with a KeyProvider that includes the inclusion key.`);
            }
        }
        // Build an execution transaction
        return await ProgramManager$1.buildExecutionTransaction(executionPrivateKey, program, functionName, inputs, priorityFee, feeRecord, this.host, imports, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery, edition);
    }
    /**
     * Builds an execution transaction for submission to the Aleo network from an Authorization and Fee Authorization.
     * This method is helpful if signing and authorization needs to be done in a secure environment separate from where
     * transactions are built.
     *
     * @param {ExecuteAuthorizationOptions} options - The options for executing the authorizations.
     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.
     *
     * @example
     * import { AleoKeyProvider, PrivateKey, initThreadPool, ProgramManager } from "@provablehq/sdk";
     *
     * await initThreadPool();
     *
     * // Create a new KeyProvider.
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider);
     *
     * // Build the `Authorization`.
     * const privateKey = new PrivateKey(); // Change this to a private key that has an aleo credit balance.
     * const authorization = await programManager.buildAuthorization({
     *     programName: "credits.aleo",
     *     functionName: "transfer_public",
     *     privateKey,
     *     inputs: [
     *         "aleo1vwls2ete8dk8uu2kmkmzumd7q38fvshrht8hlc0a5362uq8ftgyqnm3w08",
     *         "10000000u64",
     *     ],
     * });
     *
     * console.log("Getting execution id");
     *
     * // Derive the execution ID and base fee.
     * const executionId = authorization.toExecutionId().toString();
     *
     * console.log("Estimating fee");
     *
     * // Get the base fee in microcredits.
     * const baseFeeMicrocredits = await programManager.estimateFeeForAuthorization(authorization, "credits.aleo");
     * const baseFeeCredits = Number(baseFeeMicrocredits)/1000000;
     *
     * console.log("Building fee authorization");
     *
     * // Build a credits.aleo/fee_public `Authorization`.
     * const feeAuthorization = await programManager.buildFeeAuthorization({
     *     deploymentOrExecutionId: executionId,
     *     baseFeeCredits,
     *     privateKey
     * });
     *
     * console.log("Executing authorizations");
     *
     * // Build and execute the transaction.
     * const tx = await programManager.buildTransactionFromAuthorization({
     *     programName: "credits.aleo",
     *     authorization,
     *     feeAuthorization,
     * });
     *
     * // Submit the transaction to the network.
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful.
     * setTimeout(async () => {
     *     const transaction = await programManager.networkClient.getTransaction(tx.id());
     *     console.log(transaction);
     * }, 10000);
     */
    async buildTransactionFromAuthorization(options) {
        // Destructure the options object to access the parameters.
        const { programName, authorization, } = options;
        const feeAuthorization = options.feeAuthorization;
        const keySearchParams = options.keySearchParams;
        const offlineQuery = options.offlineQuery;
        let provingKey = options.provingKey;
        let verifyingKey = options.verifyingKey;
        let program = options.program;
        let imports = options.imports;
        // Ensure the function exists on the network.
        if (program === undefined) {
            try {
                program = (await this.networkClient.getProgram(programName));
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (program instanceof Program) {
            program = program.toString();
        }
        // Get the fee proving and verifying keys from the key provider.
        let feeKeys;
        const privateFee = feeAuthorization ? feeAuthorization.isFeePrivate() : false;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        // If the function proving and verifying keys are not provided, attempt to find them using the key provider.
        if (!provingKey || !verifyingKey) {
            try {
                [provingKey, verifyingKey] = (await this.keyProvider.functionKeys(keySearchParams));
            }
            catch (e) {
                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
            }
        }
        // Resolve the program imports if they exist.
        console.log("Resolving program imports");
        const numberOfImports = Program.fromString(program).getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        // If the offline query exists, add the inclusion key.
        if (offlineQuery && !this.inclusionKeysLoaded) {
            console.log("Loading inclusion keys for offline proving.");
            try {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
                console.log("Successfully loaded inclusion key");
            }
            catch {
                logAndThrow(`Inclusion key bytes not loaded, please ensure the program manager is initialized with a KeyProvider that includes the inclusion key.`);
            }
        }
        // Build an execution transaction from the authorization.
        console.log("Executing authorizations");
        return await ProgramManager$1.executeAuthorization(authorization, feeAuthorization, program, provingKey, verifyingKey, feeProvingKey, feeVerifyingKey, imports, this.host, offlineQuery);
    }
    /**
     * Builds a SnarkVM `Authorization` for a specific function.
     *
     * @param {AuthorizationOptions} options - The options for building the `Authorization`
     * @returns {Promise<Authorization>} - A promise that resolves to an `Authorization` or throws an Error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a ProgramManager with the key and record providers.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build the `Authorization`.
     * const authorization = await programManager.buildAuthorization({
     *   programName: "credits.aleo",
     *   functionName: "transfer_public",
     *   inputs: [
     *     "aleo1vwls2ete8dk8uu2kmkmzumd7q38fvshrht8hlc0a5362uq8ftgyqnm3w08",
     *     "10000000u64",
     *   ],
     * });
     */
    async buildAuthorization(options) {
        // Destructure the options object to access the parameters.
        const { functionName, inputs, } = options;
        const privateKey = options.privateKey;
        let program = options.programSource;
        let programName = options.programName;
        let imports = options.programImports;
        let edition = options.edition;
        // Ensure the function exists on the network.
        if (program === undefined) {
            try {
                program = (await this.networkClient.getProgram(programName));
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (program instanceof Program) {
            program = program.toString();
        }
        // Get the program name if it is not provided in the parameters.
        if (programName === undefined) {
            programName = Program.fromString(program).id();
        }
        // Get the private key from the account if it is not provided in the parameters.
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        if (edition == undefined) {
            try {
                edition = await this.networkClient.getLatestProgramEdition(programName);
            }
            catch (e) {
                console.warn(`Error finding edition for ${programName}. Network response: '${e.message}'. Assuming edition 1.`);
                edition = 1;
            }
        }
        // Resolve the program imports if they exist.
        const numberOfImports = Program.fromString(program).getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        // Build and return an `Authorization` for the desired function.
        return await ProgramManager$1.authorize(executionPrivateKey, program, functionName, inputs, imports, edition);
    }
    /**
     * Builds a SnarkVM `Authorization` for a specific function without building a circuit first. This should be used when fast authorization generation is needed and the invoker is confident inputs are coorect.
     *
     * @param {AuthorizationOptions} options - The options for building the `Authorization`
     * @returns {Promise<Authorization>} - A promise that resolves to an `Authorization` or throws an Error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a ProgramManager with the key and record providers.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build the unchecked `Authorization`.
     * const authorization = await programManager.buildAuthorizationUnchecked({
     *   programName: "credits.aleo",
     *   functionName: "transfer_public",
     *   inputs: [
     *     "aleo1vwls2ete8dk8uu2kmkmzumd7q38fvshrht8hlc0a5362uq8ftgyqnm3w08",
     *     "10000000u64",
     *   ],
     * });
     */
    async buildAuthorizationUnchecked(options) {
        // Destructure the options object to access the parameters.
        const { functionName, inputs, } = options;
        const privateKey = options.privateKey;
        let program = options.programSource;
        let programName = options.programName;
        let imports = options.programImports;
        let edition = options.edition;
        // Ensure the function exists on the network.
        if (program === undefined) {
            try {
                program = (await this.networkClient.getProgram(programName));
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (program instanceof Program) {
            program = program.toString();
        }
        // Get the program name if it is not provided in the parameters.
        if (programName === undefined) {
            programName = Program.fromString(program).id();
        }
        // Get the private key from the account if it is not provided in the parameters.
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Resolve the program imports if they exist.
        const numberOfImports = Program.fromString(program).getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        if (edition == undefined) {
            try {
                edition = await this.networkClient.getLatestProgramEdition(programName);
            }
            catch (e) {
                console.warn(`Error finding edition for ${programName}. Network response: '${e.message}'. Assuming edition 1.`);
                edition = 1;
            }
        }
        // Build and return an `Authorization` for the desired function.
        return await ProgramManager$1.buildAuthorizationUnchecked(executionPrivateKey, program, functionName, inputs, imports, edition);
    }
    /**
     * Builds a `ProvingRequest` for submission to a prover for execution.
     *
     * @param {ProvingRequestOptions} options - The options for building the proving request
     * @returns {Promise<ProvingRequest>} - A promise that resolves to the transaction or an error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a ProgramManager with the key and record providers.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build the proving request.
     * const provingRequest = await programManager.provingRequest({
     *   programName: "credits.aleo",
     *   functionName: "transfer_public",
     *   priorityFee: 0,
     *   privateFee: false,
     *   inputs: [
     *     "aleo1vwls2ete8dk8uu2kmkmzumd7q38fvshrht8hlc0a5362uq8ftgyqnm3w08",
     *     "10000000u64",
     *   ],
     *   broadcast: false,
     * });
     */
    async provingRequest(options) {
        // Destructure the options object to access the parameters.
        const { functionName, priorityFee, privateFee, inputs, recordSearchParams, broadcast = false, unchecked = false, } = options;
        const privateKey = options.privateKey;
        const baseFee = options.baseFee ? options.baseFee : 0;
        let program = options.programSource;
        let programName = options.programName;
        let feeRecord = options.feeRecord;
        let imports = options.programImports;
        let edition = options.edition;
        // Ensure the function exists on the network.
        if (program === undefined) {
            try {
                program = (await this.networkClient.getProgram(programName));
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (program instanceof Program) {
            program = program.toString();
        }
        // Get the program name if it is not provided in the parameters.
        if (programName === undefined) {
            programName = Program.fromString(program).id();
        }
        if (edition == undefined) {
            try {
                edition = await this.networkClient.getLatestProgramEdition(programName);
            }
            catch (e) {
                console.warn(`Error finding edition for ${programName}. Network response: '${e.message}'. Assuming edition 1.`);
                edition = 1;
            }
        }
        // Get the private key from the account if it is not provided in the parameters.
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Resolve the program imports if they exist.
        const numberOfImports = Program.fromString(program).getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a fee record wasn't provided, estimate the fee that needs to be paid.
                if (!feeRecord) {
                    const baseFee = Number(await this.estimateExecutionFee({ programName, functionName, program: program.toString(), imports }));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Build and return the `ProvingRequest`.
        return await ProgramManager$1.buildProvingRequest(executionPrivateKey, program, functionName, inputs, baseFee, priorityFee, feeRecord, imports, broadcast, unchecked, edition);
    }
    /**
     * Builds a SnarkVM fee `Authorization` for `credits.aleo/fee_private` or `credits.aleo/fee_public`. If a record is provided `fee_private` will be executed, otherwise `fee_public` will be executed.
     *
     * @param {FeeAuthorizationOptions} options - The options for building the `Authorization`.
     * @returns {Promise<Authorization>} - A promise that resolves to an `Authorization` or throws an Error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider.
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a ProgramManager with the key and record providers.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build a credits.aleo/fee_public `Authorization`.
     * const feePublicAuthorization = await programManager.buildFeeAuthorization({
     *   deploymentOrExecutionId: "2423957656946557501636078245035919227529640894159332581642187482178647335171field",
     *   baseFeeCredits: 0.1,
     * });
     *
     * // Build a credits.aleo/fee_private `Authorization`.
     * const record = "{ owner: aleo1j7qxyunfldj2lp8hsvy7mw5k8zaqgjfyr72x2gh3x4ewgae8v5gscf5jh3.private, microcredits: 1500000000000000u64.private, _nonce: 3077450429259593211617823051143573281856129402760267155982965992208217472983group.public }";
     * const feePrivateAuthorization = await programManager.buildFeeAuthorization({
     *   deploymentOrExecutionId: "2423957656946557501636078245035919227529640894159332581642187482178647335171field",
     *   baseFeeCredits: 0.1,
     *   feeRecord: record,
     * });
     */
    async buildFeeAuthorization(options) {
        // Destructure the options object to access the parameters.
        const { privateKey, deploymentOrExecutionId, baseFeeCredits, priorityFeeCredits, feeRecord, } = options;
        // Get the private key from the account if it is not provided in the parameters.
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Build and return the fee `Authorization`.
        return await ProgramManager$1.authorizeFee(executionPrivateKey, deploymentOrExecutionId, baseFeeCredits, priorityFeeCredits || 0, feeRecord);
    }
    /**
     * Builds an execution transaction for submission to the Aleo network.
     *
     * @param {ExecuteOptions} options - The options for the execution transaction.
     * @returns {Promise<string>} - The transaction id
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider using official Aleo record, key, and network providers
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     *
     * // Build and execute the transaction
     * const tx_id = await programManager.execute({
     *   programName: "hello_hello.aleo",
     *   functionName: "hello_hello",
     *   priorityFee: 0.0,
     *   privateFee: false,
     *   inputs: ["5u32", "5u32"],
     *   keySearchParams: { "cacheKey": "hello_hello:hello" }
     * });
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async execute(options) {
        const tx = await this.buildExecutionTransaction(options);
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Run an Aleo program in offline mode
     *
     * @param {string} program Program source code containing the function to be executed
     * @param {string} function_name Function name to execute
     * @param {string[]} inputs Inputs to the function
     * @param {number} proveExecution Whether to prove the execution of the function and return an execution transcript that contains the proof.
     * @param {string[] | undefined} imports Optional imports to the program
     * @param {KeySearchParams | undefined} keySearchParams Optional parameters for finding the matching proving & verifying keys for the function
     * @param {ProvingKey | undefined} provingKey Optional proving key to use for the transaction
     * @param {VerifyingKey | undefined} verifyingKey Optional verifying key to use for the transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<ExecutionResponse>} The execution response containing the outputs of the function and the proof if the program is proved.
     *
     * @example
     * /// Import the mainnet version of the sdk used to build executions.
     * import { Account, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * /// Create the source for the "helloworld" program
     * const program = "program helloworld.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager(undefined, undefined, undefined);
     *
     * /// Create a temporary account for the execution of the program
     * const account = new Account();
     * programManager.setAccount(account);
     *
     * /// Get the response and ensure that the program executed correctly
     * const executionResponse = await programManager.run(program, "hello", ["5u32", "5u32"]);
     * const result = executionResponse.getOutputs();
     * assert(result === ["10u32"]);
     */
    async run(program, function_name, inputs, proveExecution, imports, keySearchParams, provingKey, verifyingKey, privateKey, offlineQuery, edition) {
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // If the function proving and verifying keys are not provided, attempt to find them using the key provider
        if (!provingKey || !verifyingKey) {
            try {
                [provingKey, verifyingKey] = (await this.keyProvider.functionKeys(keySearchParams));
            }
            catch (e) {
                console.log(`Function keys not found. Key finder response: '${e}'. The function keys will be synthesized`);
            }
        }
        // Run the program offline and return the result
        console.log("Running program offline");
        console.log("Proving key: ", provingKey);
        console.log("Verifying key: ", verifyingKey);
        return ProgramManager$1.executeFunctionOffline(executionPrivateKey, program, function_name, inputs, proveExecution, false, imports, provingKey, verifyingKey, this.host, offlineQuery, edition);
    }
    /**
     * Join two credits records into a single credits record
     *
     * @param {RecordPlaintext | string} recordOne First credits record to join
     * @param {RecordPlaintext | string} recordTwo Second credits record to join
     * @param {number} priorityFee The optional priority fee to be paid for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the fee record to use to pay the fee for the join transaction
     * @param {RecordPlaintext | string | undefined} feeRecord Fee record to use for the join transaction
     * @param {PrivateKey | undefined} privateKey Private key to use for the join transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const record_1 = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}"
     * const record_2 = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 1540945439182663264862696551825005342995406165131907382295858612069623286213group.public}"
     * const tx_id = await programManager.join(record_1, record_2, 0.05, false);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async join(recordOne, recordTwo, priorityFee, privateFee, recordSearchParams, feeRecord, privateKey, offlineQuery) {
        // Get the private key from the account if it is not provided in the parameters and assign the fee address
        let executionPrivateKey = privateKey;
        let feeAddress;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
            feeAddress = this.account?.address();
        }
        else if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        else {
            feeAddress = Address.from_private_key(executionPrivateKey);
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        let joinKeys;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
            joinKeys = await this.keyProvider.joinKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        const [joinProvingKey, joinVerifyingKey] = joinKeys;
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a fee record wasn't provided, estimate the fee that needs to be paid.
                if (!feeRecord) {
                    const baseFee = Number(await this.estimateExecutionFee({ programName: "credits.aleo", functionName: "join" }));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Validate the records provided are valid plaintext records
        try {
            recordOne =
                recordOne instanceof RecordPlaintext
                    ? recordOne
                    : RecordPlaintext.fromString(recordOne);
            recordTwo =
                recordTwo instanceof RecordPlaintext
                    ? recordTwo
                    : RecordPlaintext.fromString(recordTwo);
        }
        catch (e) {
            logAndThrow("Records provided are not valid. Please ensure they are valid plaintext records.");
        }
        // Load the inclusion prover offline.
        if (offlineQuery && !this.inclusionKeysLoaded) {
            try {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
                console.log("Successfully loaded inclusion key");
            }
            catch {
                logAndThrow(`Inclusion key bytes not loaded, please ensure the program manager is initialized with a KeyProvider that includes the inclusion key.`);
            }
        }
        // Build an execution transaction and submit it to the network
        const tx = await ProgramManager$1.buildJoinTransaction(executionPrivateKey, recordOne, recordTwo, priorityFee, feeRecord, this.host, joinProvingKey, joinVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
        // Check if the account has sufficient credits to pay for the transaction
        if (!privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Split credits into two new credits records
     *
     * @param {number} splitAmount Amount in microcredits to split from the original credits record
     * @param {RecordPlaintext | string} amountRecord Amount record to use for the split transaction
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the split transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const record = "{  owner: aleo184vuwr5u7u0ha5f5k44067dd2uaqewxx6pe5ltha5pv99wvhfqxqv339h4.private,  microcredits: 45000000u64.private,  _nonce: 4106205762862305308495708971985748592380064201230396559307556388725936304984group.public}"
     * const tx_id = await programManager.split(25000000, record);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async split(splitAmount, amountRecord, privateKey, offlineQuery) {
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the split keys from the key provider
        let splitKeys;
        try {
            splitKeys = await this.keyProvider.splitKeys();
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [splitProvingKey, splitVerifyingKey] = splitKeys;
        // Validate the record to be split
        try {
            amountRecord =
                amountRecord instanceof RecordPlaintext
                    ? amountRecord
                    : RecordPlaintext.fromString(amountRecord);
        }
        catch (e) {
            logAndThrow("Record provided is not valid. Please ensure it is a valid plaintext record.");
        }
        // Load the inclusion prover offline.
        if (offlineQuery && !this.inclusionKeysLoaded) {
            try {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
                console.log("Successfully loaded inclusion key");
            }
            catch {
                logAndThrow(`Inclusion key bytes not loaded, please ensure the program manager is initialized with a KeyProvider that includes the inclusion key.`);
            }
        }
        // Build an execution transaction and submit it to the network
        const tx = await ProgramManager$1.buildSplitTransaction(executionPrivateKey, splitAmount, amountRecord, this.host, splitProvingKey, splitVerifyingKey, offlineQuery);
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Pre-synthesize proving and verifying keys for a program
     *
     * @param program {string} The program source code to synthesize keys for
     * @param function_id {string} The function id to synthesize keys for
     * @param inputs {Array<string>}  Sample inputs to the function
     * @param privateKey {PrivateKey | undefined} Optional private key to use for the key synthesis
     *
     * @returns {Promise<FunctionKeyPair>}
     */
    async synthesizeKeys(program, function_id, inputs, privateKey) {
        // Resolve the program imports if they exist
        let imports;
        let executionPrivateKey = privateKey;
        if (typeof executionPrivateKey === "undefined") {
            if (typeof this.account !== "undefined") {
                executionPrivateKey = this.account.privateKey();
            }
            else {
                executionPrivateKey = new PrivateKey();
            }
        }
        // Attempt to run an offline execution of the program and extract the proving and verifying keys
        try {
            imports = await this.networkClient.getProgramImports(program);
            const keyPair = await ProgramManager$1.synthesizeKeyPair(executionPrivateKey, program, function_id, inputs, imports);
            return [
                keyPair.provingKey(),
                keyPair.verifyingKey(),
            ];
        }
        catch (e) {
            logAndThrow(`Could not synthesize keys - error ${e.message}. Please ensure the program is valid and the inputs are correct.`);
        }
    }
    /**
     * Build a transaction to transfer credits to another account for later submission to the Aleo network
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
     * @param {number} priorityFee The optional priority fee to be paid for the transaction
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction
     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const tx = await programManager.buildTransferTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "public", 0.2, false);
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildTransferTransaction(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
        // Validate the transfer type
        transferType = validateTransferType(transferType);
        // Get the private key from the account if it is not provided in the parameters
        let executionPrivateKey = privateKey;
        if (typeof executionPrivateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the proving and verifying keys from the key provider
        let feeKeys;
        let transferKeys;
        try {
            feeKeys = privateFee
                ? await this.keyProvider.feePrivateKeys()
                : await this.keyProvider.feePublicKeys();
            transferKeys = (await this.keyProvider.transferKeys(transferType));
        }
        catch (e) {
            logAndThrow(`Error finding fee keys. Key finder response: '${e.message}'. Please ensure your key provider is configured correctly.`);
        }
        const [feeProvingKey, feeVerifyingKey] = feeKeys;
        const [transferProvingKey, transferVerifyingKey] = transferKeys;
        // Get the amount and fee record from the account if it is not provided in the parameters
        try {
            // Track the nonces of the records found so no duplicate records are used
            const nonces = [];
            if (requiresAmountRecord(transferType)) {
                // If the transfer type is private and requires an amount record, get it from the record provider
                amountRecord = await this.getCreditsRecord(priorityFee, [], amountRecord, recordSearchParams);
                nonces.push(amountRecord.nonce());
            }
            else {
                amountRecord = undefined;
            }
            if (privateFee) {
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(priorityFee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Load the inclusion prover offline.
        if (offlineQuery && !this.inclusionKeysLoaded) {
            const inclusionKeys = await this.keyProvider.inclusionKeys();
            ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
            try {
                const inclusionKeys = await this.keyProvider.inclusionKeys();
                ProgramManager$1.loadInclusionProver(inclusionKeys[0]);
                this.inclusionKeysLoaded = true;
                console.log("Successfully loaded inclusion key");
            }
            catch {
                logAndThrow(`Inclusion key bytes not loaded, please ensure the program manager is initialized with a KeyProvider that includes the inclusion key.`);
            }
        }
        // Build an execution transaction
        return await ProgramManager$1.buildTransferTransaction(executionPrivateKey, amount, recipient, transferType, amountRecord, priorityFee, feeRecord, this.host, transferProvingKey, transferVerifyingKey, feeProvingKey, feeVerifyingKey, offlineQuery);
    }
    /**
     * Build a transfer_public transaction to transfer credits to another account for later submission to the Aleo network
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {number} priorityFee The optional priority fee to be paid for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const tx = await programManager.buildTransferPublicTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0.2);
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildTransferPublicTransaction(amount, recipient, priorityFee, privateKey, offlineQuery) {
        return this.buildTransferTransaction(amount, recipient, "public", priorityFee, false, undefined, undefined, undefined, privateKey, offlineQuery);
    }
    /**
     * Build a transfer_public_as_signer transaction to transfer credits to another account for later submission to the Aleo network
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {number} priorityFee The optional priority fee to be paid for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const tx = await programManager.buildTransferPublicAsSignerTransaction(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", 0.2);
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildTransferPublicAsSignerTransaction(amount, recipient, priorityFee, privateKey, offlineQuery) {
        return this.buildTransferTransaction(amount, recipient, "public", priorityFee, false, undefined, undefined, undefined, privateKey, offlineQuery);
    }
    /**
     * Transfer credits to another account
     *
     * @param {number} amount The amount of credits to transfer
     * @param {string} recipient The recipient of the transfer
     * @param {string} transferType The type of transfer to perform - options: 'private', 'privateToPublic', 'public', 'publicToPrivate'
     * @param {number} priorityFee The optional priority fee to be paid for the transfer
     * @param {boolean} privateFee Use a private record to pay the fee. If false this will use the account's public credit balance
     * @param {RecordSearchParams | undefined} recordSearchParams Optional parameters for finding the amount and fee records for the transfer transaction
     * @param {RecordPlaintext | string} amountRecord Optional amount record to use for the transfer
     * @param {RecordPlaintext | string} feeRecord Optional fee record to use for the transfer
     * @param {PrivateKey | undefined} privateKey Optional private key to use for the transfer transaction
     * @param {OfflineQuery | undefined} offlineQuery Optional offline query if creating transactions in an offline environment
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, KeyProvider, and RecordProvider
     * const keyProvider = new AleoKeyProvider();
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, recordProvider);
     * const tx_id = await programManager.transfer(1, "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "public", 0.2, false);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async transfer(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery) {
        const tx = (await this.buildTransferTransaction(amount, recipient, transferType, priorityFee, privateFee, recordSearchParams, amountRecord, feeRecord, privateKey, offlineQuery));
        let feeAddress;
        if (typeof privateKey !== "undefined") {
            feeAddress = Address.from_private_key(privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build transaction to bond credits to a validator for later submission to the Aleo Network
     *
     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
     * @param {number} amount The amount of credits to bond
     * @param {Partial<ExecuteOptions>} options - Override default execution options.
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction object for later submission
     * const tx = await programManager.buildBondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
     *
     * // The transaction can be later submitted to the network using the network client.
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildBondPublicTransaction(validator_address, withdrawal_address, amount, options = {}) {
        const scaledAmount = Math.trunc(amount * 1000000);
        const { programName = "credits.aleo", functionName = "bond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [
            validator_address,
            withdrawal_address,
            `${scaledAmount.toString()}u64`,
        ], keySearchParams = new AleoKeyProviderParams({
            proverUri: CREDITS_PROGRAM_KEYS.bond_public.prover,
            verifierUri: CREDITS_PROGRAM_KEYS.bond_public.verifier,
            cacheKey: "credits.aleo/bond_public",
        }), program = this.creditsProgram(), ...additionalOptions } = options;
        const executeOptions = {
            programName,
            functionName,
            priorityFee,
            privateFee,
            inputs,
            keySearchParams,
            program,
            ...additionalOptions,
        };
        return await this.buildExecutionTransaction(executeOptions);
    }
    /**
     * Bond credits to validator.
     *
     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the signer (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 1,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
     * @param {number} amount The amount of credits to bond
     * @param {Options} options Options for the execution
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     *
     * // Create the bonding transaction
     * tx_id = await programManager.bondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async bondPublic(validator_address, withdrawal_address, amount, options = {}) {
        const tx = (await this.buildBondPublicTransaction(validator_address, withdrawal_address, amount, options));
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build a bond_validator transaction for later submission to the Aleo Network.
     *
     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator.
     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
     * @param {number} amount The amount of credits to bond. A minimum of 10000 credits is required to bond as a delegator.
     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)
     * @param {Partial<ExecuteOptions>} options - Override default execution options.
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bond validator transaction object for later use.
     * const tx = await programManager.buildBondValidatorTransaction("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
     *
     * // The transaction can later be submitted to the network using the network client.
     * const tx_id = await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options = {}) {
        const scaledAmount = Math.trunc(amount * 1000000);
        const adjustedCommission = Math.trunc(commission);
        const { programName = "credits.aleo", functionName = "bond_validator", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [
            validator_address,
            withdrawal_address,
            `${scaledAmount.toString()}u64`,
            `${adjustedCommission.toString()}u8`,
        ], keySearchParams = new AleoKeyProviderParams({
            proverUri: CREDITS_PROGRAM_KEYS.bond_validator.prover,
            verifierUri: CREDITS_PROGRAM_KEYS.bond_validator.verifier,
            cacheKey: "credits.aleo/bond_validator",
        }), program = this.creditsProgram(), ...additionalOptions } = options;
        const executeOptions = {
            programName,
            functionName,
            priorityFee,
            privateFee,
            inputs,
            keySearchParams,
            program,
            ...additionalOptions,
        };
        return await this.buildExecutionTransaction(executeOptions);
    }
    /**
     * Build transaction to bond a validator.
     *
     * @param {string} validator_address Address of the validator to bond to, if this address is the same as the staker (i.e. the executor of this function), it will attempt to bond the credits as a validator. Bonding as a validator currently requires a minimum of 10,000,000 credits to bond (subject to change). If the address is specified is an existing validator and is different from the address of the executor of this function, it will bond the credits to that validator's staking committee as a delegator. A minimum of 10 credits is required to bond as a delegator.
     * @param {string} withdrawal_address Address to withdraw the staked credits to when unbond_public is called.
     * @param {number} amount The amount of credits to bond
     * @param {number} commission The commission rate for the validator (must be between 0 and 100 - an error will be thrown if it is not)
     * @param {Partial<ExecuteOptions>} options - Override default execution options.
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the bonding transaction
     * const tx_id = await programManager.bondValidator("aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px", "aleo1feya8sjy9k2zflvl2dx39pdsq5tju28elnp2ektnn588uu9ghv8s84msv9", 2000000);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async bondValidator(validator_address, withdrawal_address, amount, commission, options = {}) {
        const tx = (await this.buildBondValidatorTransaction(validator_address, withdrawal_address, amount, commission, options));
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build an unbond_public execution transaction to unbond credits from a validator in the Aleo network.
     *
     * @param {string} staker_address - The address of the staker who is unbonding the credits.
     * @param {number} amount - The amount of credits to unbond (scaled by 1,000,000).
     * @param {Partial<ExecuteOptions>} options - Override default execution options.
     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management.
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to unbond credits.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * const tx = await programManager.buildUnbondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", 2000000);
     *
     * // The transaction can be submitted later to the network using the network client.
     * programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildUnbondPublicTransaction(staker_address, amount, options = {}) {
        const scaledAmount = Math.trunc(amount * 1000000);
        const { programName = "credits.aleo", functionName = "unbond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [staker_address, `${scaledAmount.toString()}u64`], keySearchParams = new AleoKeyProviderParams({
            proverUri: CREDITS_PROGRAM_KEYS.unbond_public.prover,
            verifierUri: CREDITS_PROGRAM_KEYS.unbond_public.verifier,
            cacheKey: "credits.aleo/unbond_public",
        }), program = this.creditsProgram(), ...additionalOptions } = options;
        const executeOptions = {
            programName,
            functionName,
            priorityFee,
            privateFee,
            inputs,
            keySearchParams,
            program,
            ...additionalOptions,
        };
        return this.buildExecutionTransaction(executeOptions);
    }
    /**
     * Unbond a specified amount of staked credits. If the address of the executor of this function is an existing
     * validator, it will subtract this amount of credits from the validator's staked credits. If there are less than
     * 1,000,000 credits staked pool after the unbond, the validator will be removed from the validator set. If the
     * address of the executor of this function is not a validator and has credits bonded as a delegator, it will
     * subtract this amount of credits from the delegator's staked credits. If there are less than 10 credits bonded
     * after the unbond operation, the delegator will be removed from the validator's staking pool.
     *
     * @param {string} staker_address Address of the staker who is unbonding the credits
     * @param {number} amount Amount of credits to unbond.
     * @param {ExecuteOptions} options Options for the execution
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the unbond_public transaction and send it to the network
     * const tx_id = await programManager.unbondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j", 10);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async unbondPublic(staker_address, amount, options = {}) {
        const tx = (await this.buildUnbondPublicTransaction(staker_address, amount, options));
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build a transaction to claim unbonded public credits in the Aleo network.
     *
     * @param {string} staker_address - The address of the staker who is claiming the credits.
     * @param {Partial<ExecuteOptions>} options - Override default execution options.
     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error message.
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to claim unbonded credits.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     *
     * // Create the claim_unbond_public transaction object for later use.
     * const tx = await programManager.buildClaimUnbondPublicTransaction("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j");
     *
     * // The transaction can be submitted later to the network using the network client.
     * programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildClaimUnbondPublicTransaction(staker_address, options = {}) {
        const { programName = "credits.aleo", functionName = "claim_unbond_public", priorityFee = options.priorityFee || 0, privateFee = false, inputs = [staker_address], keySearchParams = new AleoKeyProviderParams({
            proverUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.prover,
            verifierUri: CREDITS_PROGRAM_KEYS.claim_unbond_public.verifier,
            cacheKey: "credits.aleo/claim_unbond_public",
        }), program = this.creditsProgram(), ...additionalOptions } = options;
        const executeOptions = {
            programName,
            functionName,
            priorityFee,
            privateFee,
            inputs,
            keySearchParams,
            program,
            ...additionalOptions,
        };
        // Check if the account has sufficient credits to pay for the transaction
        return await this.buildExecutionTransaction(executeOptions);
    }
    /**
     * Claim unbonded credits. If credits have been unbonded by the account executing this function, this method will
     * claim them and add them to the public balance of the account.
     *
     * @param {string} staker_address Address of the staker who is claiming the credits
     * @param {ExecuteOptions} options
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     * programManager.setAccount(new Account("YourPrivateKey"));
     *
     * // Create the claim_unbond_public transaction
     * const tx_id = await programManager.claimUnbondPublic("aleo1jx8s4dvjepculny4wfrzwyhs3tlyv65r58ns3g6q2gm2esh7ps8sqy9s5j");
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async claimUnbondPublic(staker_address, options = {}) {
        const tx = (await this.buildClaimUnbondPublicTransaction(staker_address, options));
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return await this.networkClient.submitTransaction(tx);
    }
    /**
     * Build a set_validator_state transaction for later usage.
     *
     * This function allows a validator to set their state to be either opened or closed to new stakers.
     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.
     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.
     *
     * This function serves two primary purposes:
     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.
     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.
     *
     * @param {boolean} validator_state
     * @param {Partial<ExecuteOptions>} options - Override default execution options
     * @returns {Promise<Transaction>} The transaction object
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     *
     * // Create the set_validator_state transaction
     * const tx = await programManager.buildSetValidatorStateTransaction(true);
     *
     * // The transaction can be submitted later to the network using the network client.
     * programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildSetValidatorStateTransaction(validator_state, options = {}) {
        const { programName = "credits.aleo", functionName = "set_validator_state", priorityFee = 0, privateFee = false, inputs = [validator_state.toString()], keySearchParams = new AleoKeyProviderParams({
            proverUri: CREDITS_PROGRAM_KEYS.set_validator_state.prover,
            verifierUri: CREDITS_PROGRAM_KEYS.set_validator_state.verifier,
            cacheKey: "credits.aleo/set_validator_state",
        }), program = this.creditsProgram(), ...additionalOptions } = options;
        const executeOptions = {
            programName,
            functionName,
            priorityFee,
            privateFee,
            inputs,
            keySearchParams,
            program,
            ...additionalOptions,
        };
        return await this.buildExecutionTransaction(executeOptions);
    }
    /**
     * Submit a set_validator_state transaction to the Aleo Network.
     *
     * This function allows a validator to set their state to be either opened or closed to new stakers.
     * When the validator is open to new stakers, any staker (including the validator) can bond or unbond from the validator.
     * When the validator is closed to new stakers, existing stakers can still bond or unbond from the validator, but new stakers cannot bond.
     *
     * This function serves two primary purposes:
     * 1. Allow a validator to leave the committee, by closing themselves to stakers and then unbonding all of their stakers.
     * 2. Allow a validator to maintain their % of stake, by closing themselves to allowing more stakers to bond to them.
     *
     * @param {boolean} validator_state
     * @param {Partial<ExecuteOptions>} options - Override default execution options
     * @returns {Promise<string>} The transaction id
     *
     * @example
     * // Import the mainnet version of the sdk.
     * import { AleoKeyProvider, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a keyProvider to handle key management
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Create a new ProgramManager with the key that will be used to bond credits
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider, undefined);
     *
     * // Create the set_validator_state transaction
     * const tx_id = await programManager.setValidatorState(true);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx_id);
     *  assert(transaction.id() === tx_id);
     * }, 10000);
     */
    async setValidatorState(validator_state, options = {}) {
        const tx = (await this.buildSetValidatorStateTransaction(validator_state, options));
        let feeAddress;
        if (typeof options.privateKey !== "undefined") {
            feeAddress = Address.from_private_key(options.privateKey);
        }
        else if (this.account !== undefined) {
            feeAddress = this.account?.address();
        }
        else {
            throw Error("No private key provided and no private key set in the ProgramManager. Please set an account or provide a private key.");
        }
        // Check if the account has sufficient credits to pay for the transaction
        if (!options.privateFee) {
            await this.checkFee(feeAddress.to_string(), tx.feeAmount());
        }
        return this.networkClient.submitTransaction(tx);
    }
    /**
     * Verify a proof from an offline execution. This is useful when it is desired to do offchain proving and verification.
     *
     * @param {executionResponse} executionResponse The response from an offline function execution (via the `programManager.run` method)
     * @param {blockHeight} blockHeight The ledger height when the execution was generated.
     * @param {ImportedPrograms} imports The imported programs used in the execution. Specified as { "programName": "programSourceCode", ... }
     * @param {ImportedVerifyingKeys} importedVerifyingKeys The verifying keys in the execution. Specified as { "programName": [["functionName", "verifyingKey"], ...], ... }
     * @returns {boolean} True if the proof is valid, false otherwise
     *
     * @example
     * /// Import the mainnet version of the sdk used to build executions.
     * import { Account, ProgramManager } from "@provablehq/sdk/mainnet.js";
     *
     * /// Create the source for two programs.
     * const program = "import add_it_up.aleo; \n\n program mul_add.aleo;\n\nfunction mul_and_add:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    mul r0 r1 into r2;\n call add_it_up.aleo/add_it r1 r2 into r3;  output r3 as u32.private;\n";
     * const program_import = "program add_it_up.aleo;\n\nfunction add_it:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager(undefined, undefined, undefined);
     *
     * /// Create a temporary account for the execution of the program
     * const account = Account.fromCipherText(process.env.ciphertext, process.env.password);
     * programManager.setAccount(account);
     *
     * /// Get the response and ensure that the program executed correctly
     * const executionResponse = await programManager.run(program, "mul_and_add", ["5u32", "5u32"], true);
     *
     * /// Construct the imports and verifying keys
     * const imports = { "add_it_up.aleo": program_import };
     * const importedVerifyingKeys = { "add_it_up.aleo": [["add_it", "verifyingKey1..."]] };
     *
     * /// Verify the execution.
     * const blockHeight = 9000000;
     * const isValid = programManager.verifyExecution(executionResponse, blockHeight, imports, importedVerifyingKeys);
     * assert(isValid);
     */
    verifyExecution(executionResponse, blockHeight, imports, importedVerifyingKeys) {
        try {
            const execution = (executionResponse.getExecution());
            const function_id = executionResponse.getFunctionId();
            const program = executionResponse.getProgram();
            const verifyingKey = executionResponse.getVerifyingKey();
            return verifyFunctionExecution(execution, verifyingKey, program, function_id, imports, importedVerifyingKeys, blockHeight);
        }
        catch (e) {
            console.warn(`The execution was not found in the response, cannot verify the execution: ${e}`);
            return false;
        }
    }
    /**
     * Create a program object from a program's source code
     *
     * @param {string} program Program source code
     * @returns {Program} The program object
     */
    createProgramFromSource(program) {
        return Program.fromString(program);
    }
    /**
     * Get the credits program object
     *
     * @returns {Program} The credits program object
     */
    creditsProgram() {
        return Program.getCreditsProgram();
    }
    /**
     * Verify a program is valid
     *
     * @param {string} program The program source code
     */
    verifyProgram(program) {
        try {
            Program.fromString(program);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Estimate the execution fee for an authorization.
     *
     * @param {FeeEstimateOptions} options Options for fee estimate.
     *
     * @example
     * import { AleoKeyProvider, PrivateKey, initThreadPool, ProgramManager } from "@provablehq/sdk";
     *
     * await initThreadPool();
     *
     * // Create a new KeyProvider.
     * const keyProvider = new AleoKeyProvider();
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider);
     *
     * // Build the `Authorization`.
     * const privateKey = new PrivateKey(); // Change this to a private key that has an aleo credit balance.
     * const authorization = await programManager.buildAuthorization({
     *     programName: "credits.aleo",
     *     functionName: "transfer_public",
     *     privateKey,
     *     inputs: [
     *         "aleo1vwls2ete8dk8uu2kmkmzumd7q38fvshrht8hlc0a5362uq8ftgyqnm3w08",
     *         "10000000u64",
     *     ],
     * });
     *
     * console.log("Getting execution id");
     *
     * // Derive the execution ID and base fee.
     * const executionId = authorization.toExecutionId().toString();
     *
     * console.log("Estimating fee");
     *
     * // Get the base fee in microcredits.
     * const baseFeeMicrocredits = await programManager.estimateFeeForAuthorization({
     *      authorization,
     *      programName: "credits.aleo"
     * });
     * const baseFeeCredits = Number(baseFeeMicrocredits)/1000000;
     *
     * console.log("Building fee authorization");
     *
     * // Build a credits.aleo/fee_public `Authorization`.
     * const feeAuthorization = await programManager.buildFeeAuthorization({
     *     deploymentOrExecutionId: executionId,
     *     baseFeeCredits,
     *     privateKey
     * });
     */
    async estimateFeeForAuthorization(options) {
        const { authorization, programName, program, imports, edition } = options;
        if (!authorization) {
            throw new Error("Authorization must be provided if estimating fee for Authorization.");
        }
        const programSource = program ? program.toString() : await this.networkClient.getProgram(programName, edition);
        const programImports = imports ? imports : await this.networkClient.getProgramImports(programSource);
        console.log(JSON.stringify(programImports));
        if (Object.keys(programImports)) {
            return ProgramManager$1.estimateFeeForAuthorization(authorization, programSource, programImports, edition);
        }
        return ProgramManager$1.estimateFeeForAuthorization(authorization, programSource, imports, edition);
    }
    /**
     * Estimate the execution fee for an Aleo function.
     *
     * @param {FeeEstimateOptions} options Options for the fee estimate.
     *
     * @returns {Promise<bigint>} Execution fee in microcredits for the authorization.
     *
     * @example
     * import { AleoKeyProvider, PrivateKey, initThreadPool, ProgramManager } from "@provablehq/sdk";
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for executions.
     * const programManager = new ProgramManager("https://api.explorer.provable.com/v1", keyProvider);
     *
     * // Get the base fee in microcredits.
     * const baseFeeMicrocredits = await programManager.estimateExecutionFee({programName: "credits.aleo"});
     * const baseFeeCredits = Number(baseFeeMicrocredits)/1000000;
     *
     * console.log("Building fee authorization");
     *
     * // Build a credits.aleo/fee_public `Authorization`.
     * const baseFeeMicrocredits = await programManager.estimateFeeForAuthorization({
     *      programName: "credits.aleo",
     *      functionName: "transfer_public",
     * });
     * const baseFeeCredits = Number(baseFeeMicrocredits)/1000000;
     */
    async estimateExecutionFee(options) {
        const { functionName, programName, program, imports, edition } = options;
        if (!functionName) {
            throw new Error("Function name must be specified when estimating fee.");
        }
        const programSource = program ? program.toString() : await this.networkClient.getProgram(programName, edition);
        const programImports = imports ? imports : await this.networkClient.getProgramImports(programSource);
        if (Object.keys(programImports)) {
            return ProgramManager$1.estimateExecutionFee(programSource, functionName, programImports, edition);
        }
        return ProgramManager$1.estimateExecutionFee(programSource, functionName, imports, edition);
    }
    // Internal utility function for getting a credits.aleo record
    async getCreditsRecord(amount, nonces, record, params) {
        if (record) {
            try {
                return record instanceof RecordPlaintext
                    ? record : RecordPlaintext.fromString(record);
            }
            catch {
                logAndThrow(`Record '${record}' could not be parsed, please ensure a valid credits.aleo record 
                is passed prior to trying again`);
            }
        }
        else {
            try {
                const recordProvider = this.recordProvider;
                const record = await recordProvider.findCreditsRecord(amount, { ...params, unspent: true, nonces });
                if (record.record_plaintext) {
                    return RecordPlaintext.fromString(record.record_plaintext);
                }
                else {
                    logAndThrow("Failed to deserialize record returned from record provider");
                }
            }
            catch (e) {
                logAndThrow(`Error finding fee record. Record finder response: '${e}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
            }
        }
    }
    /**
     * Builds an execution transaction for submission to the a local devnode.
     * This method skips proof generation and is not meant for use with the mainnet or testnet Aleo networks.
     * Note: getOrInitConsensusVersionTestHeights must be called prior to using this method for this method to work properly.
     *
     * @param {ExecuteOptions} options - The options for the execution transaction.
     * @returns {Promise<Transaction>} - A promise that resolves to the transaction or an error.
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { AleoKeyProvider, getOrInitConsensusVersionTestHeights, ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Initialize the development consensus heights in order to work with devnode.
     * getOrInitConsensusVersionTestHeights("0,1,2,3,4,5,6,7,8,9,10,11");
     *
     * // Create a new NetworkClient and RecordProvider.
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager.
     * const programManager = new ProgramManager("http://localhost:3030", recordProvider);
     *
     * // Build and execute the transaction.
     * const tx = await programManager.buildDevnodeExecutionTransaction({
     *   programName: "hello_hello.aleo",
     *   functionName: "hello_hello",
     *   priorityFee: 0.0,
     *   privateFee: false,
     *   inputs: ["5u32", "5u32"],
     * });
     *
     * // Submit the transaction to the network
     * await programManager.networkClient.submitTransaction(tx.toString());
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 10000);
     */
    async buildDevnodeExecutionTransaction(options) {
        // Destructure the options object to access the parameters
        const { functionName, priorityFee, privateFee, inputs, recordSearchParams, privateKey, } = options;
        let feeRecord = options.feeRecord;
        let program = options.program;
        let programName = options.programName;
        let imports = options.imports;
        let edition = options.edition;
        let programObject;
        // Ensure the function exists on the network
        if (program === undefined) {
            try {
                programObject = await this.networkClient.getProgramObject(programName);
                program = programObject.toString();
            }
            catch (e) {
                logAndThrow(`Error finding ${programName}. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`);
            }
        }
        else if (typeof program == "string") {
            try {
                programObject = Program.fromString(program);
            }
            catch (e) {
                logAndThrow(`Program sources passed for ${programName} were invalid: ${e}`);
            }
        }
        else if (program instanceof Program) {
            programObject = program;
            program = program.toString();
        }
        if (!(programObject instanceof Program)) {
            logAndThrow(`Failed to validate program ${programName}`);
        }
        // Get the program name if it is not provided in the parameters.
        if (programName === undefined) {
            programName = programObject.id();
        }
        if (edition == undefined) {
            try {
                edition = await this.networkClient.getLatestProgramEdition(programName);
            }
            catch (e) {
                console.warn(`Error finding edition for ${programName}. Network response: '${e.message}'. Assuming edition 0.`);
                edition = 0;
            }
        }
        // Get the private key from the account if it is not provided in the parameters.
        let executionPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            executionPrivateKey = this.account.privateKey();
        }
        if (typeof executionPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee record from the account if it is not provided in the parameters.
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a private fee is specified, but no fee record is provided, estimate the fee and find a matching record.
                if (!feeRecord) {
                    console.log("Private fee specified, but no private fee record provided, estimating fee and finding a matching fee record.");
                    const programString = programObject.toString();
                    const imports = await this.networkClient.getProgramImports(programString);
                    const baseFee = Number(ProgramManager$1.estimateDeploymentFee(programString, imports));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Resolve the program imports if they exist.
        const numberOfImports = programObject.getImports().length;
        if (numberOfImports > 0 && !imports) {
            try {
                imports = (await this.networkClient.getProgramImports(programName));
            }
            catch (e) {
                logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
            }
        }
        // Build a transaction without a proof
        return await ProgramManager$1.buildDevnodeExecutionTransaction(executionPrivateKey, program, functionName, inputs, priorityFee, feeRecord, this.host, imports, edition);
    }
    /**
     * Builds a deployment transaction with placeholder certificates and verifying keys for each function in the program.
     * Intended for use with a local devnode.
     * `getOrInitConsensusVersionTestHeights` must be called with development heights prior to invoking this method for it to work properly.
     *
     * @param {DeployOptions} options - The options for the deployment transaction.
     * @returns {string} The transaction id of the deployed program or a failure message from the network
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { ProgramManager, NetworkRecordProvider, getOrInitConsensusVersionTestHeights } from "@provablehq/sdk/mainnet.js";
     *
     * // Initialize the development consensus heights in order to work with a local devnode.
     * getOrInitConsensusVersionTestHeights("0,1,2,3,4,5,6,7,8,9,10,11");
     *
     * // Create a new NetworkClient, and RecordProvider
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("http://localhost:3030", recordProvider);
     * programManager.setAccount(Account);
     *
     * // Define a fee in credits
     * const priorityFee = 0.0;
     *
     * // Create the deployment transaction.
     * const tx = await programManager.buildDevnodeDeploymentTransaction({program: program, fee: priorityFee, privateFee: false});
     * await programManager.networkClient.submitTransaction(tx);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 20000);
     */
    async buildDevnodeDeploymentTransaction(options) {
        const { program, priorityFee, privateFee, recordSearchParams } = options;
        let feeRecord = options.feeRecord;
        let privateKey = options.privateKey;
        // Ensure the program is valid.
        let programObject;
        try {
            programObject = Program.fromString(program);
        }
        catch (e) {
            logAndThrow(`Error parsing program: '${e.message}'. Please ensure the program is valid.`);
        }
        // Ensure the program is valid and does not exist on the network
        try {
            let programSource;
            try {
                programSource = await this.networkClient.getProgram(programObject.id());
            }
            catch (e) {
                // Program does not exist on the network, deployment can proceed
                console.log(`Program ${programObject.id()} does not exist on the network, deploying...`);
            }
            if (typeof programSource === "string") {
                throw Error(`Program ${programObject.id()} already exists on the network, please rename your program`);
            }
        }
        catch (e) {
            logAndThrow(`Error validating program: ${e.message}`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let deploymentPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            deploymentPrivateKey = this.account.privateKey();
        }
        if (typeof deploymentPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a private fee is specified, but no fee record is provided, estimate the fee and find a matching record.
                if (!feeRecord) {
                    console.log("Private fee specified, but no private fee record provided, estimating fee and finding a matching fee record.");
                    const programString = programObject.toString();
                    const imports = await this.networkClient.getProgramImports(programString);
                    const baseFee = Number(ProgramManager$1.estimateDeploymentFee(programString, imports));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(program);
        }
        catch (e) {
            logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        return await ProgramManager$1.buildDevnodeDeploymentTransaction(deploymentPrivateKey, program, priorityFee, feeRecord, this.host, imports);
    }
    /**
     * Builds an upgrade transaction on a local devnodewith placeholder certificates and verifying keys for each function in the program.
     * This method is only intended for use with a local devnode.
     *
     * @param {DeployOptions} options - The options for the deployment transaction.
     * @returns {string} The transaction id of the deployed program or a failure message from the network
     *
     * @example
     * /// Import the mainnet version of the sdk.
     * import { ProgramManager, NetworkRecordProvider } from "@provablehq/sdk/mainnet.js";
     *
     * // Create a new NetworkClient, and RecordProvider
     * const recordProvider = new NetworkRecordProvider(account, networkClient);
     * keyProvider.useCache(true);
     *
     * // Initialize a program manager with the key provider to automatically fetch keys for deployments
     * const program = "program hello_hello.aleo;\n\nfunction hello:\n    input r0 as u32.public;\n    input r1 as u32.private;\n    add r0 r1 into r2;\n    output r2 as u32.private;\n";
     * const programManager = new ProgramManager("http://localhost:3030", recordProvider);
     * programManager.setAccount(Account);
     *
     * // Define a fee in credits
     * const priorityFee = 0.0;
     *
     * // Create the deployment transaction.
     * const tx = await programManager.buildDevnodeUpgradeTransaction({program: program, fee: priorityFee, privateFee: false});
     * await programManager.networkClient.submitTransaction(tx);
     *
     * // Verify the transaction was successful
     * setTimeout(async () => {
     *  const transaction = await programManager.networkClient.getTransaction(tx.id());
     *  assert(transaction.id() === tx.id());
     * }, 20000);
     */
    async buildDevnodeUpgradeTransaction(options) {
        const { program, priorityFee, privateFee, recordSearchParams } = options;
        let feeRecord = options.feeRecord;
        let privateKey = options.privateKey;
        // Ensure the program is valid.
        let programObject;
        try {
            programObject = Program.fromString(program);
        }
        catch (e) {
            logAndThrow(`Error parsing program: '${e.message}'. Please ensure the program is valid.`);
        }
        // Ensure the program is valid and does not exist on the network.
        try {
            let programSource;
            try {
                programSource = await this.networkClient.getProgram(programObject.id());
            }
            catch (e) {
                // Program does not exist on the network.
                logAndThrow(`Program ${programObject.id()} does not exist on the network...`);
            }
        }
        catch (e) {
            logAndThrow(`Error validating program: ${e.message}`);
        }
        // Get the private key from the account if it is not provided in the parameters
        let deploymentPrivateKey = privateKey;
        if (typeof privateKey === "undefined" &&
            typeof this.account !== "undefined") {
            deploymentPrivateKey = this.account.privateKey();
        }
        if (typeof deploymentPrivateKey === "undefined") {
            throw "No private key provided and no private key set in the ProgramManager";
        }
        // Get the fee record from the account if it is not provided in the parameters
        try {
            if (privateFee) {
                let fee = priorityFee;
                // If a private fee is specified, but no fee record is provided, estimate the fee and find a matching record.
                if (!feeRecord) {
                    console.log("Private fee specified, but no private fee record provided, estimating fee and finding a matching fee record.");
                    const programString = programObject.toString();
                    const imports = await this.networkClient.getProgramImports(programString);
                    const baseFee = Number(ProgramManager$1.estimateDeploymentFee(programString, imports));
                    fee = baseFee + priorityFee;
                }
                // Get a credits.aleo record for the fee.
                feeRecord = await this.getCreditsRecord(fee, [], feeRecord, recordSearchParams);
            }
            else {
                // If it's specified NOT to use a privateFee, use a public fee.
                feeRecord = undefined;
            }
        }
        catch (e) {
            logAndThrow(`Error finding fee record. Record finder response: '${e.message}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`);
        }
        // Resolve the program imports if they exist
        let imports;
        try {
            imports = await this.networkClient.getProgramImports(program);
        }
        catch (e) {
            logAndThrow(`Error finding program imports. Network response: '${e.message}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`);
        }
        return ProgramManager$1.buildDevnodeUpgradeTransaction(deploymentPrivateKey, program, priorityFee, feeRecord, this.host, imports);
    }
}
// Ensure the transfer type requires an amount record
function requiresAmountRecord(transferType) {
    return PRIVATE_TRANSFER_TYPES.has(transferType);
}
// Validate the transfer type
function validateTransferType(transferType) {
    return VALID_TRANSFER_TYPES.has(transferType)
        ? transferType
        : logAndThrow(`Invalid transfer type '${transferType}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`);
}

// @TODO: This function is no longer needed, remove it.
async function initializeWasm() {
    console.warn("initializeWasm is deprecated, you no longer need to use it");
}

export { Account, AleoKeyProvider, AleoKeyProviderParams, AleoNetworkClient, BlockHeightSearch, CREDITS_PROGRAM_KEYS, KEY_STORE, NetworkRecordProvider, OfflineKeyProvider, OfflineSearchParams, PRIVATE_TO_PUBLIC_TRANSFER, PRIVATE_TRANSFER, PRIVATE_TRANSFER_TYPES, PUBLIC_TO_PRIVATE_TRANSFER, PUBLIC_TRANSFER, PUBLIC_TRANSFER_AS_SIGNER, ProgramManager, RECORD_DOMAIN, RecordScanner, SealanceMerkleTree, VALID_TRANSFER_TYPES, initializeWasm, logAndThrow };
//# sourceMappingURL=browser.js.map
