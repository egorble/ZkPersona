import { n as __toESM, t as __commonJS } from "./chunk-CVmoYqME.js";
import { t as require_react } from "./react-CPx1Bvoc.js";
import { t as require_jsx_runtime } from "./jsx-runtime-Cj3FU8Co.js";
import { t as require_eventemitter3 } from "./eventemitter3-DJwqmRen.js";
import { LeoWalletAdapter, LeoWalletName } from "@demox-labs/aleo-wallet-adapter-leo";

//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/adapter.js
var require_adapter = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/adapter.js": ((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.scopePollingDetectionStrategy = exports.BaseWalletAdapter = exports.WalletReadyState = exports.EventEmitter = void 0;
	var eventemitter3_1 = __importDefault(require_eventemitter3());
	exports.EventEmitter = eventemitter3_1.default;
	(function(WalletReadyState$3) {
		/**
		* User-installable wallets can typically be detected by scanning for an API
		* that they've injected into the global context. If such an API is present,
		* we consider the wallet to have been installed.
		*/
		WalletReadyState$3["Installed"] = "Installed";
		WalletReadyState$3["NotDetected"] = "NotDetected";
		/**
		* Loadable wallets are always available to you. Since you can load them at
		* any time, it's meaningless to say that they have been detected.
		*/
		WalletReadyState$3["Loadable"] = "Loadable";
		/**
		* If a wallet is not supported on a given platform (eg. server-rendering, or
		* mobile) then it will stay in the `Unsupported` state.
		*/
		WalletReadyState$3["Unsupported"] = "Unsupported";
	})(exports.WalletReadyState || (exports.WalletReadyState = {}));
	var BaseWalletAdapter = class extends eventemitter3_1.default {
		get connected() {
			return !!this.publicKey;
		}
	};
	exports.BaseWalletAdapter = BaseWalletAdapter;
	function scopePollingDetectionStrategy$3(detect) {
		if (typeof window === "undefined" || typeof document === "undefined") return;
		const disposers = [];
		function detectAndDispose() {
			if (detect()) for (const dispose of disposers) dispose();
		}
		const interval = setInterval(detectAndDispose, 1e3);
		disposers.push(() => clearInterval(interval));
		if (document.readyState === "loading") {
			document.addEventListener("DOMContentLoaded", detectAndDispose, { once: true });
			disposers.push(() => document.removeEventListener("DOMContentLoaded", detectAndDispose));
		}
		if (document.readyState !== "complete") {
			window.addEventListener("load", detectAndDispose, { once: true });
			disposers.push(() => window.removeEventListener("load", detectAndDispose));
		}
		detectAndDispose();
	}
	exports.scopePollingDetectionStrategy = scopePollingDetectionStrategy$3;
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/errors.js
var require_errors = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/errors.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.WalletTransactionError = exports.WalletRecordsError = exports.WalletDecryptionError = exports.WalletDecryptionNotAllowedError = exports.WalletWindowClosedError = exports.WalletWindowBlockedError = exports.WalletTimeoutError = exports.WalletSignTransactionError = exports.WalletSignMessageError = exports.WalletSendTransactionError = exports.WalletNotConnectedError = exports.WalletKeypairError = exports.WalletPublicKeyError = exports.WalletAccountError = exports.WalletDisconnectionError = exports.WalletDisconnectedError = exports.WalletNotSelectedError = exports.WalletConnectionError = exports.WalletConfigError = exports.WalletLoadError = exports.WalletNotReadyError = exports.WalletError = void 0;
	var WalletError = class extends Error {
		error;
		constructor(message, error) {
			super(message);
			this.error = error;
		}
	};
	exports.WalletError = WalletError;
	var WalletNotReadyError$3 = class extends WalletError {
		name = "WalletNotReadyError";
	};
	exports.WalletNotReadyError = WalletNotReadyError$3;
	var WalletLoadError = class extends WalletError {
		name = "WalletLoadError";
	};
	exports.WalletLoadError = WalletLoadError;
	var WalletConfigError = class extends WalletError {
		name = "WalletConfigError";
	};
	exports.WalletConfigError = WalletConfigError;
	var WalletConnectionError$3 = class extends WalletError {
		name = "WalletConnectionError";
	};
	exports.WalletConnectionError = WalletConnectionError$3;
	var WalletNotSelectedError = class extends WalletError {
		name = "WalletNotSelectedError";
	};
	exports.WalletNotSelectedError = WalletNotSelectedError;
	var WalletDisconnectedError = class extends WalletError {
		name = "WalletDisconnectedError";
	};
	exports.WalletDisconnectedError = WalletDisconnectedError;
	var WalletDisconnectionError$3 = class extends WalletError {
		name = "WalletDisconnectionError";
	};
	exports.WalletDisconnectionError = WalletDisconnectionError$3;
	var WalletAccountError = class extends WalletError {
		name = "WalletAccountError";
	};
	exports.WalletAccountError = WalletAccountError;
	var WalletPublicKeyError = class extends WalletError {
		name = "WalletPublicKeyError";
	};
	exports.WalletPublicKeyError = WalletPublicKeyError;
	var WalletKeypairError = class extends WalletError {
		name = "WalletKeypairError";
	};
	exports.WalletKeypairError = WalletKeypairError;
	var WalletNotConnectedError$3 = class extends WalletError {
		name = "WalletNotConnectedError";
	};
	exports.WalletNotConnectedError = WalletNotConnectedError$3;
	var WalletSendTransactionError = class extends WalletError {
		name = "WalletSendTransactionError";
	};
	exports.WalletSendTransactionError = WalletSendTransactionError;
	var WalletSignMessageError = class extends WalletError {
		name = "WalletSignMessageError";
	};
	exports.WalletSignMessageError = WalletSignMessageError;
	var WalletSignTransactionError$3 = class extends WalletError {
		name = "WalletSignTransactionError";
	};
	exports.WalletSignTransactionError = WalletSignTransactionError$3;
	var WalletTimeoutError = class extends WalletError {
		name = "WalletTimeoutError";
	};
	exports.WalletTimeoutError = WalletTimeoutError;
	var WalletWindowBlockedError = class extends WalletError {
		name = "WalletWindowBlockedError";
	};
	exports.WalletWindowBlockedError = WalletWindowBlockedError;
	var WalletWindowClosedError = class extends WalletError {
		name = "WalletWindowClosedError";
	};
	exports.WalletWindowClosedError = WalletWindowClosedError;
	var WalletDecryptionNotAllowedError$3 = class extends WalletError {
		name = "WalletDecryptionNotAllowedError";
	};
	exports.WalletDecryptionNotAllowedError = WalletDecryptionNotAllowedError$3;
	var WalletDecryptionError$3 = class extends WalletError {
		name = "WalletDecryptionError";
	};
	exports.WalletDecryptionError = WalletDecryptionError$3;
	var WalletRecordsError$3 = class extends WalletError {
		name = "WalletRecordsError";
	};
	exports.WalletRecordsError = WalletRecordsError$3;
	var WalletTransactionError$3 = class extends WalletError {
		name = "WalletTransactionError";
	};
	exports.WalletTransactionError = WalletTransactionError$3;
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/signer.js
var require_signer = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/signer.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseMessageSignerWalletAdapter = exports.BaseSignerWalletAdapter = void 0;
	var adapter_1 = require_adapter();
	var BaseSignerWalletAdapter = class extends adapter_1.BaseWalletAdapter {};
	exports.BaseSignerWalletAdapter = BaseSignerWalletAdapter;
	var BaseMessageSignerWalletAdapter$3 = class extends BaseSignerWalletAdapter {};
	exports.BaseMessageSignerWalletAdapter = BaseMessageSignerWalletAdapter$3;
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/types.js
var require_types = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/types.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DecryptPermission = exports.WalletAdapterNetwork = void 0;
	(function(WalletAdapterNetwork$1) {
		WalletAdapterNetwork$1["Testnet"] = "testnet3";
		WalletAdapterNetwork$1["TestnetBeta"] = "testnetbeta";
		WalletAdapterNetwork$1["MainnetBeta"] = "mainnetbeta";
	})(exports.WalletAdapterNetwork || (exports.WalletAdapterNetwork = {}));
	(function(DecryptPermission$3) {
		DecryptPermission$3["NoDecrypt"] = "NO_DECRYPT";
		DecryptPermission$3["UponRequest"] = "DECRYPT_UPON_REQUEST";
		DecryptPermission$3["AutoDecrypt"] = "AUTO_DECRYPT";
		DecryptPermission$3["OnChainHistory"] = "ON_CHAIN_HISTORY";
	})(exports.DecryptPermission || (exports.DecryptPermission = {}));
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/transaction.js
var require_transaction = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/transaction.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Transaction = exports.Transition = void 0;
	var Transition = class {
		program;
		functionName;
		inputs;
		constructor(program, functionName, inputs) {
			this.program = program;
			this.functionName = functionName;
			this.inputs = inputs;
		}
	};
	exports.Transition = Transition;
	var Transaction = class Transaction {
		address;
		chainId;
		transitions;
		fee;
		feePrivate;
		constructor(address, chainId, transitions, fee, feePrivate = true) {
			this.address = address;
			this.chainId = chainId;
			this.transitions = transitions;
			this.fee = fee;
			this.feePrivate = feePrivate;
		}
		static createTransaction(address, chainId, program, functionName, inputs, fee, feePrivate = true) {
			return new Transaction(address, chainId, [new Transition(program, functionName, inputs)], fee, feePrivate);
		}
	};
	exports.Transaction = Transaction;
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/deployment.js
var require_deployment = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/deployment.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Deployment = void 0;
	var Deployment = class {
		address;
		chainId;
		program;
		fee;
		feePrivate;
		constructor(address, chainId, program, fee, feePrivate = true) {
			this.address = address;
			this.chainId = chainId;
			this.program = program;
			this.fee = fee;
			this.feePrivate = feePrivate;
		}
	};
	exports.Deployment = Deployment;
}) });

//#endregion
//#region node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/index.js
var require_dist = /* @__PURE__ */ __commonJS({ "node_modules/aleo-adapters/node_modules/@demox-labs/aleo-wallet-adapter-base/dist/index.js": ((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	}) : (function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	}));
	var __exportStar = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p in m$1) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m$1, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(require_adapter(), exports);
	__exportStar(require_errors(), exports);
	__exportStar(require_signer(), exports);
	__exportStar(require_types(), exports);
	__exportStar(require_transaction(), exports);
	__exportStar(require_deployment(), exports);
}) });

//#endregion
//#region node_modules/aleo-adapters/dist/fox.js
var import_dist$2 = require_dist();
const FoxWalletName = "Fox Wallet";
var FoxWalletAdapter = class extends import_dist$2.BaseMessageSignerWalletAdapter {
	name = FoxWalletName;
	url = "https://foxwallet.com/download";
	icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAwIiBoZWlnaHQ9IjkwMCIgdmlld0JveD0iMCAwIDkwMCA5MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI5MDAiIGhlaWdodD0iOTAwIiByeD0iNDUwIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTU3Ny4yNDkgMjE1Ljk3NUM1MzkuOTU2IDE5Ni4yMzIgNTExLjY0NiAxNjEuNTQ5IDUwMC40NjggMTE5Ljg2OEM0OTcuMDIxIDEzMi42MTMgNDk1LjI0NSAxNDUuOTg0IDQ5NS4yNDUgMTU5Ljc3NEM0OTUuMjQ1IDE3MC41MzMgNDk2LjM5NCAxODAuOTggNDk4LjQ4MyAxOTEuMTEzQzQ5OC40ODMgMTkxLjExMyA0OTguNDgzIDE5MS4xMTMgNDk4LjQ4MyAxOTEuMjE3QzQ5OC40ODMgMTkxLjMyMiA0OTguNTg4IDE5MS41MzEgNDk4LjU4OCAxOTEuNjM1QzUwMS40MDggMjA1LjIxNiA1MDYuMDA1IDIxOC4wNjUgNTEyLjE2OCAyMjkuOTc0QzQ5OS4wMDYgMjIwLjI1OCA0ODcuMzA2IDIwOC42NjMgNDc3LjQ4NiAxOTUuNjA1QzQ2NC4zMjMgMjk3LjY2NyA1MDEuNDA4IDQwMy45MDcgNTY5LjIwNiA0NzMuODk4QzY1Ny42ODcgNTc2LjkgNTc2LjEgNzUxLjY2OSA0MzguMjA3IDc0Ny4wNzNDMjQzLjA2OCA3NDguNzQ0IDIwOS42MzkgNDYxLjM2MiAzOTYuODM5IDQxNi4yMzRMMzk2LjczNSA0MTUuNzExQzQ0Ni42NjkgMzk5LjUxOSA0NzAuMDY5IDM2Ny4wMzEgNDc0LjE0MyAzMjQuODI3QzQwMi4wNjMgMzgzLjIyMyAyODguMTk2IDMxMC44MjkgMzExLjgwNSAyMjAuMTU0QzQxLjI0MjUgMzUzLjM0NiAxNDEuNzM3IDc4NS40MTEgNDQ4LjQ0NSA3ODAuMDgzQzU4Mi4wNTUgNzgwLjA4MyA2OTUuMDg1IDY5MS43MDYgNzMyLjE3IDU3MC4yMTRDNzc2LjQ2MyA0MjguNTYxIDcwNC44IDI3Ny42MDkgNTc3LjI0OSAyMTUuOTc1WiIgZmlsbD0iIzEyRkU3NCIvPgo8L3N2Zz4K";
	supportedTransactionVersions = null;
	_connecting;
	_wallet;
	_publicKey;
	_decryptPermission;
	_readyState = typeof window === "undefined" || typeof document === "undefined" ? import_dist$2.WalletReadyState.Unsupported : import_dist$2.WalletReadyState.NotDetected;
	constructor({} = {}) {
		super();
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		this._decryptPermission = import_dist$2.DecryptPermission.NoDecrypt;
		if (this._readyState !== import_dist$2.WalletReadyState.Unsupported) (0, import_dist$2.scopePollingDetectionStrategy)(() => {
			if (window?.foxwallet && window.foxwallet?.aleo) {
				this._readyState = import_dist$2.WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get decryptPermission() {
		return this._decryptPermission;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	set readyState(readyState) {
		this._readyState = readyState;
	}
	async decrypt(cipherText, tpk, programId, functionName, index) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			switch (this._decryptPermission) {
				case import_dist$2.DecryptPermission.NoDecrypt: throw new import_dist$2.WalletDecryptionNotAllowedError();
				case import_dist$2.DecryptPermission.UponRequest:
				case import_dist$2.DecryptPermission.AutoDecrypt:
				case import_dist$2.DecryptPermission.OnChainHistory: try {
					return (await wallet.decrypt(cipherText, tpk, programId, functionName, index)).text;
				} catch (error) {
					throw new import_dist$2.WalletDecryptionError(error?.message, error);
				}
				default: throw new import_dist$2.WalletDecryptionError();
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecords(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestRecords(program)).records;
			} catch (error) {
				throw new import_dist$2.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestTransaction(transaction)).transactionId || "";
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestExecution(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestExecution(transaction)).transactionId || "";
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestBulkTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestBulkTransactions(transactions)).transactionIds || [""];
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestDeploy(deployment) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestDeploy(deployment)).transactionId || "";
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async transactionStatus(transactionId) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.transactionStatus(transactionId)).status;
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async getExecution(transactionId) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.getExecution(transactionId)).execution;
			} catch (error) {
				throw new import_dist$2.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecordPlaintexts(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestRecordPlaintexts(program)).records;
			} catch (error) {
				throw new import_dist$2.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestTransactionHistory(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.requestTransactionHistory(program)).transactions;
			} catch (error) {
				throw new import_dist$2.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async connect(decryptPermission, network, programs) {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== import_dist$2.WalletReadyState.Installed) throw new import_dist$2.WalletNotReadyError();
			this._connecting = true;
			const wallet = window.foxwallet && window.foxwallet.aleo;
			try {
				if (wallet) await wallet.connect(decryptPermission, network, programs);
				if (!wallet?.publicKey) throw new import_dist$2.WalletConnectionError();
				this._publicKey = wallet.publicKey;
			} catch (error) {
				throw new import_dist$2.WalletConnectionError(error?.message, error);
			}
			this._wallet = wallet;
			this._decryptPermission = decryptPermission;
			this.emit("connect", this._publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new import_dist$2.WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist$2.WalletNotConnectedError();
			try {
				return (await wallet.signMessage(message)).signature;
			} catch (error) {
				throw new import_dist$2.WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/utils/clientInfo.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
const hasInjectedConnection = () => {
	if (typeof window === "undefined") return false;
	return !!window?.aleo?.puzzleWalletClient;
};
const waitForInjectedConnection = async () => {
	const startTime = Date.now();
	while (!hasInjectedConnection()) {
		if (Date.now() - startTime > 5e3) throw new Error("Puzzle wallet not detected within 5 seconds");
		console.log("Puzzle wallet not detected! Waiting for 0.25 seconds");
		await new Promise((resolve) => setTimeout(resolve, 250));
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/data/errors.js
var SdkError;
(function(SdkError$1) {
	SdkError$1["PuzzleWalletNotDetected"] = "Puzzle Wallet not detected!";
	SdkError$1["NotConnected"] = "dApp not connected to Puzzle Wallet. Call connect first!";
})(SdkError = SdkError || (SdkError = {}));

//#endregion
//#region node_modules/events/events.js
var require_events = /* @__PURE__ */ __commonJS({ "node_modules/events/events.js": ((exports, module) => {
	var R = typeof Reflect === "object" ? Reflect : null;
	var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply$1(target, receiver, args) {
		return Function.prototype.apply.call(target, receiver, args);
	};
	var ReflectOwnKeys;
	if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
	else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
	};
	else ReflectOwnKeys = function ReflectOwnKeys$1(target) {
		return Object.getOwnPropertyNames(target);
	};
	function ProcessEmitWarning(warning) {
		if (console && console.warn) console.warn(warning);
	}
	var NumberIsNaN = Number.isNaN || function NumberIsNaN$1(value) {
		return value !== value;
	};
	function EventEmitter$1() {
		EventEmitter$1.init.call(this);
	}
	module.exports = EventEmitter$1;
	module.exports.once = once;
	EventEmitter$1.EventEmitter = EventEmitter$1;
	EventEmitter$1.prototype._events = void 0;
	EventEmitter$1.prototype._eventsCount = 0;
	EventEmitter$1.prototype._maxListeners = void 0;
	var defaultMaxListeners = 10;
	function checkListener(listener) {
		if (typeof listener !== "function") throw new TypeError("The \"listener\" argument must be of type Function. Received type " + typeof listener);
	}
	Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
		enumerable: true,
		get: function() {
			return defaultMaxListeners;
		},
		set: function(arg) {
			if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError("The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received " + arg + ".");
			defaultMaxListeners = arg;
		}
	});
	EventEmitter$1.init = function() {
		if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
			this._events = Object.create(null);
			this._eventsCount = 0;
		}
		this._maxListeners = this._maxListeners || void 0;
	};
	EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n$1) {
		if (typeof n$1 !== "number" || n$1 < 0 || NumberIsNaN(n$1)) throw new RangeError("The value of \"n\" is out of range. It must be a non-negative number. Received " + n$1 + ".");
		this._maxListeners = n$1;
		return this;
	};
	function _getMaxListeners(that) {
		if (that._maxListeners === void 0) return EventEmitter$1.defaultMaxListeners;
		return that._maxListeners;
	}
	EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
		return _getMaxListeners(this);
	};
	EventEmitter$1.prototype.emit = function emit(type) {
		var args = [];
		for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
		var doError = type === "error";
		var events = this._events;
		if (events !== void 0) doError = doError && events.error === void 0;
		else if (!doError) return false;
		if (doError) {
			var er;
			if (args.length > 0) er = args[0];
			if (er instanceof Error) throw er;
			var err = /* @__PURE__ */ new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
			err.context = er;
			throw err;
		}
		var handler = events[type];
		if (handler === void 0) return false;
		if (typeof handler === "function") ReflectApply(handler, this, args);
		else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
		}
		return true;
	};
	function _addListener(target, type, listener, prepend) {
		var m$1;
		var events;
		var existing;
		checkListener(listener);
		events = target._events;
		if (events === void 0) {
			events = target._events = Object.create(null);
			target._eventsCount = 0;
		} else {
			if (events.newListener !== void 0) {
				target.emit("newListener", type, listener.listener ? listener.listener : listener);
				events = target._events;
			}
			existing = events[type];
		}
		if (existing === void 0) {
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === "function") existing = events[type] = prepend ? [listener, existing] : [existing, listener];
			else if (prepend) existing.unshift(listener);
			else existing.push(listener);
			m$1 = _getMaxListeners(target);
			if (m$1 > 0 && existing.length > m$1 && !existing.warned) {
				existing.warned = true;
				var w$1 = /* @__PURE__ */ new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
				w$1.name = "MaxListenersExceededWarning";
				w$1.emitter = target;
				w$1.type = type;
				w$1.count = existing.length;
				ProcessEmitWarning(w$1);
			}
		}
		return target;
	}
	EventEmitter$1.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
	EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
		return _addListener(this, type, listener, true);
	};
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			if (arguments.length === 0) return this.listener.call(this.target);
			return this.listener.apply(this.target, arguments);
		}
	}
	function _onceWrap(target, type, listener) {
		var state = {
			fired: false,
			wrapFn: void 0,
			target,
			type,
			listener
		};
		var wrapped = onceWrapper.bind(state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	EventEmitter$1.prototype.once = function once$1(type, listener) {
		checkListener(listener);
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
		checkListener(listener);
		this.prependListener(type, _onceWrap(this, type, listener));
		return this;
	};
	EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
		var list, events, position, i, originalListener;
		checkListener(listener);
		events = this._events;
		if (events === void 0) return this;
		list = events[type];
		if (list === void 0) return this;
		if (list === listener || list.listener === listener) if (--this._eventsCount === 0) this._events = Object.create(null);
		else {
			delete events[type];
			if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
		}
		else if (typeof list !== "function") {
			position = -1;
			for (i = list.length - 1; i >= 0; i--) if (list[i] === listener || list[i].listener === listener) {
				originalListener = list[i].listener;
				position = i;
				break;
			}
			if (position < 0) return this;
			if (position === 0) list.shift();
			else spliceOne(list, position);
			if (list.length === 1) events[type] = list[0];
			if (events.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
		}
		return this;
	};
	EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
	EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
		var listeners, events = this._events, i;
		if (events === void 0) return this;
		if (events.removeListener === void 0) {
			if (arguments.length === 0) {
				this._events = Object.create(null);
				this._eventsCount = 0;
			} else if (events[type] !== void 0) if (--this._eventsCount === 0) this._events = Object.create(null);
			else delete events[type];
			return this;
		}
		if (arguments.length === 0) {
			var keys = Object.keys(events);
			var key;
			for (i = 0; i < keys.length; ++i) {
				key = keys[i];
				if (key === "removeListener") continue;
				this.removeAllListeners(key);
			}
			this.removeAllListeners("removeListener");
			this._events = Object.create(null);
			this._eventsCount = 0;
			return this;
		}
		listeners = events[type];
		if (typeof listeners === "function") this.removeListener(type, listeners);
		else if (listeners !== void 0) for (i = listeners.length - 1; i >= 0; i--) this.removeListener(type, listeners[i]);
		return this;
	};
	function _listeners(target, type, unwrap) {
		var events = target._events;
		if (events === void 0) return [];
		var evlistener = events[type];
		if (evlistener === void 0) return [];
		if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
		return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}
	EventEmitter$1.prototype.listeners = function listeners(type) {
		return _listeners(this, type, true);
	};
	EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
		return _listeners(this, type, false);
	};
	EventEmitter$1.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
		else return listenerCount.call(emitter, type);
	};
	EventEmitter$1.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
		if (events !== void 0) {
			var evlistener = events[type];
			if (typeof evlistener === "function") return 1;
			else if (evlistener !== void 0) return evlistener.length;
		}
		return 0;
	}
	EventEmitter$1.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};
	function arrayClone(arr, n$1) {
		var copy = new Array(n$1);
		for (var i = 0; i < n$1; ++i) copy[i] = arr[i];
		return copy;
	}
	function spliceOne(list, index) {
		for (; index + 1 < list.length; index++) list[index] = list[index + 1];
		list.pop();
	}
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
		return ret;
	}
	function once(emitter, name) {
		return new Promise(function(resolve, reject) {
			function errorListener(err) {
				emitter.removeListener(name, resolver);
				reject(err);
			}
			function resolver() {
				if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
				resolve([].slice.call(arguments));
			}
			eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
			if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
		});
	}
	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
	}
	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		if (typeof emitter.on === "function") if (flags.once) emitter.once(name, listener);
		else emitter.on(name, listener);
		else if (typeof emitter.addEventListener === "function") emitter.addEventListener(name, function wrapListener(arg) {
			if (flags.once) emitter.removeEventListener(name, wrapListener);
			listener(arg);
		});
		else throw new TypeError("The \"emitter\" argument must be of type EventEmitter. Received type " + typeof emitter);
	}
}) });

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/utils/eventEmitter.js
var import_events = /* @__PURE__ */ __toESM(require_events(), 1);
const PuzzleWalletSDKEventEmitter = new import_events.default();

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/connect.js
const connect = async (request) => {
	await waitForInjectedConnection();
	if (!window.aleo.puzzleWalletClient.connect?.mutate) throw new Error("connect.mutate not found!");
	try {
		const connectRequest = {
			method: "connect",
			params: request
		};
		const connectResponse = await window.aleo.puzzleWalletClient.connect.mutate(connectRequest);
		PuzzleWalletSDKEventEmitter.emit("connectSuccess", connectResponse);
		return connectResponse;
	} catch (e$1) {
		console.error("connect error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/requestCreateEvent.js
const requestCreateEvent = async (requestData) => {
	if (!hasInjectedConnection()) throw new Error(`requestCreateEvent ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.requestCreateEvent?.mutate) throw new Error("requestCreateEvent.mutate not found!");
	const inputs = requestData?.inputs.map((input) => {
		if (typeof input === "string") return input;
		return input.plaintext;
	});
	const req = {
		method: "requestCreateEvent",
		params: {
			...requestData,
			inputs
		}
	};
	try {
		return await window.aleo.puzzleWalletClient.requestCreateEvent.mutate(req);
	} catch (e$1) {
		console.error("createEvent error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/decrypt.js
const decrypt = async ({ ciphertexts, network, address }) => {
	if (!hasInjectedConnection()) throw new Error(`decrypt ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.decrypt?.query) throw new Error("decrypt.query not found!");
	const query = {
		method: "decrypt",
		params: {
			ciphertexts,
			address,
			network
		}
	};
	try {
		return await window.aleo.puzzleWalletClient.decrypt.query(query);
	} catch (e$1) {
		e$1.message;
		console.error("decrypt error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/disconnect.js
const disconnect = async () => {
	if (!hasInjectedConnection()) throw new Error(`disconnect ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.disconnect?.mutate) throw new Error("disconnect.mutate not found!");
	const req = { method: "disconnect" };
	try {
		await window.aleo.puzzleWalletClient.disconnect.mutate(req);
		PuzzleWalletSDKEventEmitter.emit("disconnectSuccess", "disconnected");
	} catch (e$1) {
		console.error("error disconnecting", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/event.js
const getEvent = async ({ id, address, network }) => {
	if (!hasInjectedConnection()) throw new Error(`getEvent ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.getEvent?.query) throw new Error("getEvent.query not found!");
	const query = {
		method: "getEvent",
		params: {
			id,
			address,
			network
		}
	};
	try {
		return await window.aleo.puzzleWalletClient.getEvent.query(query);
	} catch (e$1) {
		console.error("getEvent error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/records.js
const getRecords = async ({ filter, page = 0, address, network }) => {
	if (!hasInjectedConnection()) throw new Error(`getRecords ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.getRecords?.query) throw new Error("getRecords.query not found!");
	const query = {
		method: "getRecords",
		params: {
			filter,
			page,
			address,
			network
		}
	};
	try {
		return await window.aleo.puzzleWalletClient.getRecords.query(query);
	} catch (e$1) {
		console.error("getRecords error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/messages/requestSignature.js
const requestSignature = async ({ message, address, network }) => {
	if (!hasInjectedConnection()) throw new Error(`requestSignature ${SdkError.PuzzleWalletNotDetected}`);
	if (!window.aleo.puzzleWalletClient.requestSignature?.mutate) throw new Error("requestSignature.mutate not found!");
	const req = {
		method: "requestSignature",
		params: {
			message,
			address,
			network
		}
	};
	try {
		return await window.aleo.puzzleWalletClient.requestSignature.mutate(req);
	} catch (e$1) {
		console.error("signature error", e$1);
		throw e$1;
	}
};

//#endregion
//#region node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJS({ "node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n$1 = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n$1 * y;
			case "weeks":
			case "week":
			case "w": return n$1 * w;
			case "days":
			case "day":
			case "d": return n$1 * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n$1 * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n$1 * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n$1 * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n$1;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n$1, name) {
		var isPlural = msAbs >= n$1 * 1.5;
		return Math.round(ms / n$1) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region node_modules/debug/src/common.js
var require_common = /* @__PURE__ */ __commonJS({ "node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce$1;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$1(...args) {
				if (!debug$1.enabled) return;
				const self = debug$1;
				const curr = Number(/* @__PURE__ */ new Date());
				self.diff = curr - (prevTime || curr);
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self, args);
				(self.log || createDebug.log).apply(self, args);
			}
			debug$1.namespace = namespace;
			debug$1.useColors = createDebug.useColors();
			debug$1.color = createDebug.selectColor(namespace);
			debug$1.extend = extend;
			debug$1.destroy = createDebug.destroy;
			Object.defineProperty(debug$1, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$1);
			return debug$1;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce$1(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}) });

//#endregion
//#region node_modules/debug/src/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/debug/src/browser.js": ((exports, module) => {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$1;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		let r$1;
		try {
			r$1 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r$1 && typeof process !== "undefined" && "env" in process) r$1 = process.env.DEBUG;
		return r$1;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	var { formatters } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}) });

//#endregion
//#region node_modules/@puzzlehq/sdk-core/dist/src/utils/logger.js
var import_browser = /* @__PURE__ */ __toESM(require_browser(), 1);
const log_sdk = (0, import_browser.default)("wallet:sdk");
log_sdk.enabled = true;

//#endregion
//#region node_modules/zod/lib/index.mjs
var util;
(function(util$1) {
	util$1.assertEqual = (val) => val;
	function assertIs(_arg) {}
	util$1.assertIs = assertIs;
	function assertNever(_x) {
		throw new Error();
	}
	util$1.assertNever = assertNever;
	util$1.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) obj[item] = item;
		return obj;
	};
	util$1.getValidEnumValues = (obj) => {
		const validKeys = util$1.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		const filtered = {};
		for (const k of validKeys) filtered[k] = obj[k];
		return util$1.objectValues(filtered);
	};
	util$1.objectValues = (obj) => {
		return util$1.objectKeys(obj).map(function(e$1) {
			return obj[e$1];
		});
	};
	util$1.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
		const keys = [];
		for (const key in object) if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
		return keys;
	};
	util$1.find = (arr, checker) => {
		for (const item of arr) if (checker(item)) return item;
	};
	util$1.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$1.joinValues = joinValues;
	util$1.jsonStringifyReplacer = (_, value) => {
		if (typeof value === "bigint") return value.toString();
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first, second) => {
		return {
			...first,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
var getParsedType = (data) => {
	switch (typeof data) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data)) return ZodParsedType.array;
			if (data === null) return ZodParsedType.null;
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
			if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
			if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
			if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};
var ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
var quotelessJson = (obj) => {
	return JSON.stringify(obj, null, 2).replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		this.name = "ZodError";
		this.issues = issues;
	}
	get errors() {
		return this.issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue) {
			return issue.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error) => {
			for (const issue of error.issues) if (issue.code === "invalid_union") issue.unionErrors.map(processError);
			else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
			else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
			else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
			else {
				let curr = fieldErrors;
				let i = 0;
				while (i < issue.path.length) {
					const el = issue.path[i];
					if (!(i === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue));
					}
					curr = curr[el];
					i++;
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) if (sub.path.length > 0) {
			fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
			fieldErrors[sub.path[0]].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	return new ZodError(issues);
};
var errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) message = "Required";
			else message = `Expected ${issue.expected}, received ${issue.received}`;
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") if ("includes" in issue.validation) {
				message = `Invalid input: must include "${issue.validation.includes}"`;
				if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
			} else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
			else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
			else util.assertNever(issue.validation);
			else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
			else message = "Invalid";
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue);
	}
	return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
	overrideErrorMap = map;
}
function getErrorMap() {
	return overrideErrorMap;
}
var makeIssue = (params) => {
	const { data, path, errorMaps, issueData } = params;
	const fullPath = [...path, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	let errorMessage = "";
	const maps = errorMaps.filter((m$1) => !!m$1).slice().reverse();
	for (const map of maps) errorMessage = map(fullIssue, {
		data,
		defaultError: errorMessage
	}).message;
	return {
		...issueData,
		path: fullPath,
		message: issueData.message || errorMessage
	};
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			getErrorMap(),
			errorMap
		].filter((x) => !!x)
	});
	ctx.common.issues.push(issue);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status, results) {
		const arrayValue = [];
		for (const s$1 of results) {
			if (s$1.status === "aborted") return INVALID;
			if (s$1.status === "dirty") status.dirty();
			arrayValue.push(s$1.value);
		}
		return {
			status: status.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status, pairs) {
		const syncPairs = [];
		for (const pair of pairs) syncPairs.push({
			key: await pair.key,
			value: await pair.value
		});
		return ParseStatus.mergeObjectSync(status, syncPairs);
	}
	static mergeObjectSync(status, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status.dirty();
			if (value.status === "dirty") status.dirty();
			if (typeof value.value !== "undefined" || pair.alwaysSet) finalObject[key.value] = value.value;
		}
		return {
			status: status.value,
			value: finalObject
		};
	}
};
var INVALID = Object.freeze({ status: "aborted" });
var DIRTY = (value) => ({
	status: "dirty",
	value
});
var OK = (value) => ({
	status: "valid",
	value
});
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
	constructor(parent, value, path, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) if (this._key instanceof Array) this._cachedPath.push(...this._path, ...this._key);
		else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
};
var handleResult = (ctx, result) => {
	if (isValid(result)) return {
		success: true,
		data: result.value
	};
	else {
		if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				this._error = new ZodError(ctx.common.issues);
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		if (typeof ctx.data === "undefined") return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
		return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	constructor(def) {
		/** Alias of safeParseAsync */
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
	}
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		const result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		var _a;
		const ctx = {
			common: {
				issues: [],
				async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
				contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
			},
			path: (params === null || params === void 0 ? void 0 : params.path) || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		return handleResult(ctx, this._parseSync({
			data,
			path: ctx.path,
			parent: ctx
		}));
	}
	async parseAsync(data, params) {
		const result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
				async: true
			},
			path: (params === null || params === void 0 ? void 0 : params.path) || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const maybeAsyncResult = this._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult)));
	}
	refine(check, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			const result = check(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data) => {
				if (!data) {
					setError();
					return false;
				} else return true;
			});
			if (!result) {
				setError();
				return false;
			} else return true;
		});
	}
	refinement(check, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else return true;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this, this._def);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
	if (args.precision) if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
	else if (args.precision === 0) if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
	else if (args.offset) return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	else return /* @__PURE__ */ new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
};
function isValidIP(ip, version$1) {
	if ((version$1 === "v4" || !version$1) && ipv4Regex.test(ip)) return true;
	if ((version$1 === "v6" || !version$1) && ipv6Regex.test(ip)) return true;
	return false;
}
var ZodString = class ZodString extends ZodType {
	constructor() {
		super(...arguments);
		this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
		/**
		* @deprecated Use z.string().min(1) instead.
		* @see {@link ZodString.min}
		*/
		this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
		this.trim = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
		this.toLowerCase = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
		this.toUpperCase = () => new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.length < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.length > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "length") {
			const tooBig = input.data.length > check.value;
			const tooSmall = input.data.length < check.value;
			if (tooBig || tooSmall) {
				ctx = this._getOrReturnCtx(input, ctx);
				if (tooBig) addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				else if (tooSmall) addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "email") {
			if (!emailRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "email",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "emoji") {
			if (!emojiRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "emoji",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "uuid") {
			if (!uuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "uuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid") {
			if (!cuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "cuid2") {
			if (!cuid2Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid2",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ulid") {
			if (!ulidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ulid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "url") try {
			new URL(input.data);
		} catch (_a) {
			ctx = this._getOrReturnCtx(input, ctx);
			addIssueToContext(ctx, {
				validation: "url",
				code: ZodIssueCode.invalid_string,
				message: check.message
			});
			status.dirty();
		}
		else if (check.kind === "regex") {
			check.regex.lastIndex = 0;
			if (!check.regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "regex",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "trim") input.data = input.data.trim();
		else if (check.kind === "includes") {
			if (!input.data.includes(check.value, check.position)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: {
						includes: check.value,
						position: check.position
					},
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
		else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
		else if (check.kind === "startsWith") {
			if (!input.data.startsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { startsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "endsWith") {
			if (!input.data.endsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { endsWith: check.value },
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "datetime") {
			if (!datetimeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "datetime",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "ip") {
			if (!isValidIP(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ip",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	_addCheck(check) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		var _a;
		if (typeof options === "string") return this._addCheck({
			kind: "datetime",
			precision: null,
			offset: false,
			message: options
		});
		return this._addCheck({
			kind: "datetime",
			precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
			offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
			...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
		});
	}
	regex(regex, message) {
		return this._addCheck({
			kind: "regex",
			regex,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options === null || options === void 0 ? void 0 : options.position,
			...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message)
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message)
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodString.create = (params) => {
	var _a;
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	return parseInt(val.toFixed(decCount).replace(".", "")) % parseInt(step.toFixed(decCount).replace(".", "")) / Math.pow(10, decCount);
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "int") {
			if (!util.isInteger(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: "integer",
					received: "float",
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (floatSafeRemainder(input.data, check.value) !== 0) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "finite") {
			if (!Number.isFinite(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_finite,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
	}
	get isFinite() {
		let max = null, min = null;
		for (const ch of this._def.checks) if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
		else if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		} else if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) input.data = BigInt(input.data);
		if (this._getType(input) !== ZodParsedType.bigint) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.bigint,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					type: "bigint",
					minimum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					type: "bigint",
					maximum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (input.data % check.value !== BigInt(0)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodBigInt.create = (params) => {
	var _a;
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (isNaN(input.data.getTime())) {
			addIssueToContext(this._getOrReturnCtx(input), { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.getTime() < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					message: check.message,
					inclusive: true,
					exact: false,
					minimum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.getTime() > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					message: check.message,
					inclusive: true,
					exact: false,
					maximum: check.value,
					type: "date"
				});
				status.dirty();
			}
		} else util.assertNever(check);
		return {
			status: status.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max != null ? new Date(max) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status.dirty();
			}
		}
		if (ctx.common.async) return Promise.all([...ctx.data].map((item, i) => {
			return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
		})).then((result$1) => {
			return ParseStatus.mergeArray(status, result$1);
		});
		const result = [...ctx.data].map((item, i) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
		});
		return ParseStatus.mergeArray(status, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) return new ZodArray({
		...schema._def,
		type: deepPartialify(schema.element)
	});
	else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		/**
		* @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
		* If you want to pass through unknown properties, use `.passthrough()` instead.
		*/
		this.nonstrict = this.passthrough;
		/**
		* @deprecated Use `.extend` instead
		*  */
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		return this._cached = {
			shape,
			keys: util.objectKeys(shape)
		};
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) if (!shapeKeys.includes(key)) extraKeys.push(key);
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") for (const key of extraKeys) pairs.push({
				key: {
					status: "valid",
					value: key
				},
				value: {
					status: "valid",
					value: ctx.data[key]
				}
			});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status.dirty();
				}
			} else if (unknownKeys === "strip");
			else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
		} else {
			const catchall = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: {
						status: "valid",
						value: key
					},
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data
				});
			}
		}
		if (ctx.common.async) return Promise.resolve().then(async () => {
			const syncPairs = [];
			for (const pair of pairs) {
				const key = await pair.key;
				syncPairs.push({
					key,
					value: await pair.value,
					alwaysSet: pair.alwaysSet
				});
			}
			return syncPairs;
		}).then((syncPairs) => {
			return ParseStatus.mergeObjectSync(status, syncPairs);
		});
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== void 0 ? { errorMap: (issue, ctx) => {
				var _a, _b, _c, _d;
				const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
				if (issue.code === "unrecognized_keys") return { message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	/**
	* Prior to zod@1.0.12 there was a bug in the
	* inferred type of merged objects. Please
	* upgrade if you are experiencing issues.
	*/
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		util.objectKeys(mask).forEach((key) => {
			if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
		});
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		util.objectKeys(this.shape).forEach((key) => {
			if (!mask[key]) shape[key] = this.shape[key];
		});
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	/**
	* @deprecated
	*/
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		util.objectKeys(this.shape).forEach((key) => {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) newShape[key] = fieldSchema;
			else newShape[key] = fieldSchema.optional();
		});
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		util.objectKeys(this.shape).forEach((key) => {
			if (mask && !mask[key]) newShape[key] = this.shape[key];
			else {
				let newField = this.shape[key];
				while (newField instanceof ZodOptional) newField = newField._def.innerType;
				newShape[key] = newField;
			}
		});
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) if (result.result.status === "valid") return result.result;
			for (const result of results) if (result.result.status === "dirty") {
				ctx.common.issues.push(...result.ctx.common.issues);
				return result.result;
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) return Promise.all(options.map(async (option) => {
			const childCtx = {
				...ctx,
				common: {
					...ctx.common,
					issues: []
				},
				parent: null
			};
			return {
				result: await option._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				}),
				ctx: childCtx
			};
		})).then(handleResults);
		else {
			let dirty = void 0;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty) dirty = {
					result,
					ctx: childCtx
				};
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types, params) => {
	return new ZodUnion({
		options: types,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
var getDiscriminator = (type) => {
	if (type instanceof ZodLazy) return getDiscriminator(type.schema);
	else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
	else if (type instanceof ZodLiteral) return [type.value];
	else if (type instanceof ZodEnum) return type.options;
	else if (type instanceof ZodNativeEnum) return Object.keys(type.enum);
	else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
	else if (type instanceof ZodUndefined) return [void 0];
	else if (type instanceof ZodNull) return [null];
	else return null;
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) return option._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
		else return option._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	/**
	* The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	* However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	* have a different value for each object in the union.
	* @param discriminator the name of the discriminator property
	* @param types an array of object schemas
	* @param params
	*/
	static create(discriminator, options, params) {
		const optionsMap = /* @__PURE__ */ new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a, b) {
	const aType = getParsedType(a);
	const bType = getParsedType(b);
	if (a === b) return {
		valid: true,
		data: a
	};
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b);
		const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a[key], b[key]);
			if (!sharedValue.valid) return { valid: false };
			newObj[key] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) return { valid: false };
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: false };
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
		valid: true,
		data: a
	};
	else return { valid: false };
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) status.dirty();
			return {
				status: status.value,
				value: merged.data
			};
		};
		if (ctx.common.async) return Promise.all([this._def.left._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		})]).then(([left, right]) => handleParsed(left, right));
		else return handleParsed(this._def.left._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}));
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		if (!this._def.rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x) => !!x);
		if (ctx.common.async) return Promise.all(items).then((results) => {
			return ParseStatus.mergeArray(status, results);
		});
		else return ParseStatus.mergeArray(status, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) pairs.push({
			key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
			value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
		});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status, pairs);
		else return ParseStatus.mergeObjectSync(status, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) return new ZodRecord({
			keyType: first,
			valueType: second,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(third)
		});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = /* @__PURE__ */ new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") return INVALID;
					if (key.status === "dirty" || value.status === "dirty") status.dirty();
					finalMap.set(key.value, value.value);
				}
				return {
					status: status.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = /* @__PURE__ */ new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") return INVALID;
				if (key.status === "dirty" || value.status === "dirty") status.dirty();
				finalMap.set(key.value, value.value);
			}
			return {
				status: status.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = /* @__PURE__ */ new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
		if (ctx.common.async) return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error
				}
			});
		}
		function makeReturnsIssue(returns, error) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					errorMap
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) return OK(async (...args) => {
			const error = new ZodError([]);
			const result = await fn(...await this._def.args.parseAsync(args, params).catch((e$1) => {
				error.addIssue(makeArgsIssue(args, e$1));
				throw error;
			}));
			return await this._def.returns._def.type.parseAsync(result, params).catch((e$1) => {
				error.addIssue(makeReturnsIssue(result, e$1));
				throw error;
			});
		});
		else return OK((...args) => {
			const parsedArgs = this._def.args.safeParse(args, params);
			if (!parsedArgs.success) throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
			const result = fn(...parsedArgs.data);
			const parsedReturns = this._def.returns.safeParse(result, params);
			if (!parsedReturns.success) throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
			return parsedReturns.data;
		});
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		return this._def.getter()._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (this._def.values.indexOf(input.data) === -1) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values) {
		return ZodEnum.create(values);
	}
	exclude(values) {
		return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (nativeEnumValues.indexOf(input.data) === -1) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK((ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data)).then((data) => {
			return this._def.type.parseAsync(data, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data);
			if (ctx.common.async) return Promise.resolve(processed).then((processed$1) => {
				return this._def.schema._parseAsync({
					data: processed$1,
					path: ctx.path,
					parent: ctx
				});
			});
			else return this._def.schema._parseSync({
				data: processed,
				path: ctx.path,
				parent: ctx
			});
		}
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) status.abort();
				else status.dirty();
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				executeRefinement(inner.value);
				return {
					status: status.value,
					value: inner.value
				};
			} else return this._def.schema._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}).then((inner) => {
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status.dirty();
				return executeRefinement(inner.value).then(() => {
					return {
						status: status.value,
						value: inner.value
					};
				});
			});
		}
		if (effect.type === "transform") if (ctx.common.async === false) {
			const base = this._def.schema._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (!isValid(base)) return base;
			const result = effect.transform(base.value, checkCtx);
			if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
			return {
				status: status.value,
				value: result
			};
		} else return this._def.schema._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}).then((base) => {
			if (!isValid(base)) return base;
			return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
				status: status.value,
				value: result
			}));
		});
		util.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
		return this._def.innerType._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) return result.then((result$1) => {
			return {
				status: "valid",
				value: result$1.status === "valid" ? result$1.value : this._def.catchValue({ get error() {
					return new ZodError(newCtx.common.issues);
				} })
			};
		});
		else return {
			status: "valid",
			value: result.status === "valid" ? result.value : this._def.catchValue({ get error() {
				return new ZodError(newCtx.common.issues);
			} })
		};
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data = ctx.data;
		return this._def.type._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status.dirty();
					return DIRTY(inResult.value);
				} else return this._def.out._parseAsync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else return this._def.out._parseSync({
				data: inResult.value,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var custom = (check, params = {}, fatal) => {
	if (check) return ZodAny.create().superRefine((data, ctx) => {
		var _a, _b;
		if (!check(data)) {
			const p = typeof params === "function" ? params(data) : params;
			const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
			const p2 = typeof p === "string" ? { message: p } : p;
			ctx.addIssue({
				code: "custom",
				...p2,
				fatal: _fatal
			});
		}
	});
	return ZodAny.create();
};
var late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {
	ZodFirstPartyTypeKind$1["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$1["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$1["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$1["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$1["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$1["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$1["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$1["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$1["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$1["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$1["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$1["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$1["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$1["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$1["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$1["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$1["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$1["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$1["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$1["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$1["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$1["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$1["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$1["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$1["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$1["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$1["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$1["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$1["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$1["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$1["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$1["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$1["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$1["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$1["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = { message: `Input not instance of ${cls.name}` }) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
	string: ((arg) => ZodString.create({
		...arg,
		coerce: true
	})),
	number: ((arg) => ZodNumber.create({
		...arg,
		coerce: true
	})),
	boolean: ((arg) => ZodBoolean.create({
		...arg,
		coerce: true
	})),
	bigint: ((arg) => ZodBigInt.create({
		...arg,
		coerce: true
	})),
	date: ((arg) => ZodDate.create({
		...arg,
		coerce: true
	}))
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
	__proto__: null,
	defaultErrorMap: errorMap,
	setErrorMap,
	getErrorMap,
	makeIssue,
	EMPTY_PATH,
	addIssueToContext,
	ParseStatus,
	INVALID,
	DIRTY,
	OK,
	isAborted,
	isDirty,
	isValid,
	isAsync,
	get util() {
		return util;
	},
	get objectUtil() {
		return objectUtil;
	},
	ZodParsedType,
	getParsedType,
	ZodType,
	ZodString,
	ZodNumber,
	ZodBigInt,
	ZodBoolean,
	ZodDate,
	ZodSymbol,
	ZodUndefined,
	ZodNull,
	ZodAny,
	ZodUnknown,
	ZodNever,
	ZodVoid,
	ZodArray,
	ZodObject,
	ZodUnion,
	ZodDiscriminatedUnion,
	ZodIntersection,
	ZodTuple,
	ZodRecord,
	ZodMap,
	ZodSet,
	ZodFunction,
	ZodLazy,
	ZodLiteral,
	ZodEnum,
	ZodNativeEnum,
	ZodPromise,
	ZodEffects,
	ZodTransformer: ZodEffects,
	ZodOptional,
	ZodNullable,
	ZodDefault,
	ZodCatch,
	ZodNaN,
	BRAND,
	ZodBranded,
	ZodPipeline,
	custom,
	Schema: ZodType,
	ZodSchema: ZodType,
	late,
	get ZodFirstPartyTypeKind() {
		return ZodFirstPartyTypeKind;
	},
	coerce,
	any: anyType,
	array: arrayType,
	bigint: bigIntType,
	boolean: booleanType,
	date: dateType,
	discriminatedUnion: discriminatedUnionType,
	effect: effectsType,
	"enum": enumType,
	"function": functionType,
	"instanceof": instanceOfType,
	intersection: intersectionType,
	lazy: lazyType,
	literal: literalType,
	map: mapType,
	nan: nanType,
	nativeEnum: nativeEnumType,
	never: neverType,
	"null": nullType,
	nullable: nullableType,
	number: numberType,
	object: objectType,
	oboolean,
	onumber,
	optional: optionalType,
	ostring,
	pipeline: pipelineType,
	preprocess: preprocessType,
	promise: promiseType,
	record: recordType,
	set: setType,
	strictObject: strictObjectType,
	string: stringType,
	symbol: symbolType,
	transformer: effectsType,
	tuple: tupleType,
	"undefined": undefinedType,
	union: unionType,
	unknown: unknownType,
	"void": voidType,
	NEVER,
	ZodIssueCode,
	quotelessJson,
	ZodError
});

//#endregion
//#region node_modules/@puzzlehq/types/aleo.js
const aleoAddressRegex = /^aleo1[a-z0-9]{58}$/i;
const aleoViewKeyRegex = /^AViewKey1[a-z0-9]{44}$/i;
const aleoPrivateKeyRegex = /^APrivateKey1[a-z0-9]{47}$/i;
const aleoTransitionIdRegex = /^au1[a-z0-9]{58}$/i;
const aleoTransactionIdRegex = /^at1[a-z0-9]{58}$/i;
const aleoFieldRegex = /^\d+field$/;
const aleoU32 = /^\d+u32$/;
const aleoU64 = /^\d+u64$/;
const zodAddress = z.string().regex(aleoAddressRegex);
const zodViewKey = z.string().regex(aleoViewKeyRegex);
const zodPrivateKey = z.string().regex(aleoPrivateKeyRegex);
const zodTransitionId = z.string().regex(aleoTransitionIdRegex);
const zodTransactionId = z.string().regex(aleoTransactionIdRegex);
const zodField = z.string().regex(aleoFieldRegex);
const zodU32 = z.string().regex(aleoU32);
const zodU64 = z.string().regex(aleoU64);
var InputOutputType;
(function(InputOutputType$1) {
	InputOutputType$1["Record"] = "record";
	InputOutputType$1["OutputRecord"] = "outputRecord";
	InputOutputType$1["Public"] = "public";
	InputOutputType$1["Private"] = "private";
	InputOutputType$1["Constant"] = "constant";
	InputOutputType$1["Future"] = "future";
	InputOutputType$1["ExternalRecord"] = "external_record";
})(InputOutputType || (InputOutputType = {}));

//#endregion
//#region node_modules/@puzzlehq/types/index.js
var RecordStatus;
(function(RecordStatus$1) {
	RecordStatus$1["Unspent"] = "Unspent";
	RecordStatus$1["Pending"] = "Pending";
	RecordStatus$1["Spent"] = "Spent";
})(RecordStatus || (RecordStatus = {}));
var EventType;
(function(EventType$1) {
	EventType$1["Deploy"] = "Deploy";
	EventType$1["Execute"] = "Execute";
	EventType$1["Send"] = "Send";
	EventType$1["Receive"] = "Receive";
	EventType$1["Join"] = "Join";
	EventType$1["Split"] = "Split";
	EventType$1["Shield"] = "Shield";
	EventType$1["Unshield"] = "Unshield";
	EventType$1["Referral"] = "Referral";
	EventType$1["Points"] = "Points";
	EventType$1["Spin"] = "Spin";
	EventType$1["Raffle"] = "Raffle";
	EventType$1["Mint"] = "Mint";
	EventType$1["StoreStock"] = "Store Stock";
	EventType$1["StorePurchase"] = "Store Purchase";
	EventType$1["StoreFulfillment"] = "Store Fulfillment";
	EventType$1["GiveawayEntry"] = "Giveaway Entry";
	EventType$1["GiveawayDraw"] = "Giveaway Draw";
	EventType$1["GiveawayWin"] = "Giveaway Win";
	EventType$1["SquashMint"] = "Squash Mint";
	EventType$1["SquashWater"] = "Squash Water";
	EventType$1["SquashLevelUp"] = "Squash Level Up";
	EventType$1["MysteryCity"] = "Mystery City";
	EventType$1["CatCharmer"] = "Cat Charmer";
})(EventType || (EventType = {}));
var EventStatus;
(function(EventStatus$1) {
	EventStatus$1["Creating"] = "Creating";
	EventStatus$1["Pending"] = "Pending";
	EventStatus$1["Settled"] = "Settled";
	EventStatus$1["Failed"] = "Failed";
})(EventStatus || (EventStatus = {}));
var Visibility;
(function(Visibility$1) {
	Visibility$1["Private"] = "Private";
	Visibility$1["Public"] = "Public";
})(Visibility || (Visibility = {}));
var Network;
(function(Network$1) {
	Network$1["AleoTestnet"] = "AleoTestnet";
	Network$1["AleoMainnet"] = "AleoMainnet";
})(Network || (Network = {}));
const zodEventType = z.nativeEnum(EventType);
const zodEventStatus = z.nativeEnum(EventStatus);
const zodNetwork = z.nativeEnum(Network);
const zodVisibility = z.nativeEnum(Visibility);
const zodRecordStatus = z.nativeEnum(RecordStatus);

//#endregion
//#region node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
	let state;
	const listeners = /* @__PURE__ */ new Set();
	const setState = (partial, replace) => {
		const nextState = typeof partial === "function" ? partial(state) : partial;
		if (!Object.is(nextState, state)) {
			const previousState = state;
			state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
			listeners.forEach((listener) => listener(state, previousState));
		}
	};
	const getState = () => state;
	const getInitialState = () => initialState;
	const subscribe = (listener) => {
		listeners.add(listener);
		return () => listeners.delete(listener);
	};
	const destroy = () => {
		if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.");
		listeners.clear();
	};
	const api = {
		setState,
		getState,
		getInitialState,
		subscribe,
		destroy
	};
	const initialState = state = createState(setState, getState, api);
	return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
/**
* @license React
* use-sync-external-store-shim.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_use_sync_external_store_shim_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js": ((exports) => {
	(function() {
		function is(x, y$1) {
			return x === y$1 && (0 !== x || 1 / x === 1 / y$1) || x !== x && y$1 !== y$1;
		}
		function useSyncExternalStore$2(subscribe, getSnapshot) {
			didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
			var value = getSnapshot();
			if (!didWarnUncachedGetSnapshot) {
				var cachedValue = getSnapshot();
				objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
			}
			cachedValue = useState$3({ inst: {
				value,
				getSnapshot
			} });
			var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
			useLayoutEffect(function() {
				inst.value = value;
				inst.getSnapshot = getSnapshot;
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
			}, [
				subscribe,
				value,
				getSnapshot
			]);
			useEffect$7(function() {
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				return subscribe(function() {
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				});
			}, [subscribe]);
			useDebugValue$1(value);
			return value;
		}
		function checkIfSnapshotChanged(inst) {
			var latestGetSnapshot = inst.getSnapshot;
			inst = inst.value;
			try {
				var nextValue = latestGetSnapshot();
				return !objectIs(inst, nextValue);
			} catch (error) {
				return !0;
			}
		}
		function useSyncExternalStore$1(subscribe, getSnapshot) {
			return getSnapshot();
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState$3 = React.useState, useEffect$7 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue$1 = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
		exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/index.js
var require_shim = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/index.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_shim_development();
}) });

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
/**
* @license React
* use-sync-external-store-shim/with-selector.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_with_selector_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js": ((exports) => {
	(function() {
		function is(x, y$1) {
			return x === y$1 && (0 !== x || 1 / x === 1 / y$1) || x !== x && y$1 !== y$1;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect$7 = React.useEffect, useMemo = React.useMemo, useDebugValue$1 = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
			useEffect$7(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue$1(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/with-selector.js": ((exports, module) => {
	module.exports = require_with_selector_development();
}) });

//#endregion
//#region node_modules/zustand/esm/index.mjs
var import_with_selector = /* @__PURE__ */ __toESM(require_with_selector(), 1);
var { useDebugValue } = import_react.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
	if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
		console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937");
		didWarnAboutEqualityFn = true;
	}
	const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getServerState || api.getInitialState, selector, equalityFn);
	useDebugValue(slice);
	return slice;
}
var createImpl = (createState) => {
	if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && typeof createState !== "function") console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
	const api = typeof createState === "function" ? createStore(createState) : createState;
	const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
	Object.assign(useBoundStore, api);
	return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/subscribable.mjs
var Subscribable = class {
	constructor() {
		this.listeners = /* @__PURE__ */ new Set();
		this.subscribe = this.subscribe.bind(this);
	}
	subscribe(listener) {
		const identity$1 = { listener };
		this.listeners.add(identity$1);
		this.onSubscribe();
		return () => {
			this.listeners.delete(identity$1);
			this.onUnsubscribe();
		};
	}
	hasListeners() {
		return this.listeners.size > 0;
	}
	onSubscribe() {}
	onUnsubscribe() {}
};

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/utils.mjs
var isServer = typeof window === "undefined" || "Deno" in window;
function noop() {}
function functionalUpdate(updater, input) {
	return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
	return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
	return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
	if (!isQueryKey(arg1)) return arg1;
	if (typeof arg2 === "function") return {
		...arg3,
		queryKey: arg1,
		queryFn: arg2
	};
	return {
		...arg2,
		queryKey: arg1
	};
}
function parseFilterArgs(arg1, arg2, arg3) {
	return isQueryKey(arg1) ? [{
		...arg2,
		queryKey: arg1
	}, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
	const { type = "all", exact, fetchStatus, predicate, queryKey, stale } = filters;
	if (isQueryKey(queryKey)) {
		if (exact) {
			if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) return false;
		} else if (!partialMatchKey(query.queryKey, queryKey)) return false;
	}
	if (type !== "all") {
		const isActive = query.isActive();
		if (type === "active" && !isActive) return false;
		if (type === "inactive" && isActive) return false;
	}
	if (typeof stale === "boolean" && query.isStale() !== stale) return false;
	if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) return false;
	if (predicate && !predicate(query)) return false;
	return true;
}
function matchMutation(filters, mutation) {
	const { exact, fetching, predicate, mutationKey } = filters;
	if (isQueryKey(mutationKey)) {
		if (!mutation.options.mutationKey) return false;
		if (exact) {
			if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) return false;
		} else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) return false;
	}
	if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) return false;
	if (predicate && !predicate(mutation)) return false;
	return true;
}
function hashQueryKeyByOptions(queryKey, options) {
	return ((options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey)(queryKey);
}
/**
* Default query keys hash function.
* Hashes the value into a stable hash.
*/
function hashQueryKey(queryKey) {
	return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
		result[key] = val[key];
		return result;
	}, {}) : val);
}
/**
* Checks if key `b` partially matches with key `a`.
*/
function partialMatchKey(a, b) {
	return partialDeepEqual(a, b);
}
/**
* Checks if `b` partially matches with `a`.
*/
function partialDeepEqual(a, b) {
	if (a === b) return true;
	if (typeof a !== typeof b) return false;
	if (a && b && typeof a === "object" && typeof b === "object") return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
	return false;
}
/**
* This function returns `a` if `b` is deeply equal.
* If not, it will replace any deeply equal children of `b` with those of `a`.
* This can be used for structural sharing between JSON values for example.
*/
function replaceEqualDeep(a, b) {
	if (a === b) return a;
	const array = isPlainArray(a) && isPlainArray(b);
	if (array || isPlainObject(a) && isPlainObject(b)) {
		const aSize = array ? a.length : Object.keys(a).length;
		const bItems = array ? b : Object.keys(b);
		const bSize = bItems.length;
		const copy = array ? [] : {};
		let equalItems = 0;
		for (let i = 0; i < bSize; i++) {
			const key = array ? i : bItems[i];
			copy[key] = replaceEqualDeep(a[key], b[key]);
			if (copy[key] === a[key]) equalItems++;
		}
		return aSize === bSize && equalItems === aSize ? a : copy;
	}
	return b;
}
function isPlainArray(value) {
	return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
	if (!hasObjectPrototype(o)) return false;
	const ctor = o.constructor;
	if (typeof ctor === "undefined") return true;
	const prot = ctor.prototype;
	if (!hasObjectPrototype(prot)) return false;
	if (!prot.hasOwnProperty("isPrototypeOf")) return false;
	return true;
}
function hasObjectPrototype(o) {
	return Object.prototype.toString.call(o) === "[object Object]";
}
function isQueryKey(value) {
	return Array.isArray(value);
}
function sleep(timeout) {
	return new Promise((resolve) => {
		setTimeout(resolve, timeout);
	});
}
/**
* Schedules a microtask.
* This can be useful to schedule state updates after rendering.
*/
function scheduleMicrotask(callback) {
	sleep(0).then(callback);
}
function getAbortController() {
	if (typeof AbortController === "function") return new AbortController();
}
function replaceData(prevData, data, options) {
	if (options.isDataEqual != null && options.isDataEqual(prevData, data)) return prevData;
	else if (typeof options.structuralSharing === "function") return options.structuralSharing(prevData, data);
	else if (options.structuralSharing !== false) return replaceEqualDeep(prevData, data);
	return data;
}

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/focusManager.mjs
var FocusManager = class extends Subscribable {
	constructor() {
		super();
		this.setup = (onFocus) => {
			if (!isServer && window.addEventListener) {
				const listener = () => onFocus();
				window.addEventListener("visibilitychange", listener, false);
				window.addEventListener("focus", listener, false);
				return () => {
					window.removeEventListener("visibilitychange", listener);
					window.removeEventListener("focus", listener);
				};
			}
		};
	}
	onSubscribe() {
		if (!this.cleanup) this.setEventListener(this.setup);
	}
	onUnsubscribe() {
		if (!this.hasListeners()) {
			var _this$cleanup;
			(_this$cleanup = this.cleanup) == null || _this$cleanup.call(this);
			this.cleanup = void 0;
		}
	}
	setEventListener(setup$1) {
		var _this$cleanup2;
		this.setup = setup$1;
		(_this$cleanup2 = this.cleanup) == null || _this$cleanup2.call(this);
		this.cleanup = setup$1((focused) => {
			if (typeof focused === "boolean") this.setFocused(focused);
			else this.onFocus();
		});
	}
	setFocused(focused) {
		if (this.focused !== focused) {
			this.focused = focused;
			this.onFocus();
		}
	}
	onFocus() {
		this.listeners.forEach(({ listener }) => {
			listener();
		});
	}
	isFocused() {
		if (typeof this.focused === "boolean") return this.focused;
		if (typeof document === "undefined") return true;
		return [
			void 0,
			"visible",
			"prerender"
		].includes(document.visibilityState);
	}
};
var focusManager = new FocusManager();

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/onlineManager.mjs
var onlineEvents = ["online", "offline"];
var OnlineManager = class extends Subscribable {
	constructor() {
		super();
		this.setup = (onOnline) => {
			if (!isServer && window.addEventListener) {
				const listener = () => onOnline();
				onlineEvents.forEach((event) => {
					window.addEventListener(event, listener, false);
				});
				return () => {
					onlineEvents.forEach((event) => {
						window.removeEventListener(event, listener);
					});
				};
			}
		};
	}
	onSubscribe() {
		if (!this.cleanup) this.setEventListener(this.setup);
	}
	onUnsubscribe() {
		if (!this.hasListeners()) {
			var _this$cleanup;
			(_this$cleanup = this.cleanup) == null || _this$cleanup.call(this);
			this.cleanup = void 0;
		}
	}
	setEventListener(setup$1) {
		var _this$cleanup2;
		this.setup = setup$1;
		(_this$cleanup2 = this.cleanup) == null || _this$cleanup2.call(this);
		this.cleanup = setup$1((online) => {
			if (typeof online === "boolean") this.setOnline(online);
			else this.onOnline();
		});
	}
	setOnline(online) {
		if (this.online !== online) {
			this.online = online;
			this.onOnline();
		}
	}
	onOnline() {
		this.listeners.forEach(({ listener }) => {
			listener();
		});
	}
	isOnline() {
		if (typeof this.online === "boolean") return this.online;
		if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") return true;
		return navigator.onLine;
	}
};
var onlineManager = new OnlineManager();

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/retryer.mjs
function defaultRetryDelay(failureCount) {
	return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
	return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class {
	constructor(options) {
		this.revert = options == null ? void 0 : options.revert;
		this.silent = options == null ? void 0 : options.silent;
	}
};
function isCancelledError(value) {
	return value instanceof CancelledError;
}
function createRetryer(config) {
	let isRetryCancelled = false;
	let failureCount = 0;
	let isResolved = false;
	let continueFn;
	let promiseResolve;
	let promiseReject;
	const promise = new Promise((outerResolve, outerReject) => {
		promiseResolve = outerResolve;
		promiseReject = outerReject;
	});
	const cancel = (cancelOptions) => {
		if (!isResolved) {
			reject(new CancelledError(cancelOptions));
			config.abort == null || config.abort();
		}
	};
	const cancelRetry = () => {
		isRetryCancelled = true;
	};
	const continueRetry = () => {
		isRetryCancelled = false;
	};
	const shouldPause = () => !focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.isOnline();
	const resolve = (value) => {
		if (!isResolved) {
			isResolved = true;
			config.onSuccess == null || config.onSuccess(value);
			continueFn?.();
			promiseResolve(value);
		}
	};
	const reject = (value) => {
		if (!isResolved) {
			isResolved = true;
			config.onError == null || config.onError(value);
			continueFn?.();
			promiseReject(value);
		}
	};
	const pause = () => {
		return new Promise((continueResolve) => {
			continueFn = (value) => {
				const canContinue = isResolved || !shouldPause();
				if (canContinue) continueResolve(value);
				return canContinue;
			};
			config.onPause == null || config.onPause();
		}).then(() => {
			continueFn = void 0;
			if (!isResolved) config.onContinue == null || config.onContinue();
		});
	};
	const run = () => {
		if (isResolved) return;
		let promiseOrValue;
		try {
			promiseOrValue = config.fn();
		} catch (error) {
			promiseOrValue = Promise.reject(error);
		}
		Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
			var _config$retry, _config$retryDelay;
			if (isResolved) return;
			const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
			const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
			const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
			const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
			if (isRetryCancelled || !shouldRetry) {
				reject(error);
				return;
			}
			failureCount++;
			config.onFail == null || config.onFail(failureCount, error);
			sleep(delay).then(() => {
				if (shouldPause()) return pause();
			}).then(() => {
				if (isRetryCancelled) reject(error);
				else run();
			});
		});
	};
	if (canFetch(config.networkMode)) run();
	else pause().then(run);
	return {
		promise,
		cancel,
		continue: () => {
			return (continueFn == null ? void 0 : continueFn()) ? promise : Promise.resolve();
		},
		cancelRetry,
		continueRetry
	};
}

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/logger.mjs
var defaultLogger = console;

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/notifyManager.mjs
function createNotifyManager() {
	let queue = [];
	let transactions = 0;
	let notifyFn = (callback) => {
		callback();
	};
	let batchNotifyFn = (callback) => {
		callback();
	};
	const batch = (callback) => {
		let result;
		transactions++;
		try {
			result = callback();
		} finally {
			transactions--;
			if (!transactions) flush();
		}
		return result;
	};
	const schedule = (callback) => {
		if (transactions) queue.push(callback);
		else scheduleMicrotask(() => {
			notifyFn(callback);
		});
	};
	/**
	* All calls to the wrapped function will be batched.
	*/
	const batchCalls = (callback) => {
		return (...args) => {
			schedule(() => {
				callback(...args);
			});
		};
	};
	const flush = () => {
		const originalQueue = queue;
		queue = [];
		if (originalQueue.length) scheduleMicrotask(() => {
			batchNotifyFn(() => {
				originalQueue.forEach((callback) => {
					notifyFn(callback);
				});
			});
		});
	};
	/**
	* Use this method to set a custom notify function.
	* This can be used to for example wrap notifications with `React.act` while running tests.
	*/
	const setNotifyFunction = (fn) => {
		notifyFn = fn;
	};
	/**
	* Use this method to set a custom function to batch notifications together into a single tick.
	* By default React Query will use the batch function provided by ReactDOM or React Native.
	*/
	const setBatchNotifyFunction = (fn) => {
		batchNotifyFn = fn;
	};
	return {
		batch,
		batchCalls,
		schedule,
		setNotifyFunction,
		setBatchNotifyFunction
	};
}
var notifyManager = createNotifyManager();

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/removable.mjs
var Removable = class {
	destroy() {
		this.clearGcTimeout();
	}
	scheduleGc() {
		this.clearGcTimeout();
		if (isValidTimeout(this.cacheTime)) this.gcTimeout = setTimeout(() => {
			this.optionalRemove();
		}, this.cacheTime);
	}
	updateCacheTime(newCacheTime) {
		this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 300 * 1e3);
	}
	clearGcTimeout() {
		if (this.gcTimeout) {
			clearTimeout(this.gcTimeout);
			this.gcTimeout = void 0;
		}
	}
};

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/query.mjs
var Query = class extends Removable {
	constructor(config) {
		super();
		this.abortSignalConsumed = false;
		this.defaultOptions = config.defaultOptions;
		this.setOptions(config.options);
		this.observers = [];
		this.cache = config.cache;
		this.logger = config.logger || defaultLogger;
		this.queryKey = config.queryKey;
		this.queryHash = config.queryHash;
		this.initialState = config.state || getDefaultState$1(this.options);
		this.state = this.initialState;
		this.scheduleGc();
	}
	get meta() {
		return this.options.meta;
	}
	setOptions(options) {
		this.options = {
			...this.defaultOptions,
			...options
		};
		this.updateCacheTime(this.options.cacheTime);
	}
	optionalRemove() {
		if (!this.observers.length && this.state.fetchStatus === "idle") this.cache.remove(this);
	}
	setData(newData, options) {
		const data = replaceData(this.state.data, newData, this.options);
		this.dispatch({
			data,
			type: "success",
			dataUpdatedAt: options == null ? void 0 : options.updatedAt,
			manual: options == null ? void 0 : options.manual
		});
		return data;
	}
	setState(state, setStateOptions) {
		this.dispatch({
			type: "setState",
			state,
			setStateOptions
		});
	}
	cancel(options) {
		var _this$retryer;
		const promise = this.promise;
		(_this$retryer = this.retryer) == null || _this$retryer.cancel(options);
		return promise ? promise.then(noop).catch(noop) : Promise.resolve();
	}
	destroy() {
		super.destroy();
		this.cancel({ silent: true });
	}
	reset() {
		this.destroy();
		this.setState(this.initialState);
	}
	isActive() {
		return this.observers.some((observer) => observer.options.enabled !== false);
	}
	isDisabled() {
		return this.getObserversCount() > 0 && !this.isActive();
	}
	isStale() {
		return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
	}
	isStaleByTime(staleTime = 0) {
		return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
	}
	onFocus() {
		var _this$retryer2;
		const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
		if (observer) observer.refetch({ cancelRefetch: false });
		(_this$retryer2 = this.retryer) == null || _this$retryer2.continue();
	}
	onOnline() {
		var _this$retryer3;
		const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
		if (observer) observer.refetch({ cancelRefetch: false });
		(_this$retryer3 = this.retryer) == null || _this$retryer3.continue();
	}
	addObserver(observer) {
		if (!this.observers.includes(observer)) {
			this.observers.push(observer);
			this.clearGcTimeout();
			this.cache.notify({
				type: "observerAdded",
				query: this,
				observer
			});
		}
	}
	removeObserver(observer) {
		if (this.observers.includes(observer)) {
			this.observers = this.observers.filter((x) => x !== observer);
			if (!this.observers.length) {
				if (this.retryer) if (this.abortSignalConsumed) this.retryer.cancel({ revert: true });
				else this.retryer.cancelRetry();
				this.scheduleGc();
			}
			this.cache.notify({
				type: "observerRemoved",
				query: this,
				observer
			});
		}
	}
	getObserversCount() {
		return this.observers.length;
	}
	invalidate() {
		if (!this.state.isInvalidated) this.dispatch({ type: "invalidate" });
	}
	fetch(options, fetchOptions) {
		var _this$options$behavio, _context$fetchOptions;
		if (this.state.fetchStatus !== "idle") {
			if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) this.cancel({ silent: true });
			else if (this.promise) {
				var _this$retryer4;
				(_this$retryer4 = this.retryer) == null || _this$retryer4.continueRetry();
				return this.promise;
			}
		}
		if (options) this.setOptions(options);
		if (!this.options.queryFn) {
			const observer = this.observers.find((x) => x.options.queryFn);
			if (observer) this.setOptions(observer.options);
		}
		if (!Array.isArray(this.options.queryKey)) this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
		const abortController = getAbortController();
		const queryFnContext = {
			queryKey: this.queryKey,
			pageParam: void 0,
			meta: this.meta
		};
		const addSignalProperty = (object) => {
			Object.defineProperty(object, "signal", {
				enumerable: true,
				get: () => {
					if (abortController) {
						this.abortSignalConsumed = true;
						return abortController.signal;
					}
				}
			});
		};
		addSignalProperty(queryFnContext);
		const fetchFn = () => {
			if (!this.options.queryFn) return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
			this.abortSignalConsumed = false;
			return this.options.queryFn(queryFnContext);
		};
		const context = {
			fetchOptions,
			options: this.options,
			queryKey: this.queryKey,
			state: this.state,
			fetchFn
		};
		addSignalProperty(context);
		(_this$options$behavio = this.options.behavior) == null || _this$options$behavio.onFetch(context);
		this.revertState = this.state;
		if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
			var _context$fetchOptions2;
			this.dispatch({
				type: "fetch",
				meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
			});
		}
		const onError = (error) => {
			if (!(isCancelledError(error) && error.silent)) this.dispatch({
				type: "error",
				error
			});
			if (!isCancelledError(error)) {
				var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
				(_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null || _this$cache$config$on.call(_this$cache$config, error, this);
				(_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null || _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
				this.logger.error(error);
			}
			if (!this.isFetchingOptimistic) this.scheduleGc();
			this.isFetchingOptimistic = false;
		};
		this.retryer = createRetryer({
			fn: context.fetchFn,
			abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
			onSuccess: (data) => {
				var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
				if (typeof data === "undefined") {
					this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
					onError(/* @__PURE__ */ new Error(this.queryHash + " data is undefined"));
					return;
				}
				this.setData(data);
				(_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null || _this$cache$config$on3.call(_this$cache$config3, data, this);
				(_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null || _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
				if (!this.isFetchingOptimistic) this.scheduleGc();
				this.isFetchingOptimistic = false;
			},
			onError,
			onFail: (failureCount, error) => {
				this.dispatch({
					type: "failed",
					failureCount,
					error
				});
			},
			onPause: () => {
				this.dispatch({ type: "pause" });
			},
			onContinue: () => {
				this.dispatch({ type: "continue" });
			},
			retry: context.options.retry,
			retryDelay: context.options.retryDelay,
			networkMode: context.options.networkMode
		});
		this.promise = this.retryer.promise;
		return this.promise;
	}
	dispatch(action) {
		const reducer = (state) => {
			var _action$meta, _action$dataUpdatedAt;
			switch (action.type) {
				case "failed": return {
					...state,
					fetchFailureCount: action.failureCount,
					fetchFailureReason: action.error
				};
				case "pause": return {
					...state,
					fetchStatus: "paused"
				};
				case "continue": return {
					...state,
					fetchStatus: "fetching"
				};
				case "fetch": return {
					...state,
					fetchFailureCount: 0,
					fetchFailureReason: null,
					fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
					fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
					...!state.dataUpdatedAt && {
						error: null,
						status: "loading"
					}
				};
				case "success": return {
					...state,
					data: action.data,
					dataUpdateCount: state.dataUpdateCount + 1,
					dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
					error: null,
					isInvalidated: false,
					status: "success",
					...!action.manual && {
						fetchStatus: "idle",
						fetchFailureCount: 0,
						fetchFailureReason: null
					}
				};
				case "error":
					const error = action.error;
					if (isCancelledError(error) && error.revert && this.revertState) return {
						...this.revertState,
						fetchStatus: "idle"
					};
					return {
						...state,
						error,
						errorUpdateCount: state.errorUpdateCount + 1,
						errorUpdatedAt: Date.now(),
						fetchFailureCount: state.fetchFailureCount + 1,
						fetchFailureReason: error,
						fetchStatus: "idle",
						status: "error"
					};
				case "invalidate": return {
					...state,
					isInvalidated: true
				};
				case "setState": return {
					...state,
					...action.state
				};
			}
		};
		this.state = reducer(this.state);
		notifyManager.batch(() => {
			this.observers.forEach((observer) => {
				observer.onQueryUpdate(action);
			});
			this.cache.notify({
				query: this,
				type: "updated",
				action
			});
		});
	}
};
function getDefaultState$1(options) {
	const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
	const hasData = typeof data !== "undefined";
	const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
	return {
		data,
		dataUpdateCount: 0,
		dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
		error: null,
		errorUpdateCount: 0,
		errorUpdatedAt: 0,
		fetchFailureCount: 0,
		fetchFailureReason: null,
		fetchMeta: null,
		isInvalidated: false,
		status: hasData ? "success" : "loading",
		fetchStatus: "idle"
	};
}

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/queryCache.mjs
var QueryCache = class extends Subscribable {
	constructor(config) {
		super();
		this.config = config || {};
		this.queries = [];
		this.queriesMap = {};
	}
	build(client, options, state) {
		var _options$queryHash;
		const queryKey = options.queryKey;
		const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
		let query = this.get(queryHash);
		if (!query) {
			query = new Query({
				cache: this,
				logger: client.getLogger(),
				queryKey,
				queryHash,
				options: client.defaultQueryOptions(options),
				state,
				defaultOptions: client.getQueryDefaults(queryKey)
			});
			this.add(query);
		}
		return query;
	}
	add(query) {
		if (!this.queriesMap[query.queryHash]) {
			this.queriesMap[query.queryHash] = query;
			this.queries.push(query);
			this.notify({
				type: "added",
				query
			});
		}
	}
	remove(query) {
		const queryInMap = this.queriesMap[query.queryHash];
		if (queryInMap) {
			query.destroy();
			this.queries = this.queries.filter((x) => x !== query);
			if (queryInMap === query) delete this.queriesMap[query.queryHash];
			this.notify({
				type: "removed",
				query
			});
		}
	}
	clear() {
		notifyManager.batch(() => {
			this.queries.forEach((query) => {
				this.remove(query);
			});
		});
	}
	get(queryHash) {
		return this.queriesMap[queryHash];
	}
	getAll() {
		return this.queries;
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	find(arg1, arg2) {
		const [filters] = parseFilterArgs(arg1, arg2);
		if (typeof filters.exact === "undefined") filters.exact = true;
		return this.queries.find((query) => matchQuery(filters, query));
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	findAll(arg1, arg2) {
		const [filters] = parseFilterArgs(arg1, arg2);
		return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
	}
	notify(event) {
		notifyManager.batch(() => {
			this.listeners.forEach(({ listener }) => {
				listener(event);
			});
		});
	}
	onFocus() {
		notifyManager.batch(() => {
			this.queries.forEach((query) => {
				query.onFocus();
			});
		});
	}
	onOnline() {
		notifyManager.batch(() => {
			this.queries.forEach((query) => {
				query.onOnline();
			});
		});
	}
};

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/mutation.mjs
var Mutation = class extends Removable {
	constructor(config) {
		super();
		this.defaultOptions = config.defaultOptions;
		this.mutationId = config.mutationId;
		this.mutationCache = config.mutationCache;
		this.logger = config.logger || defaultLogger;
		this.observers = [];
		this.state = config.state || getDefaultState();
		this.setOptions(config.options);
		this.scheduleGc();
	}
	setOptions(options) {
		this.options = {
			...this.defaultOptions,
			...options
		};
		this.updateCacheTime(this.options.cacheTime);
	}
	get meta() {
		return this.options.meta;
	}
	setState(state) {
		this.dispatch({
			type: "setState",
			state
		});
	}
	addObserver(observer) {
		if (!this.observers.includes(observer)) {
			this.observers.push(observer);
			this.clearGcTimeout();
			this.mutationCache.notify({
				type: "observerAdded",
				mutation: this,
				observer
			});
		}
	}
	removeObserver(observer) {
		this.observers = this.observers.filter((x) => x !== observer);
		this.scheduleGc();
		this.mutationCache.notify({
			type: "observerRemoved",
			mutation: this,
			observer
		});
	}
	optionalRemove() {
		if (!this.observers.length) if (this.state.status === "loading") this.scheduleGc();
		else this.mutationCache.remove(this);
	}
	continue() {
		var _this$retryer$continu, _this$retryer;
		return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
	}
	async execute() {
		const executeMutation = () => {
			var _this$options$retry;
			this.retryer = createRetryer({
				fn: () => {
					if (!this.options.mutationFn) return Promise.reject("No mutationFn found");
					return this.options.mutationFn(this.state.variables);
				},
				onFail: (failureCount, error) => {
					this.dispatch({
						type: "failed",
						failureCount,
						error
					});
				},
				onPause: () => {
					this.dispatch({ type: "pause" });
				},
				onContinue: () => {
					this.dispatch({ type: "continue" });
				},
				retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
				retryDelay: this.options.retryDelay,
				networkMode: this.options.networkMode
			});
			return this.retryer.promise;
		};
		const restored = this.state.status === "loading";
		try {
			var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
			if (!restored) {
				var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
				this.dispatch({
					type: "loading",
					variables: this.options.variables
				});
				await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
				const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
				if (context !== this.state.context) this.dispatch({
					type: "loading",
					context,
					variables: this.state.variables
				});
			}
			const data = await executeMutation();
			await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
			await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
			await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
			await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
			this.dispatch({
				type: "success",
				data
			});
			return data;
		} catch (error) {
			try {
				var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
				await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
				this.logger.error(error);
				await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
				await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
				await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
				throw error;
			} finally {
				this.dispatch({
					type: "error",
					error
				});
			}
		}
	}
	dispatch(action) {
		const reducer = (state) => {
			switch (action.type) {
				case "failed": return {
					...state,
					failureCount: action.failureCount,
					failureReason: action.error
				};
				case "pause": return {
					...state,
					isPaused: true
				};
				case "continue": return {
					...state,
					isPaused: false
				};
				case "loading": return {
					...state,
					context: action.context,
					data: void 0,
					failureCount: 0,
					failureReason: null,
					error: null,
					isPaused: !canFetch(this.options.networkMode),
					status: "loading",
					variables: action.variables
				};
				case "success": return {
					...state,
					data: action.data,
					failureCount: 0,
					failureReason: null,
					error: null,
					status: "success",
					isPaused: false
				};
				case "error": return {
					...state,
					data: void 0,
					error: action.error,
					failureCount: state.failureCount + 1,
					failureReason: action.error,
					isPaused: false,
					status: "error"
				};
				case "setState": return {
					...state,
					...action.state
				};
			}
		};
		this.state = reducer(this.state);
		notifyManager.batch(() => {
			this.observers.forEach((observer) => {
				observer.onMutationUpdate(action);
			});
			this.mutationCache.notify({
				mutation: this,
				type: "updated",
				action
			});
		});
	}
};
function getDefaultState() {
	return {
		context: void 0,
		data: void 0,
		error: null,
		failureCount: 0,
		failureReason: null,
		isPaused: false,
		status: "idle",
		variables: void 0
	};
}

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/mutationCache.mjs
var MutationCache = class extends Subscribable {
	constructor(config) {
		super();
		this.config = config || {};
		this.mutations = [];
		this.mutationId = 0;
	}
	build(client, options, state) {
		const mutation = new Mutation({
			mutationCache: this,
			logger: client.getLogger(),
			mutationId: ++this.mutationId,
			options: client.defaultMutationOptions(options),
			state,
			defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
		});
		this.add(mutation);
		return mutation;
	}
	add(mutation) {
		this.mutations.push(mutation);
		this.notify({
			type: "added",
			mutation
		});
	}
	remove(mutation) {
		this.mutations = this.mutations.filter((x) => x !== mutation);
		this.notify({
			type: "removed",
			mutation
		});
	}
	clear() {
		notifyManager.batch(() => {
			this.mutations.forEach((mutation) => {
				this.remove(mutation);
			});
		});
	}
	getAll() {
		return this.mutations;
	}
	find(filters) {
		if (typeof filters.exact === "undefined") filters.exact = true;
		return this.mutations.find((mutation) => matchMutation(filters, mutation));
	}
	findAll(filters) {
		return this.mutations.filter((mutation) => matchMutation(filters, mutation));
	}
	notify(event) {
		notifyManager.batch(() => {
			this.listeners.forEach(({ listener }) => {
				listener(event);
			});
		});
	}
	resumePausedMutations() {
		var _this$resuming;
		this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
			const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
			return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));
		}).then(() => {
			this.resuming = void 0;
		});
		return this.resuming;
	}
};

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs
function infiniteQueryBehavior() {
	return { onFetch: (context) => {
		context.fetchFn = () => {
			var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
			const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
			const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
			const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
			const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
			const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
			const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
			const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
			let newPageParams = oldPageParams;
			let cancelled = false;
			const addSignalProperty = (object) => {
				Object.defineProperty(object, "signal", {
					enumerable: true,
					get: () => {
						var _context$signal;
						if ((_context$signal = context.signal) != null && _context$signal.aborted) cancelled = true;
						else {
							var _context$signal2;
							(_context$signal2 = context.signal) == null || _context$signal2.addEventListener("abort", () => {
								cancelled = true;
							});
						}
						return context.signal;
					}
				});
			};
			const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
			const buildNewPages = (pages, param, page, previous) => {
				newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
				return previous ? [page, ...pages] : [...pages, page];
			};
			const fetchPage = (pages, manual, param, previous) => {
				if (cancelled) return Promise.reject("Cancelled");
				if (typeof param === "undefined" && !manual && pages.length) return Promise.resolve(pages);
				const queryFnContext = {
					queryKey: context.queryKey,
					pageParam: param,
					meta: context.options.meta
				};
				addSignalProperty(queryFnContext);
				const queryFnResult = queryFn(queryFnContext);
				return Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
			};
			let promise;
			if (!oldPages.length) promise = fetchPage([]);
			else if (isFetchingNextPage) {
				const manual = typeof pageParam !== "undefined";
				promise = fetchPage(oldPages, manual, manual ? pageParam : getNextPageParam(context.options, oldPages));
			} else if (isFetchingPreviousPage) {
				const manual = typeof pageParam !== "undefined";
				promise = fetchPage(oldPages, manual, manual ? pageParam : getPreviousPageParam(context.options, oldPages), true);
			} else {
				newPageParams = [];
				const manual = typeof context.options.getNextPageParam === "undefined";
				promise = (refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true) ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
				for (let i = 1; i < oldPages.length; i++) promise = promise.then((pages) => {
					if (refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true) return fetchPage(pages, manual, manual ? oldPageParams[i] : getNextPageParam(context.options, pages));
					return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
				});
			}
			return promise.then((pages) => ({
				pages,
				pageParams: newPageParams
			}));
		};
	} };
}
function getNextPageParam(options, pages) {
	return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
	return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}

//#endregion
//#region node_modules/@tanstack/query-core/build/lib/queryClient.mjs
var QueryClient = class {
	constructor(config = {}) {
		this.queryCache = config.queryCache || new QueryCache();
		this.mutationCache = config.mutationCache || new MutationCache();
		this.logger = config.logger || defaultLogger;
		this.defaultOptions = config.defaultOptions || {};
		this.queryDefaults = [];
		this.mutationDefaults = [];
		this.mountCount = 0;
		if (config.logger) this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
	}
	mount() {
		this.mountCount++;
		if (this.mountCount !== 1) return;
		this.unsubscribeFocus = focusManager.subscribe(() => {
			if (focusManager.isFocused()) {
				this.resumePausedMutations();
				this.queryCache.onFocus();
			}
		});
		this.unsubscribeOnline = onlineManager.subscribe(() => {
			if (onlineManager.isOnline()) {
				this.resumePausedMutations();
				this.queryCache.onOnline();
			}
		});
	}
	unmount() {
		var _this$unsubscribeFocu, _this$unsubscribeOnli;
		this.mountCount--;
		if (this.mountCount !== 0) return;
		(_this$unsubscribeFocu = this.unsubscribeFocus) == null || _this$unsubscribeFocu.call(this);
		this.unsubscribeFocus = void 0;
		(_this$unsubscribeOnli = this.unsubscribeOnline) == null || _this$unsubscribeOnli.call(this);
		this.unsubscribeOnline = void 0;
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	isFetching(arg1, arg2) {
		const [filters] = parseFilterArgs(arg1, arg2);
		filters.fetchStatus = "fetching";
		return this.queryCache.findAll(filters).length;
	}
	isMutating(filters) {
		return this.mutationCache.findAll({
			...filters,
			fetching: true
		}).length;
	}
	/**
	* @deprecated This method will accept only queryKey in the next major version.
	*/
	getQueryData(queryKey, filters) {
		var _this$queryCache$find;
		return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	ensureQueryData(arg1, arg2, arg3) {
		const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
		const cachedData = this.getQueryData(parsedOptions.queryKey);
		return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	getQueriesData(queryKeyOrFilters) {
		return this.getQueryCache().findAll(queryKeyOrFilters).map(({ queryKey, state }) => {
			return [queryKey, state.data];
		});
	}
	setQueryData(queryKey, updater, options) {
		const query = this.queryCache.find(queryKey);
		const data = functionalUpdate(updater, query == null ? void 0 : query.state.data);
		if (typeof data === "undefined") return;
		const parsedOptions = parseQueryArgs(queryKey);
		const defaultedOptions = this.defaultQueryOptions(parsedOptions);
		return this.queryCache.build(this, defaultedOptions).setData(data, {
			...options,
			manual: true
		});
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	setQueriesData(queryKeyOrFilters, updater, options) {
		return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({ queryKey }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
	}
	getQueryState(queryKey, filters) {
		var _this$queryCache$find2;
		return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	removeQueries(arg1, arg2) {
		const [filters] = parseFilterArgs(arg1, arg2);
		const queryCache = this.queryCache;
		notifyManager.batch(() => {
			queryCache.findAll(filters).forEach((query) => {
				queryCache.remove(query);
			});
		});
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	resetQueries(arg1, arg2, arg3) {
		const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
		const queryCache = this.queryCache;
		const refetchFilters = {
			type: "active",
			...filters
		};
		return notifyManager.batch(() => {
			queryCache.findAll(filters).forEach((query) => {
				query.reset();
			});
			return this.refetchQueries(refetchFilters, options);
		});
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	cancelQueries(arg1, arg2, arg3) {
		const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
		if (typeof cancelOptions.revert === "undefined") cancelOptions.revert = true;
		const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
		return Promise.all(promises).then(noop).catch(noop);
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	invalidateQueries(arg1, arg2, arg3) {
		const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
		return notifyManager.batch(() => {
			var _ref, _filters$refetchType;
			this.queryCache.findAll(filters).forEach((query) => {
				query.invalidate();
			});
			if (filters.refetchType === "none") return Promise.resolve();
			const refetchFilters = {
				...filters,
				type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
			};
			return this.refetchQueries(refetchFilters, options);
		});
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	refetchQueries(arg1, arg2, arg3) {
		const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
		const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
			var _options$cancelRefetc;
			return query.fetch(void 0, {
				...options,
				cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
				meta: { refetchPage: filters.refetchPage }
			});
		}));
		let promise = Promise.all(promises).then(noop);
		if (!(options != null && options.throwOnError)) promise = promise.catch(noop);
		return promise;
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	fetchQuery(arg1, arg2, arg3) {
		const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
		const defaultedOptions = this.defaultQueryOptions(parsedOptions);
		if (typeof defaultedOptions.retry === "undefined") defaultedOptions.retry = false;
		const query = this.queryCache.build(this, defaultedOptions);
		return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	prefetchQuery(arg1, arg2, arg3) {
		return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	fetchInfiniteQuery(arg1, arg2, arg3) {
		const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
		parsedOptions.behavior = infiniteQueryBehavior();
		return this.fetchQuery(parsedOptions);
	}
	/**
	* @deprecated This method should be used with only one object argument.
	*/
	prefetchInfiniteQuery(arg1, arg2, arg3) {
		return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
	}
	resumePausedMutations() {
		return this.mutationCache.resumePausedMutations();
	}
	getQueryCache() {
		return this.queryCache;
	}
	getMutationCache() {
		return this.mutationCache;
	}
	getLogger() {
		return this.logger;
	}
	getDefaultOptions() {
		return this.defaultOptions;
	}
	setDefaultOptions(options) {
		this.defaultOptions = options;
	}
	setQueryDefaults(queryKey, options) {
		const result = this.queryDefaults.find((x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));
		if (result) result.defaultOptions = options;
		else this.queryDefaults.push({
			queryKey,
			defaultOptions: options
		});
	}
	getQueryDefaults(queryKey) {
		if (!queryKey) return;
		const firstMatchingDefaults = this.queryDefaults.find((x) => partialMatchKey(queryKey, x.queryKey));
		if (this.queryDefaults.filter((x) => partialMatchKey(queryKey, x.queryKey)).length > 1) this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
		return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
	}
	setMutationDefaults(mutationKey, options) {
		const result = this.mutationDefaults.find((x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));
		if (result) result.defaultOptions = options;
		else this.mutationDefaults.push({
			mutationKey,
			defaultOptions: options
		});
	}
	getMutationDefaults(mutationKey) {
		if (!mutationKey) return;
		const firstMatchingDefaults = this.mutationDefaults.find((x) => partialMatchKey(mutationKey, x.mutationKey));
		if (this.mutationDefaults.filter((x) => partialMatchKey(mutationKey, x.mutationKey)).length > 1) this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
		return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
	}
	defaultQueryOptions(options) {
		if (options != null && options._defaulted) return options;
		const defaultedOptions = {
			...this.defaultOptions.queries,
			...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
			...options,
			_defaulted: true
		};
		if (!defaultedOptions.queryHash && defaultedOptions.queryKey) defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
		if (typeof defaultedOptions.refetchOnReconnect === "undefined") defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
		if (typeof defaultedOptions.useErrorBoundary === "undefined") defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
		return defaultedOptions;
	}
	defaultMutationOptions(options) {
		if (options != null && options._defaulted) return options;
		return {
			...this.defaultOptions.mutations,
			...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
			...options,
			_defaulted: true
		};
	}
	clear() {
		this.queryCache.clear();
		this.mutationCache.clear();
	}
};

//#endregion
//#region node_modules/@puzzlehq/sdk/dist/src/provider/queryProvider.js
var import_jsx_runtime = require_jsx_runtime();
const queryClient = new QueryClient();

//#endregion
//#region node_modules/zustand/esm/middleware.mjs
function createJSONStorage(getStorage, options) {
	let storage;
	try {
		storage = getStorage();
	} catch (_e) {
		return;
	}
	return {
		getItem: (name) => {
			var _a;
			const parse$1 = (str2) => {
				if (str2 === null) return null;
				return JSON.parse(str2, options == null ? void 0 : options.reviver);
			};
			const str = (_a = storage.getItem(name)) != null ? _a : null;
			if (str instanceof Promise) return str.then(parse$1);
			return parse$1(str);
		},
		setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),
		removeItem: (name) => storage.removeItem(name)
	};
}
var toThenable = (fn) => (input) => {
	try {
		const result = fn(input);
		if (result instanceof Promise) return result;
		return {
			then(onFulfilled) {
				return toThenable(onFulfilled)(result);
			},
			catch(_onRejected) {
				return this;
			}
		};
	} catch (e$1) {
		return {
			then(_onFulfilled) {
				return this;
			},
			catch(onRejected) {
				return toThenable(onRejected)(e$1);
			}
		};
	}
};
var oldImpl = (config, baseOptions) => (set, get, api) => {
	let options = {
		getStorage: () => localStorage,
		serialize: JSON.stringify,
		deserialize: JSON.parse,
		partialize: (state) => state,
		version: 0,
		merge: (persistedState, currentState) => ({
			...currentState,
			...persistedState
		}),
		...baseOptions
	};
	let hasHydrated = false;
	const hydrationListeners = /* @__PURE__ */ new Set();
	const finishHydrationListeners = /* @__PURE__ */ new Set();
	let storage;
	try {
		storage = options.getStorage();
	} catch (_e) {}
	if (!storage) return config((...args) => {
		console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
		set(...args);
	}, get, api);
	const thenableSerialize = toThenable(options.serialize);
	const setItem = () => {
		const state = options.partialize({ ...get() });
		let errorInSync;
		const thenable = thenableSerialize({
			state,
			version: options.version
		}).then((serializedValue) => storage.setItem(options.name, serializedValue)).catch((e$1) => {
			errorInSync = e$1;
		});
		if (errorInSync) throw errorInSync;
		return thenable;
	};
	const savedSetState = api.setState;
	api.setState = (state, replace) => {
		savedSetState(state, replace);
		setItem();
	};
	const configResult = config((...args) => {
		set(...args);
		setItem();
	}, get, api);
	let stateFromStorage;
	const hydrate = () => {
		var _a;
		if (!storage) return;
		hasHydrated = false;
		hydrationListeners.forEach((cb) => cb(get()));
		const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
		return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
			if (storageValue) return options.deserialize(storageValue);
		}).then((deserializedStorageValue) => {
			if (deserializedStorageValue) if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
				if (options.migrate) return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
				console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
			} else return deserializedStorageValue.state;
		}).then((migratedState) => {
			var _a2;
			stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
			set(stateFromStorage, true);
			return setItem();
		}).then(() => {
			postRehydrationCallback?.(stateFromStorage, void 0);
			hasHydrated = true;
			finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
		}).catch((e$1) => {
			postRehydrationCallback?.(void 0, e$1);
		});
	};
	api.persist = {
		setOptions: (newOptions) => {
			options = {
				...options,
				...newOptions
			};
			if (newOptions.getStorage) storage = newOptions.getStorage();
		},
		clearStorage: () => {
			storage?.removeItem(options.name);
		},
		getOptions: () => options,
		rehydrate: () => hydrate(),
		hasHydrated: () => hasHydrated,
		onHydrate: (cb) => {
			hydrationListeners.add(cb);
			return () => {
				hydrationListeners.delete(cb);
			};
		},
		onFinishHydration: (cb) => {
			finishHydrationListeners.add(cb);
			return () => {
				finishHydrationListeners.delete(cb);
			};
		}
	};
	hydrate();
	return stateFromStorage || configResult;
};
var newImpl = (config, baseOptions) => (set, get, api) => {
	let options = {
		storage: createJSONStorage(() => localStorage),
		partialize: (state) => state,
		version: 0,
		merge: (persistedState, currentState) => ({
			...currentState,
			...persistedState
		}),
		...baseOptions
	};
	let hasHydrated = false;
	const hydrationListeners = /* @__PURE__ */ new Set();
	const finishHydrationListeners = /* @__PURE__ */ new Set();
	let storage = options.storage;
	if (!storage) return config((...args) => {
		console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
		set(...args);
	}, get, api);
	const setItem = () => {
		const state = options.partialize({ ...get() });
		return storage.setItem(options.name, {
			state,
			version: options.version
		});
	};
	const savedSetState = api.setState;
	api.setState = (state, replace) => {
		savedSetState(state, replace);
		setItem();
	};
	const configResult = config((...args) => {
		set(...args);
		setItem();
	}, get, api);
	api.getInitialState = () => configResult;
	let stateFromStorage;
	const hydrate = () => {
		var _a, _b;
		if (!storage) return;
		hasHydrated = false;
		hydrationListeners.forEach((cb) => {
			var _a2;
			return cb((_a2 = get()) != null ? _a2 : configResult);
		});
		const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
		return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
			if (deserializedStorageValue) if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
				if (options.migrate) return [true, options.migrate(deserializedStorageValue.state, deserializedStorageValue.version)];
				console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
			} else return [false, deserializedStorageValue.state];
			return [false, void 0];
		}).then((migrationResult) => {
			var _a2;
			const [migrated, migratedState] = migrationResult;
			stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
			set(stateFromStorage, true);
			if (migrated) return setItem();
		}).then(() => {
			postRehydrationCallback?.(stateFromStorage, void 0);
			stateFromStorage = get();
			hasHydrated = true;
			finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
		}).catch((e$1) => {
			postRehydrationCallback?.(void 0, e$1);
		});
	};
	api.persist = {
		setOptions: (newOptions) => {
			options = {
				...options,
				...newOptions
			};
			if (newOptions.storage) storage = newOptions.storage;
		},
		clearStorage: () => {
			storage?.removeItem(options.name);
		},
		getOptions: () => options,
		rehydrate: () => hydrate(),
		hasHydrated: () => hasHydrated,
		onHydrate: (cb) => {
			hydrationListeners.add(cb);
			return () => {
				hydrationListeners.delete(cb);
			};
		},
		onFinishHydration: (cb) => {
			finishHydrationListeners.add(cb);
			return () => {
				finishHydrationListeners.delete(cb);
			};
		}
	};
	if (!options.skipHydration) hydrate();
	return stateFromStorage || configResult;
};
var persistImpl = (config, baseOptions) => {
	if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
		if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.");
		return oldImpl(config, baseOptions);
	}
	return newImpl(config, baseOptions);
};
var persist = persistImpl;

//#endregion
//#region node_modules/@puzzlehq/sdk/dist/src/store.js
const useWalletStore = create()(persist((set) => ({
	account: void 0,
	setAccount: (account) => {
		set({ account });
	},
	onDisconnect: () => {
		console.log("useWalletStore onDisconnect called");
		queryClient.clear();
		set({ account: void 0 });
	}
}), {
	name: "puzzle-wallet-store",
	version: 2
}));

//#endregion
//#region node_modules/@puzzlehq/sdk/dist/src/provider/connectionProvider.js
const ConnectionContext = (0, import_react.createContext)(void 0);

//#endregion
//#region node_modules/aleo-adapters/dist/puzzle.js
var import_dist$1 = require_dist();
function convertProgramIdPermissions(permissions) {
	const networkMapping = {
		[import_dist$1.WalletAdapterNetwork.MainnetBeta]: Network.AleoMainnet,
		[import_dist$1.WalletAdapterNetwork.TestnetBeta]: Network.AleoTestnet,
		[import_dist$1.WalletAdapterNetwork.Testnet]: Network.AleoTestnet
	};
	const convertedPermissions = {};
	for (const [key, value] of Object.entries(permissions)) {
		const network = networkMapping[key];
		if (network) convertedPermissions[network] = value;
	}
	return convertedPermissions;
}
Network.AleoMainnet;
const PuzzleWalletName = "Puzzle Wallet";
var PuzzleWalletAdapter = class extends import_dist$1.BaseMessageSignerWalletAdapter {
	name = PuzzleWalletName;
	url = "https://puzzle.online/wallet";
	icon = "data:image/png;base64,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";
	supportedTransactionVersions = null;
	_connecting;
	_wallet;
	_network = void 0;
	_appName;
	_appIconUrl;
	_appDescription;
	_programIdPermissions;
	_publicKey;
	_decryptPermission;
	_readyState = typeof window === "undefined" || typeof document === "undefined" ? import_dist$1.WalletReadyState.Unsupported : import_dist$1.WalletReadyState.NotDetected;
	constructor({ appName, appIconUrl, appDescription, programIdPermissions }) {
		super();
		this._appName = appName;
		this._appIconUrl = appIconUrl;
		this._appDescription = appDescription;
		this._programIdPermissions = convertProgramIdPermissions(programIdPermissions);
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		this._decryptPermission = import_dist$1.DecryptPermission.NoDecrypt;
		if (this._readyState !== import_dist$1.WalletReadyState.Unsupported) (0, import_dist$1.scopePollingDetectionStrategy)(() => {
			if (window?.puzzle) {
				this._readyState = import_dist$1.WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			} else if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
				this._readyState = import_dist$1.WalletReadyState.Loadable;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get decryptPermission() {
		return this._decryptPermission;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	set readyState(readyState) {
		this._readyState = readyState;
	}
	async decrypt(cipherText, tpk, programId, functionName, index) {
		try {
			if (!this._wallet || !this.publicKey) throw new import_dist$1.WalletNotConnectedError();
			switch (this._decryptPermission) {
				case import_dist$1.DecryptPermission.NoDecrypt: throw new import_dist$1.WalletDecryptionNotAllowedError();
				case import_dist$1.DecryptPermission.UponRequest:
				case import_dist$1.DecryptPermission.AutoDecrypt:
				case import_dist$1.DecryptPermission.OnChainHistory: try {
					return (await decrypt({ ciphertexts: [cipherText] })).plaintexts[0];
				} catch (error) {
					throw new import_dist$1.WalletDecryptionError(error?.message || "Permission Not Granted", error);
				}
				default: throw new import_dist$1.WalletDecryptionError();
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecords(program) {
		try {
			if (!this._wallet || !this.publicKey) throw new import_dist$1.WalletNotConnectedError();
			try {
				const filter = {
					programIds: [program],
					status: "Unspent"
				};
				return (await getRecords({
					address: this.publicKey,
					filter,
					network: this._network
				})).records.map((record) => {
					return {
						...record,
						owner: this.publicKey,
						program_id: program,
						spent: false
					};
				});
			} catch (error) {
				throw new import_dist$1.WalletRecordsError(error?.message || "Permission Not Granted", error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestTransaction(transaction) {
		try {
			if (!this._wallet || !this.publicKey) throw new import_dist$1.WalletNotConnectedError();
			try {
				const result = await requestCreateEvent({
					type: EventType.Execute,
					programId: transaction.transitions[0].program,
					functionId: transaction.transitions[0].functionName,
					fee: transaction.fee / 1e6,
					inputs: transaction.transitions[0].inputs,
					address: this._publicKey,
					network: this._network
				});
				if (result.error) throw new Error(result.error);
				else if (result.eventId === void 0 || result.eventId === "") throw new Error("Could not create transaction.");
				return result.eventId;
			} catch (error) {
				throw new import_dist$1.WalletTransactionError(error?.message || "Permission Not Granted", error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async transactionStatus(transactionId) {
		try {
			if (!this._wallet || !this.publicKey) throw new import_dist$1.WalletNotConnectedError();
			try {
				const result = await getEvent({
					id: transactionId,
					address: this.publicKey,
					network: this._network
				});
				return result.event ? result.event.status == EventStatus.Settled ? "Finalized" : result.event.status : "";
			} catch (error) {
				throw new import_dist$1.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecordPlaintexts(program) {
		return this.requestRecords(program);
	}
	async connect(decryptPermission, network) {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== import_dist$1.WalletReadyState.Installed && this._readyState !== import_dist$1.WalletReadyState.Loadable) throw new import_dist$1.WalletNotReadyError();
			this._connecting = true;
			try {
				const connectResponse = await connect({
					dAppInfo: {
						name: this._appName,
						iconUrl: this._appIconUrl,
						description: this._appDescription
					},
					permissions: { programIds: this._programIdPermissions }
				});
				this._wallet = connectResponse.connection;
				this._publicKey = connectResponse.connection.address;
				this._network = [import_dist$1.WalletAdapterNetwork.Testnet, import_dist$1.WalletAdapterNetwork.TestnetBeta].includes(network) ? Network.AleoTestnet : Network.AleoMainnet;
				this.emit("connect", this._publicKey);
			} catch (error) {
				throw new import_dist$1.WalletConnectionError(error?.message, error);
			}
			this._decryptPermission = decryptPermission;
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		if (this._wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await disconnect();
			} catch (error) {
				this.emit("error", new import_dist$1.WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signMessage(message) {
		try {
			if (!this._wallet || !this.publicKey) throw new import_dist$1.WalletNotConnectedError();
			try {
				const signature = await requestSignature({
					message: new TextDecoder().decode(message),
					address: this.publicKey,
					network: this._network
				});
				return new TextEncoder().encode(signature.signature);
			} catch (error) {
				throw new import_dist$1.WalletSignTransactionError(error?.message || "Permission Not Granted", error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	requestDeploy(deployment) {
		throw new Error("Method not implemented.");
	}
	requestExecution(transaction) {
		throw new Error("Method not implemented.");
	}
	requestBulkTransactions(transactions) {
		throw new Error("Method not implemented.");
	}
	getExecution(transactionId) {
		throw new Error("Method not implemented.");
	}
	requestTransactionHistory(program) {
		throw new Error("Method not implemented.");
	}
};

//#endregion
//#region node_modules/aleo-adapters/dist/soter.js
var import_dist = require_dist();
const SoterWalletName = "Soter Wallet";
var SoterWalletAdapter = class extends import_dist.BaseMessageSignerWalletAdapter {
	name = SoterWalletName;
	url = "https://chromewebstore.google.com/detail/soter-aleo-wallet/gkodhkbmiflnmkipcmlhhgadebbeijhh";
	icon = "data:image/png;base64,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";
	supportedTransactionVersions = null;
	_connecting;
	_wallet;
	_publicKey;
	_decryptPermission;
	_readyState = typeof window === "undefined" || typeof document === "undefined" ? import_dist.WalletReadyState.Unsupported : import_dist.WalletReadyState.NotDetected;
	constructor({} = {}) {
		super();
		this._connecting = false;
		this._wallet = null;
		this._publicKey = null;
		this._decryptPermission = import_dist.DecryptPermission.NoDecrypt;
		if (this._readyState !== import_dist.WalletReadyState.Unsupported) (0, import_dist.scopePollingDetectionStrategy)(() => {
			if (window?.soter || window?.soterWallet) {
				this._readyState = import_dist.WalletReadyState.Installed;
				this.emit("readyStateChange", this._readyState);
				return true;
			}
			return false;
		});
	}
	get publicKey() {
		return this._publicKey;
	}
	get decryptPermission() {
		return this._decryptPermission;
	}
	get connecting() {
		return this._connecting;
	}
	get readyState() {
		return this._readyState;
	}
	set readyState(readyState) {
		this._readyState = readyState;
	}
	async decrypt(cipherText, tpk, programId, functionName, index) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			switch (this._decryptPermission) {
				case import_dist.DecryptPermission.NoDecrypt: throw new import_dist.WalletDecryptionNotAllowedError();
				case import_dist.DecryptPermission.UponRequest:
				case import_dist.DecryptPermission.AutoDecrypt:
				case import_dist.DecryptPermission.OnChainHistory: try {
					return (await wallet.decrypt(cipherText, tpk, programId, functionName, index)).text;
				} catch (error) {
					throw new import_dist.WalletDecryptionError(error?.message, error);
				}
				default: throw new import_dist.WalletDecryptionError();
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecords(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				return (await wallet.requestRecords(program)).records;
			} catch (error) {
				throw new import_dist.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestTransaction(transaction) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				transaction.fee = 10;
				const transactionId = (await wallet.requestTransaction(transaction)).transactionId;
				if (!transactionId || transactionId.length == 0) throw new import_dist.WalletTransactionError("Permission Not Granted");
				return transactionId;
			} catch (error) {
				throw new import_dist.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestBulkTransactions(transactions) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				const result = await wallet.requestBulkTransactions(transactions);
				return result.transactionIds ? result.transactionIds : [];
			} catch (error) {
				throw new import_dist.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestDeploy(deployment) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				const result = await wallet.requestDeploy(deployment);
				return result.transactionId ? result.transactionId : "";
			} catch (error) {
				throw new import_dist.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async transactionStatus(transactionId) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				const result = await wallet.transactionStatus(transactionId);
				return result.status ? result.status : "";
			} catch (error) {
				throw new import_dist.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	requestExecution(_transaction) {
		throw new Error("Method not implemented.");
	}
	async getExecution(transactionId) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				return (await wallet.getExecution(transactionId)).execution;
			} catch (error) {
				throw new import_dist.WalletTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestRecordPlaintexts(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				return (await wallet.requestRecordPlaintexts(program)).records;
			} catch (error) {
				throw new import_dist.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async requestTransactionHistory(program) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				return (await wallet.requestTransactionHistory(program)).transactions;
			} catch (error) {
				throw new import_dist.WalletRecordsError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
	async connect(decryptPermission, network, programs) {
		try {
			if (this.connected || this.connecting) return;
			if (this._readyState !== import_dist.WalletReadyState.Installed) throw new import_dist.WalletNotReadyError();
			this._connecting = true;
			const wallet = window.soterWallet || window.soter;
			try {
				await wallet.connect(decryptPermission, network, programs);
				if (!wallet?.publicKey) throw new import_dist.WalletConnectionError();
				this._publicKey = wallet.publicKey;
			} catch (error) {
				throw new import_dist.WalletConnectionError(error?.message, error);
			}
			this._wallet = wallet;
			this._decryptPermission = decryptPermission;
			this.emit("connect", this._publicKey);
		} catch (error) {
			this.emit("error", error);
			throw error;
		} finally {
			this._connecting = false;
		}
	}
	async disconnect() {
		const wallet = this._wallet;
		if (wallet) {
			this._wallet = null;
			this._publicKey = null;
			try {
				await wallet.disconnect();
			} catch (error) {
				this.emit("error", new import_dist.WalletDisconnectionError(error?.message, error));
			}
		}
		this.emit("disconnect");
	}
	async signMessage(message) {
		try {
			const wallet = this._wallet;
			if (!wallet || !this.publicKey) throw new import_dist.WalletNotConnectedError();
			try {
				const signature = await wallet.signMessage(message);
				if (signature.signature.errorCode != 0) throw new Error("Permission Not Granted");
				return new TextEncoder().encode(signature.signature.result);
			} catch (error) {
				throw new import_dist.WalletSignTransactionError(error?.message, error);
			}
		} catch (error) {
			this.emit("error", error);
			throw error;
		}
	}
};

//#endregion
//#region node_modules/aleo-adapters/dist/version.js
const version = "1.2.1";

//#endregion
export { FoxWalletAdapter, FoxWalletName, LeoWalletAdapter, LeoWalletName, PuzzleWalletAdapter, PuzzleWalletName, SoterWalletAdapter, SoterWalletName, version };
//# sourceMappingURL=aleo-adapters.js.map