import { z } from 'zod';
import { Transaction } from './aleo.js';

export type Account = {
  _id: string;
  address: string;
  viewkey: string;
  viewer: string;
  created?: Date;
  lastAccessed?: Date;
  imported: boolean;
  shared: boolean;
  walletAddress?: string;
  archivedHeight?: number;
  archivedHeightTestnet?: number;
};

export type AccountAuth = {
  address: string;
  challenge?: string;
  expiration_date?: Date;
};

export type EventTransition = {
  transitionId: string;
  programId: string;
  functionId: string;
  inputs: (string | null)[];
  outputs: (string | null)[];
};

type TransitionCreate = {
  transitionId: string;
  programId: string;
  functionId: string;
  inputs?: string[];
  outputs?: string[];
};

export type Asset = {
  tokenId: string; // field
  name: string;
  symbol?: string;
  programId: string;
  decimals: number; // u8 in metadata
  supply?: number; // u128 in metadata
  max_supply?: number; // u128 in metadata
  isARC20: boolean;
  displayIfZero?: boolean;
  recordName: string;
};

export type AssetV2 = {
  tokenId: string; // field
  name: string;
  symbol?: string;
  decimals: number; // u8 in metadata
  supply?: number; // u128 in metadata
  maxSupply?: number; // u128 in metadata
  admin?: string; // address in metadata
  externalAuthorizationRequired?: boolean;
  externalAuthorizationParty?: string; // address in metadata

  isMTSP: boolean;

  programId: string;
  recordName: string; // Token if isMTSP === true

  displayIfZero?: boolean;
  iconURL?: string;
  usageCount?: number;
  priority: number;
  coinbaseSymbol?: string;
};

type ClientInfo = {
  client: 'ios' | 'android' | 'extension';
  version: string;
  device?: string;
};

export type Event = {
  _id: string;
  type: EventType;
  owner: string;

  status: EventStatus;
  created: Date;
  broadcast?: Date;
  broadcastHeight?: number;
  settled?: Date;

  network: Network;
  transactionId?: string;
  height?: number;
  description?: string;
  visibility: Visibility;

  fee: number;
  feeCovered?: boolean;
  feeCoverageType?: CoverageType;
  functionId?: string;
  programId?: string;

  inputs: string[];
  transitions: EventTransition[];
  feeTransition?: EventTransition;

  error?: string;

  tokenIds?: string[];
  giveawayId?: string;

  clientInfo?: ClientInfo;

  questRewardId?: string;

  // for re-broadcasting until Settled or Failed
  // set on broadcast
  // unset on Settled (patience settlements)
  // unset on Failed (checkPendingTransactions.ts)
  transaction?: Transaction;
  // // for store fulfillments, reprove until Settled or Failed
  // // set on initial and subsequent broadcasts
  // // unset on Settled (patience settlements)
  // // unset on Failed (broadcasts.ts)
  // proveAttempts?: number;
};

export type EventCreate = {
  type: EventType;
  owner: string;
  description?: string;
  network: Network;
  functionId?: string;
  programId?: string;
  visibility?: Visibility;
  inputs?: string[];
  transitions?: TransitionCreate[];
  tokenIds?: string[];
  clientInfo?: ClientInfo;
};

export type Record = {
  _id: string;
  eventId?: string;
  height: number;
  timestamp: Date;
  ciphertext: string;
  programId: string;
  functionId: string;
  name: string;
  network: Network;
  transactionId: string;
  transitionId: string;
  /// output index
  index: number;
  status: RecordStatus;
  owner?: string | null;
  spentEventId?: string;
  serialNumber?: string | null;
};

export enum RecordStatus {
  Unspent = 'Unspent',
  Pending = 'Pending',
  Spent = 'Spent',
}

export type StringRecord = {
  [key: string]: string | StringRecord;
};

export const getNestedProperty = (
  data: StringRecord,
  path: string[]
): string | StringRecord | undefined => {
  let result: string | StringRecord = data;
  for (const key of path) {
    if (typeof result !== 'object' || result[key] === undefined) {
      return undefined;
    }
    result = result[key];
  }
  return result;
};

export const getNestedStringProperty = (
  data: StringRecord,
  path: string[]
): string | undefined => {
  const result = getNestedProperty(data, path);
  if (typeof result === 'string') {
    return result;
  }
  return undefined;
};

export type RecordWithPlaintext = Record & {
  plaintext: string;
  microcredits: number;
  data: StringRecord;
};

export type BalanceValues = {
  private: number;
  public: number;
};

export type Balance = AssetV2 & {
  owner: string;
  network: Network;
  values: BalanceValues;
};

/// enums

export enum EventType {
  Deploy = 'Deploy',
  Execute = 'Execute',
  Send = 'Send',
  Receive = 'Receive',
  Join = 'Join',
  Split = 'Split',
  Shield = 'Shield',
  Unshield = 'Unshield',
  Referral = 'Referral',
  Points = 'Points',

  /// arcade
  Spin = 'Spin',
  Raffle = 'Raffle',
  Mint = 'Mint',
  StoreStock = 'Store Stock',
  StorePurchase = 'Store Purchase',
  StoreFulfillment = 'Store Fulfillment',
  GiveawayEntry = 'Giveaway Entry',
  GiveawayDraw = 'Giveaway Draw',
  GiveawayWin = 'Giveaway Win',
  SquashMint = 'Squash Mint',
  SquashWater = 'Squash Water',
  SquashLevelUp = 'Squash Level Up',
  MysteryCity = 'Mystery City',
  CatCharmer = 'Cat Charmer',
}

export enum EventStatus {
  Creating = 'Creating',
  Pending = 'Pending',
  Settled = 'Settled',
  Failed = 'Failed',
}

export enum Visibility {
  Private = 'Private',
  Public = 'Public',
}

export enum Network {
  AleoTestnet = 'AleoTestnet',
  AleoMainnet = 'AleoMainnet',
}

export type CoverageType = 'pro' | 'all' | 'none';

/// note: these are not necessarily correct yet (except for testnet3)
export const networkPath = (network: Network): string => {
  switch (network) {
    case Network.AleoTestnet:
      return 'testnet';
    case Network.AleoMainnet:
      return 'mainnet';
  }
};

export const zodEventType = z.nativeEnum(EventType);
export const zodEventStatus = z.nativeEnum(EventStatus);
export const zodNetwork = z.nativeEnum(Network);
export const zodVisibility = z.nativeEnum(Visibility);
export const zodRecordStatus = z.nativeEnum(RecordStatus);

export * from './aleo.js';
